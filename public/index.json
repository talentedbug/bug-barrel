[{"content":"本蛾子家里有一部香橙派 Zero 3 一直在吃灰。\n最近期末复习，大量打印试卷，只有蛾爸的台式机连着一台 HP LaserJet 打印机，不得不断断续续打扰他玩游戏去打印。蛾爸说，唉，要么买一台带 Wi-Fi 打印功能的新打印机吧！一看价格，动辄 2000 多。\n于是本蛾子在网上搜了搜，发现 HP 对 Linux 的驱动支持很好。在提出将打印机挪到本蛾子的房间的要求并被拒绝之后，猛地想起来这部吃灰的香橙派，插电看看，更新一下包，还能用。遂记录一下操作方法供您参考 😁\n🛜 Wi-Fi 上网 之前这部单板机一直都是直接插网线上网的，但由于房间里唯一的网线接口被蛾爸的台式机占据，不得不使用无线网络。\nArmbian 竟然不自带 network-manager，先自己装一个。\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade sudo apt install network-manager sudo systemctl enable --now NetworkManager # 大小写敏感 然后用 nmtui 连接一下无线网。\nsudo nmtui 然后选择你的 Wi-Fi 连接即可。\n使用 ip addr 验证一下：\n可以发现已经 DHCP 了一个 Wi-Fi IP 段的 IP。\n本蛾子家的路由器似乎不按照递增的顺序添加 IP，因此还需要设置一下静态 IP，以防失联：\nsudo nmtui 重启一下 network-manager 看看：\nsudo systemctl restart NetworkManager 很好，还是原来的 IP 地址。现在我们临时关闭 SSH 强制证书认证（撤销使用 SSH 公钥登录服务器并禁用密码中的操作），用 Wi-Fi IP 连接一下。\n重启 sshd：\nsudo systemctl restart sshd 这时候，不要着急关闭原来的 SSH 连接，新开一个窗口，用新 IP 地址连接。\n成功 ✌️ 然后您可以按照上面那篇文章的方法，重新生成证书并关闭密码登录。\n🖨 CUPS 配置 sudo apt install cups sudo usermod -aG lpadmin USER_NAME # 添加已有的用户为管理员 # sudo useradd -m -G lpadmin USER_NAME # 也可以新建一个用户 # passwd USER_NAME # 记得修改密码 sudo cupsctl --remote-any 如果您使用防火墙，记得放行 631 端口：\nsudo firewall-cmd --add-port=631/tcp --permanent sudo firewall-cmd --reload 然后就可以从 http://YOUR_IP:631 访问到 CUPS 的管理页面了。\n其实 CUPS 最初是 Apple 在开发，因为其 macOS 也是 UNIX-like 系统，为其开发了打印机管理工具。但是后来开发工作似乎转交给了 OpenPrinting，所以这个版本上首页不再出现 Apple 字样了。\n然后接上你的打印机，只要不是特别远古的基本都是 USB 接口了，然后点击上面页面中的「Administration」，会要求您使用 HTTPS 访问，如果出现证书无效的警告，这是因为 HTTPS 使用的证书是自签发的，浏览器没法验证，直接继续访问即可。\n点击「Add Printer」。然后需要您用刚刚创建或者添加权限的那个用户登录。\n大部分 Linux 发行版都自带 HP 打印机的驱动，没啥问题的话，应该可以直接找到打印机，例如本蛾子的 HP LasetJet M1005 是可以自动识别的。\n直接选择，然后点击「Continue」。然后填写一下向用户展示的信息，这个大概是无所谓的，保持默认即可。注意一定要勾选「Share This Printer」，以便内网用户访问。\n然后会让您选择型号，但是本蛾子发现这里并没有 M1005 的选项。搜了一下，需要装一个 PDD 描述文件。\nsudo apt install hplip 装完刷新一下页面，重新填写。这样就有了，但是不知道为什么有三个 🤔\n然后提示添加成功，但是最好还是打印一下测试页，因为就算描述文件是错误的也不会给出警告。\n果不其然，打印失败了。搜索一下，发现这部打印机需要专有驱动支持，直接使用 hp-plugin 安装，发现下载非常慢，因此转而在本机下载，然后用 SFTP 传送到单板机上。\nchmod +x hplip-3.22.10-plugin.run sudo hp-plugin -i # 输入 `p`，然后输入路径，忽略没有密钥的警告 这时候再打印测试页，发现打印成功，主要是 CUPS 的图标、Debian 的图标，还有一些色阶的测试（当然是看不来的，黑白打印啊），下面输出了一些信息。\n🖥 客户端设置 Windows 打印，到这里就结束了，只需要在设置里添加设备，就能自动扫描网络并找到设备。但是 Linux 和 macOS 还需要额外设置。\n根据 ArchWiki 的说明，您不应当在客户端和服务端都启用 hplip 提供的驱动，否则文件会被 filter 两次，导致打印失败。\n先在本地也部署一下 CUPS：\nsudo pacman -Sy cups sudo systemctl start cups 本地其实并不需要安装驱动，但是以防万一，您可以按照上面服务端的做法安装一下 hplip 包并安装专有插件。KDE Plasma 有自带的打印机管理界面，但是不能使用，因为这玩意儿缺了很多 CUPS 网页管理界面的功能，因此打开 localhost:631，依然在网页端操作。\n首先依然选择添加打印机的选项，但这次我们选择 IPP 协议的打印机。\n按照 ipp://IP:PORT/printer/QUEUE_NAME 输入地址。\n这里设置名称，不需要和服务端保持一致，不勾选共享打印机。\n下一步，注意一定要选择「Raw」里的「IPP Everywhere™」，避免上面说到的两次 filter 问题。\n然后保持默认选项，打印机就添加完成了！打印一张测试页试试。\n这回测试页上并没有 Arch Linux 的徽标，只有 CUPS 的，而且测试也少很多。\n🎆 下课 现在本蛾子可以方便地从自己的房间打印试卷了，只需要去拿一下打印完的纸张。蛾爸也终于不怕玩游戏被打断了……\n","permalink":"http://localhost:1313/posts/fdf8cb41df/","summary":"\u003cp\u003e本蛾子家里有一部\u003ca href=\"http://www.orangepi.org/html/hardWare/computerAndMicrocontrollers/details/Orange-Pi-Zero-3.html\"\u003e香橙派 Zero 3\u003c/a\u003e 一直在吃灰。\u003c/p\u003e\n\u003cp\u003e最近期末复习，大量打印试卷，只有蛾爸的台式机连着一台 HP LaserJet 打印机，不得不断断续续打扰他玩游戏去打印。蛾爸说，唉，要么买一台带 Wi-Fi 打印功能的新打印机吧！一看价格，动辄 2000 多。\u003c/p\u003e\n\u003cp\u003e于是本蛾子在网上搜了搜，发现 HP 对 Linux 的驱动支持很好。在提出将打印机挪到本蛾子的房间的要求并被拒绝之后，猛地想起来这部吃灰的香橙派，插电看看，更新一下包，还能用。遂记录一下操作方法供您参考 😁\u003c/p\u003e\n\u003ch2 id=\"-wi-fi-上网\"\u003e🛜 Wi-Fi 上网\u003c/h2\u003e\n\u003cp\u003e之前这部单板机一直都是直接插网线上网的，但由于房间里唯一的网线接口被蛾爸的台式机占据，不得不使用无线网络。\u003c/p\u003e\n\u003cp\u003eArmbian 竟然不自带 \u003ccode\u003enetwork-manager\u003c/code\u003e，先自己装一个。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt update \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt upgrade\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install network-manager\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo systemctl \u003cspan class=\"nb\"\u003eenable\u003c/span\u003e --now NetworkManager \u003cspan class=\"c1\"\u003e# 大小写敏感\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后用 \u003ccode\u003enmtui\u003c/code\u003e 连接一下无线网。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo nmtui\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"image-20250110222603503\" loading=\"lazy\" src=\"../../static/img/fdf8cb41df.d/image-20250110222603503.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250110222704440\" loading=\"lazy\" src=\"../../static/img/fdf8cb41df.d/image-20250110222704440.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然后选择你的 Wi-Fi 连接即可。\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003eip addr\u003c/code\u003e 验证一下：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250110222913786\" loading=\"lazy\" src=\"../../static/img/fdf8cb41df.d/image-20250110222913786.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可以发现已经 DHCP 了一个 Wi-Fi IP 段的 IP。\u003c/p\u003e\n\u003cp\u003e本蛾子家的路由器似乎不按照递增的顺序添加 IP，因此还需要设置一下静态 IP，以防失联：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo nmtui\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg alt=\"image-20250110223114160\" loading=\"lazy\" src=\"../../static/img/fdf8cb41df.d/image-20250110223114160.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250110223137620\" loading=\"lazy\" src=\"../../static/img/fdf8cb41df.d/image-20250110223137620.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250110223252638\" loading=\"lazy\" src=\"../../static/img/fdf8cb41df.d/image-20250110223252638.png\"\u003e\u003c/p\u003e\n\u003cp\u003e重启一下 \u003ccode\u003enetwork-manager\u003c/code\u003e 看看：\u003c/p\u003e","title":"使用单板机为旧打印机添加局域网共享"},{"content":"最近本蛾子发现之前搭建的代理，访问部分国内网站的时候不光速度很慢，而且有时候会报 PR_END_OF_FILE_ERROR（无法确定内容完整性，就是远程，特别是 CSDN，全站都无法访问。\n😮‍💨 唉：后来发现其实是服务端 WARP 的问题，跟 v2rayA 一毛钱关系都没有。\n本蛾子现在使用的 v2rayA 虽然安装起来很方便（Arch Linux CN 有打包），但是对于规则的支持并不算好，并且开启、关闭、切换节点的速度也不尽人意。在网上搜索一通，似乎眼下最完善的内核是 Clash 系列的后继者 Mihomo，因此本蛾子就用它来学习一下如何书写 Clash 配置文件。\n💻 客户端选择 Clash 系的客户端在 AUR 上基本全部都有打包。根据本蛾子的测试，似乎还在开发且可用性比较高的，只有 Clash Verge Rev 和 FlClash，而后者的 UI 设计本蛾子看着非常舒服，因此本文就以 FlClash 作为测试客户端。\n首先对 FlClash 的软件设置进行调整。虽然诸多 Clash 系客户端使用同一个内核，但是其 UI 设计却千差万别。FlClash 的界面大概是这样的。\n在 Tools 栏目中，主要是软件本身和覆写配置文件的选项，前者是主题、日志、自动启动等本地定义的选项，不出现在配置文件中，因此我们首先来完成对其的设置。覆写配置文件的设置主要针对使用远程配置文件（例如机场）的用户，方便修改配置文件。\n选项大部分您都应该能理解，说几个比较迷惑的：\nLogcat：就是日志功能，记录您使用代理访问的网站，关闭之后不会记录，但是似乎需要手动删除之前的记录（位于您的主目录下）。 Auto lost connections：在切换节点之后切断当前存在的连接，开启之后换区域会更加彻底，但是您的下载会被终端。 Only statistics proxy：只对通过的流量进行记录，这时候 FlClash 就变成了一个网络监测工具。 当然这个栏目还有其他功能，比如设置语言、主题、备份之类的，就请您自己探索了。\n⚙️ 配置文件 这当然就是本文的重点了！通过 Clash 配置文件，您可以方便地修改 DNS、分流、（基础）去广告等，至于节点链接，倒成了配置文件中不太重要的一部分了。下面本蛾子参考了一些链接和项目，为行文流畅就不一一列出角标了，一并在文末引用。\n您书写的配置文件应当保存在任意名称的 .yaml 文件中，在 FlClash 中这样引用：\n🏠 基础 Clash 配置文件使用 YAML 的语法，以 key: value 的形式书写，注意中间的空格不可以省略。如果一个键有子键，那么需要缩进并添加 -；注释以 # 开头。示例请见下文说明。\n一个 Clash 配置文件类似于这样：\nmixed-port: 7890 allow-lan: false # bind-address: \u0026#34;*\u0026#34; ipv6: true mode: rule log-level: info # external-controller: 127.0.0.1:9090 # secret:\u0026#34;\u0026#34; dns: proxies: proxy-groups: rules: 每一个选项的含义：\nmixed-port：混合端口，即 Clash 内核所使用的端口，支持 HTTP、SOCKS 等代理协议混用。 allow-lan：是否允许局域网连接，如果您希望连接其他设备可以连接代理，您应当将其设置为 true，公用网络下无论如何都应当设置为 false 来保证安全。 bind-address：绑定地址，在 allow-lan: true 的情况下，端口允许的地址，例如 0.0.0.0 代表您设备在网络中的 IP 地址（所有 IPv4 设备均可连接），127.0.0.1 代表回环地址（只有本机可以连接），:: 代表您设备的 IPv6 地址等等；设置为 \u0026quot;*\u0026quot; 即允许所有设备连接。 ipv6：是否启用 IPv6，这要看您路由器是否支持。设为 true 没啥坏处。 mode：模式，接下来我们将使用规则集，因此要设成 rule 即规则模式。其他还有 direct（不走代理）和 global（全走代理）。 log-level：日志等级，info 比较适中，也可设成 error（仅错误）、warning（错误和警告）、debug（所有记录）、silent（不输出）。 external-controller 和 secret：控制端口和密码，非常建议设置为 127.0.0.1 而非 0.0.0.0，后者将把控制界面向局域网开放。 其他的是接下来讨论的重点。 当然其实还有个 authentication 即代理认证功能，请您自行查阅文末引用，有详细介绍。本文主要讨论作为本地代理的功能，不过度介绍。\n🗺️ DNS 在上述配置中继续添加。\nDNS 是互联网上用于查找域名对应 IP 地址的工具，您在浏览器中输入的所有域名都会被发送到 DNS 服务器解析，然后再访问 IP。由于纯 DNS 使用的是未经加密的 UDP 包，非常容易被污染篡改，早年间的 GFW 主要就采用 DNS 污染的方式封禁域名。\n说实话，本蛾子建议您就算不使用代理，也按照下文方法（在 FlClash 或操作系统中）设置安全的 DNS 方案，详情请见文末引用的部分文章。\n但是后来由于 DoH 即 DNS over HTTPS 技术的出现（其实还有 HTTPS 本身），GFW 原本准确的 DNS 污染和选择性屏蔽页面形同虚设，就开始使用 IP 黑洞这种最简单、最暴力的方法屏蔽一些网站。\n当然对于 Cloudflare 这种 IP 大户还是没什么用，于是对于 *.pages.dev 和 *.workers.dev 又开始了域名封锁。\n无论如何，您在使用代理时，最好还是要添加一下 DNS 配置。例如：\ndns: enable: true prefer-h3: true use-hosts: true use-system-hosts: true respect-rules: false listen: 0.0.0.0:1053 ipv6: false enhanced-mode: fake-ip fake-ip-range: 198.18.0.1/16 # fake-ip-filter: # - \u0026#39;*.lan\u0026#39; # - \u0026#34;+.local\u0026#34; # - localhost.ptlogin2.qq.com default-nameserver: - 8.8.8.8 - 1.1.1.1 - 223.5.5.5 - 119.29.29.29 # nameserver-policy: # \u0026#39;www.baidu.com\u0026#39;: \u0026#39;114.114.114.114\u0026#39; # \u0026#39;+.internal.crop.com\u0026#39;: \u0026#39;10.0.0.1\u0026#39; # \u0026#39;geosite:cn,private\u0026#39;: # - https://223.5.5.5/dns-query # - https://223.6.6.6/dns-query nameserver: - https://dns.alidns.com/dns-query - https://doh.pub/dns-query proxy-server-nameserver: - https://dns.alidns.com/dns-query - https://doh.pub/dns-query fallback: - https://dns.google/dns-query - https://cloudflare-dns.com/dns-query - 8.8.8.8 - 1.1.1.1 fallback-filter: geoip: true geoip-code: CN geosite: - gfw ipcidr: - 240.0.0.0/4 - 0.0.0.0/32 - 127.0.0.1/32 # domain: # - \u0026#39;+.google.com\u0026#39; # - \u0026#39;+.facebook.com\u0026#39; # - \u0026#39;+.youtube.com\u0026#39; 简单解释一下：\nenable：启用 DNS 设置。\nprefer-h3：加密的、使用 QUIC 实现的 DNS 协议，有助于加快查询速度。\nuse-hosts 和 use-system-hosts：是否使用 hosts 优先查询。hosts 是独立于 DNS 系统的查询文件，一般在操作系统中定义，可以把某些地址强制解析到特定 IP 上，例如实际上 localhost 这个地址并不存在，是操作系统在 hosts 中定义了 127.0.0.1 localhost。建议开启。\nrespect-rules：优先遵守下文规则的设置，如果您使用机场，不建议开启，因为如果机场定义了 DNS 设置会导致您的配置失效。（如果没有，就无所谓了，这玩意儿就成了「自尊」😄）\nfake-ip-*：这是个比较有意思的东西。正常来说，浏览器查询 DNS 服务器，得到 IP，然后访问；但是如果 Clash 开启了 fake-ip，浏览器得到 Clash 的解析结果都指向 fake-ip-range 中的一个随机地址，然后对其发送请求，再由 Clash 来请求服务端。\n由此也可以发现，Clash 运行时一定会劫持 DNS，所以如果您发现 DNS 设置不正常，不必惊慌。\nfake-ip-filter 还可以定义不使用 fake-ip 的地址，一般不需要，除了 QQ 对于本地的请求也使用域名……\ndefault-nameserver：如果定义了 nameserver，此配置将用于解析 DoH 域名，从上至下轮询直到得到第一个结果。由于我们使用代理，就优先选择国外服务；如果您想配置不开代理的 DoH，需要将国内的几个调到上面。\nDoH 地址也是域名，也需要解析……所以有的时候称为「引导域名服务器」。\nnameserver：默认 DNS 服务器，但是由于下文设置了 fallback-filter，所有 GeoIP 非 CN 的域名实际上会采用 fallback，因此这里仅针对国内网站。\nnameserver-policy：域名解析规则，对于特定域名采用指定 DNS 服务器。\nproxy-server-nameserver：用于解析代理服务器域名的 DNS 服务器，建议设国内地址，因为这个流量不走代理。\nfallback：后备 DNS 服务器。若第一轮解析结果显示其 GeoIP 非 CN，则使用这些服务器验证。\nfallback-filter：过滤器，负责决定哪些域名需要使用 fallback 验证：\ngeoip-code：除了该国家代码的解析结果，全部视为已经污染，进入 fallback。\ngeosite：在列表中的全部视为污染，进入 fallback。\nipcidr：如果解析结果是这些网段，则认为是污染。\n这是因为 GFW 在 DNS 污染之后还是要返回结果的，通常就是回环地址或者不存在的 IP，因此可以根据这一点来判断是否被污染。文末的维基学院参考提供了一个污染返回的结果列表，但是本蛾子未采用，因为该列表有极大概率滥杀无辜 😮‍💨\ndomain：对于这些域名，直接使用 fallback。\n👷‍♂️ 代理 这里你应当填写你的订阅链接。如果您获得的链接是类似于 vless://... 的格式，您需要先进行转换。下面本蛾子给出一个示范。\n对于 vless://[UUID]@[DOMAIN]:[PORT]?encryption=[ENCRYPTION]\u0026amp;security=[SECURITY]\u0026amp;type=[TYPE]\u0026amp;host=[DOMAIN]\u0026amp;path=[UUID2]#[TAB] 这样的链接，如果我们使用 v2rayA 进行解析（自动分开各个部分），就会发现实际上是这个意思：\n那么根据 Clash 对应格式，就应该写为：\nproxies: - name: \u0026#34;any_name_is_okay\u0026#34; type: vless server: [DOMAIN] port: [PORT] uuid: [UUID] udp: true tls: true network: ws servername: [DOMAIN] ws-opts: path: \u0026#34;/[UUID]\u0026#34; headers: Host: [DOMAIN] 如果您使用的方案与本蛾子不相同，请您查看参考中的 GitLab 仓库，其中有最常见的 13 种代理的配置模板。\n这部分没什么好说的，本蛾子也变不出来新的订阅 🧙‍♂️\n🧭 策略组 如果您使用机场，机场应当已经给您配置好了，直接下载即可。如果您需要自定义，也可以在网上搜一搜好用的模板，直接下载即可。对于本蛾子自建节点来说，就不需要了（只有一个节点）😄\n只需要添加一个 PROXY 组，代表使用代理，Clash 内置了 REJECT 和 DIRECT 组，分别表示「拒绝连接」和「直接连接」。\nproxy-groups: - name: \u0026#34;PROXY\u0026#34; type: select proxies: - \u0026#34;any_name_is_okay\u0026#34; 🔌 分流规则 这应该是这篇文章的重头戏了！毕竟本蛾子写这篇文章就是因为吃了没有做好分流的苦。\n⚠️ 注意：部分站点（如 ChatGPT）会到处连接来确定您是否位于 OpenAI 不提供服务的区域。在这种情况下，建议启用全局代理。\n由于网站的数量是无限的，无论是您还是本蛾子还是网上的大神，这部分配置大概都不是一个字一个字打出来的，因此我们直接采用别人搞好的规则集。本蛾子搜了一圈，好像比较好用的是 Loyalsoldier/clash-rules（链接请见参考），如下配置：\n本蛾子采用了全套配置，可能稍有多于，您可以自行删除一部分\nrule-providers: reject: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt\u0026#34; path: ./ruleset/reject.yaml interval: 86400 icloud: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt\u0026#34; path: ./ruleset/icloud.yaml interval: 86400 apple: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt\u0026#34; path: ./ruleset/apple.yaml interval: 86400 google: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt\u0026#34; path: ./ruleset/google.yaml interval: 86400 proxy: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt\u0026#34; path: ./ruleset/proxy.yaml interval: 86400 direct: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt\u0026#34; path: ./ruleset/direct.yaml interval: 86400 private: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt\u0026#34; path: ./ruleset/private.yaml interval: 86400 gfw: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt\u0026#34; path: ./ruleset/gfw.yaml interval: 86400 tld-not-cn: type: http behavior: domain url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt\u0026#34; path: ./ruleset/tld-not-cn.yaml interval: 86400 telegramcidr: type: http behavior: ipcidr url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt\u0026#34; path: ./ruleset/telegramcidr.yaml interval: 86400 cncidr: type: http behavior: ipcidr url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt\u0026#34; path: ./ruleset/cncidr.yaml interval: 86400 lancidr: type: http behavior: ipcidr url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt\u0026#34; path: ./ruleset/lancidr.yaml interval: 86400 applications: type: http behavior: classical url: \u0026#34;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt\u0026#34; path: ./ruleset/applications.yaml interval: 86400 以上是对规则集的引用。\ntype：规则集的协议类别，本文均为针对 HTTP。 behavior：规则集的内容类别。 url：下载地址，本文选择使用 jsDelivr 的源。 path：下载的规则集的保存位置。 interval：更新时间间隔，这个规则集使用 GitHub Actions 每天更新一次，因此我们也每天重新下载一次。 下面需要继续添加规则，来使用这些规则集：\nrules: - RULE-SET,applications,DIRECT - RULE-SET,private,DIRECT - RULE-SET,reject,REJECT - RULE-SET,icloud,DIRECT - RULE-SET,apple,DIRECT - RULE-SET,google,PROXY - RULE-SET,proxy,PROXY - RULE-SET,direct,DIRECT - RULE-SET,lancidr,DIRECT - RULE-SET,cncidr,DIRECT - RULE-SET,telegramcidr,PROXY - GEOIP,LAN,DIRECT - GEOIP,CN,DIRECT - MATCH,PROXY 由于本蛾子不适用 YACD 面板，以上规则集删除了两个 YACD 面板的域名。\n这个部分应该很好理解：\nRULE-SET，GEOIP，GEOSITE 或 DOMAIN 表示匹配的类型。 后面是匹配的属性。 DIRECT，REJECT 和 PROXY 分别代表「直接访问」「拒绝访问」和「使用代理访问」。 本蛾子是 Arch Linux 用户，需要不时使用 BFSU、USTC 或者 TUNA 的源进行更新，并且本蛾子不希望使用代理下载包（容易中断，而且浪费流量），因此额外添加了几条：\nrules: ... - DOMAIN,mirrors.bfsu.edu.cn,DIRECT - DOMAIN,mirrors.ustc.edu.cn,DIRECT - DOMAIN,mirrors.tuna.tsinghua.edu.cn,DIRECT 以上是白名单模式，因此不在列表中的域名会自动采用代理。\n🎆 下课 经过这些配置，应该差不多就可以顺利地使用代理了！\n这些只是最基本的配置，Clash Meta 内核还在不断发展，也不断有新的协议和工具出现。本蛾子建议您看看结尾的参考文章，相信能给您更多启发！\n💡 提示：本文不提供完整的样板。本蛾子认为配置 Clash 是一个非常个人化的工作，没有所谓的「最佳实践」。请您认真阅读本文，相信您可以配置得比本蛾子更好！\n➕ 本文参考或引用了以下来源：\n【保姆级教学】掰碎了给你讲！Clash配置文件详解（含实战演练）（原作者：崔裕姝）\nLoyalsoldier/clash-rules: 🦄️ 🎃 👻 Clash Premium 规则集(RULE-SET)，兼容 ClashX Pro、Clash for Windows 等基于 Clash Premium 内核的客户端。（原作者：Loyalsoldier）\nClash 知识库（原作者：原文未标注，疑似Dreamacro）\nDNS 污染和劫持原理（原作者：人身如逆旅，我亦是行人）\n防火长城域名服务器缓存污染 IP 列表（维基学院）\nMisaka-blog/clash-meta: 这是一个基于 Clash Meta 订阅的配置文件模板（原作者：Misaka-blog，博客已删）\n","permalink":"http://localhost:1313/posts/eeace13dad/","summary":"\u003cp\u003e最近本蛾子发现之前搭建的代理，访问部分国内网站的时候不光速度很慢，而且有时候会报 PR_END_OF_FILE_ERROR（无法确定内容完整性，就是远程，特别是 CSDN，全站都无法访问。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e😮‍💨 唉：后来发现其实是服务端 WARP 的问题，跟 v2rayA 一毛钱关系都没有。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e本蛾子现在使用的 v2rayA 虽然安装起来很方便（Arch Linux CN 有打包），但是对于规则的支持并不算好，并且开启、关闭、切换节点的速度也不尽人意。在网上搜索一通，似乎眼下最完善的内核是 Clash 系列的后继者 Mihomo，因此本蛾子就用它来学习一下\u003cstrong\u003e如何书写 Clash 配置文件\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"-客户端选择\"\u003e💻 客户端选择\u003c/h2\u003e\n\u003cp\u003eClash 系的客户端在 AUR 上基本全部都有打包。根据本蛾子的测试，似乎还在开发且可用性比较高的，只有 Clash Verge Rev 和 FlClash，而后者的 UI 设计本蛾子看着非常舒服，因此本文就以 FlClash 作为测试客户端。\u003c/p\u003e\n\u003cp\u003e首先对 FlClash 的软件设置进行调整。虽然诸多 Clash 系客户端使用同一个内核，但是其 UI 设计却千差万别。FlClash 的界面大概是这样的。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20241229103214948\" loading=\"lazy\" src=\"../../static/img/eeace13dad.d/image-20241229103214948.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在 Tools 栏目中，主要是软件本身和覆写配置文件的选项，前者是主题、日志、自动启动等本地定义的选项，不出现在配置文件中，因此我们首先来完成对其的设置。覆写配置文件的设置主要针对使用远程配置文件（例如机场）的用户，方便修改配置文件。\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e选项大部分您都应该能理解，说几个比较迷惑的：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLogcat：就是日志功能，记录您使用代理访问的网站，关闭之后不会记录，但是似乎需要手动删除之前的记录（位于您的主目录下）。\u003c/li\u003e\n\u003cli\u003eAuto lost connections：在切换节点之后切断当前存在的连接，开启之后换区域会更加彻底，但是您的下载会被终端。\u003c/li\u003e\n\u003cli\u003eOnly statistics proxy：只对通过的流量进行记录，这时候 FlClash 就变成了一个网络监测工具。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然这个栏目还有其他功能，比如设置语言、主题、备份之类的，就请您自己探索了。\u003c/p\u003e\n\u003ch2 id=\"-配置文件\"\u003e⚙️ 配置文件\u003c/h2\u003e\n\u003cp\u003e这当然就是本文的重点了！通过 Clash 配置文件，您可以方便地修改 DNS、分流、（基础）去广告等，至于节点链接，倒成了配置文件中不太重要的一部分了。下面本蛾子参考了一些链接和项目，为行文流畅就不一一列出角标了，一并在文末引用。\u003c/p\u003e\n\u003cp\u003e您书写的配置文件应当保存在任意名称的 \u003ccode\u003e.yaml\u003c/code\u003e 文件中，在 FlClash 中这样引用：\u003c/p\u003e","title":"Clash 配置文件简述"},{"content":"😠 太长不读：生成 SSH密钥，上传到服务器，然后禁用密码登录。（好像是废话）\n0x01 🔒 生成 SSH 密钥 以下使用 $ 符号代表本机执行，\u0026gt; 符号代表服务器执行。\n$ ssh-keygen # 旧版本需要添加 `-t ed25519` 参数 Generating public/private ed25519 key pair. Enter file in which to save the key (/home/YOUR_USER_NAME/.ssh/id_ed25519): # 可以自定义位置，也可以直接回车 Enter passphrase for \u0026#34;example\u0026#34; (empty for no passphrase): # 输入密码（不显示），不建议空密码 Enter same passphrase again: # 再输一遍 Your identification has been saved in id_ed25519 Your public key has been saved in id_ed25519.pub # 带有 .pub 的是公钥 The key fingerprint is: SHA256:SOME_STRANGE_STRING YOUR_USER_NAME@YOUR_HOST_NAME # 你的公钥指纹 The key\u0026#39;s randomart image is: # 根据公钥生成的随机图像 +--[ED25519 256]--+ | SOME | | STRANGE | | IMAGE | | | | | | | | | | | | | +----[SHA256]-----+ $ ls .ssh id_ed25519 id_ed25519 # 可能还有其他文件 0x02 ⬆️ 上传到服务器 首先确保你当前可以使用密码登录一个非 root 的账号。\n$ ssh example_user@example_host example_user@example_host\u0026#39;s password: \u0026gt; 然后，退出 SSH，在本机上执行（注意是本机）：\n$ ssh-copy-id -i .ssh/id_ed25519.pub example_user@example_host 在上传过程中，会要求你输入当前密码。一般来说很快就会上传完成。\n测试一下是否可以登录。\n$ ssh -i .ssh/id_ed25519.pub example_user@example_host .ssh/id_ed25519.pub\u0026#39;s password: # 注意这里变成输入密钥的密码了 \u0026gt; 如果可以，继续下一步。\n0x03 🙅‍♂️ 禁用密码登录 \u0026gt; sudo vim /etc/ssh/sshd_config 在编辑器中，添加或修改以下选项：\nPasswordAuthentication no PermitRootLogin no AllowPAM no AllowUsers example_user # 可选，这将禁止除 example_user 之外任何用户 SSH 登录 保存并退出，然后：\n\u0026gt; sudo systemctl restart sshd 退出 SSH，再次尝试登录：\n$ ssh example_user@example_host example_user@example_host: Permission denied (publickey). 再次使用密钥登录，如果登录成功，那么说明以上步骤都是正确的！\n❓ 如果不行呢？恭喜你 🎉 你被锁在系统之外了！VNC 你的服务器吧……\n来源：XKCD，原文解说是 True story: I had to try several times to upload this comic because my ssh key was blacklisted.。\n","permalink":"http://localhost:1313/posts/5baaf9322f/","summary":"\u003cp\u003e😠 \u003cstrong\u003e太长不读\u003c/strong\u003e：生成 SSH密钥，上传到服务器，然后禁用密码登录。（好像是废话）\u003c/p\u003e\n\u003ch2 id=\"0x01--生成-ssh-密钥\"\u003e0x01 🔒 生成 SSH 密钥\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e以下使用 \u003ccode\u003e$\u003c/code\u003e 符号代表本机执行，\u003ccode\u003e\u0026gt;\u003c/code\u003e 符号代表服务器执行。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e$ ssh-keygen # 旧版本需要添加 `-t ed25519` 参数\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/YOUR_USER_NAME/.ssh/id_ed25519): # 可以自定义位置，也可以直接回车\nEnter passphrase for \u0026#34;example\u0026#34; (empty for no passphrase): # 输入密码（不显示），不建议空密码\nEnter same passphrase again: # 再输一遍\nYour identification has been saved in id_ed25519\nYour public key has been saved in id_ed25519.pub # 带有 .pub 的是公钥\nThe key fingerprint is:\nSHA256:SOME_STRANGE_STRING YOUR_USER_NAME@YOUR_HOST_NAME # 你的公钥指纹\nThe key\u0026#39;s randomart image is: # 根据公钥生成的随机图像\n+--[ED25519 256]--+\n|       SOME      |\n|     STRANGE     |\n|      IMAGE      |\n|                 |\n|                 |\n|                 |\n|                 |\n|                 |\n|                 |\n+----[SHA256]-----+\n\n$ ls .ssh\nid_ed25519 id_ed25519 # 可能还有其他文件\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"0x02--上传到服务器\"\u003e0x02 ⬆️ 上传到服务器\u003c/h2\u003e\n\u003cp\u003e首先确保你当前可以使用密码登录一个\u003cstrong\u003e非 root\u003c/strong\u003e 的账号。\u003c/p\u003e","title":"使用 SSH 公钥登录服务器并禁用密码"},{"content":"👋 你好！\n本蛾子是智慧的幺蛾子，这是本蛾子的奇葩博客桶装幺蛾子。\n智慧的幺蛾子 做个简单的自我介绍吧。\n标签 🐸 网名都是智慧的幺蛾子（Talented Bug），来自江苏扬州，现在就读于江苏省扬州中学，又称月子中心。 🏃‍♂️ AFO\u0026rsquo;d OIer，CSP-J 2022 初入，NOIP 2024 退役。 📢 母语汉语，第二语言英语，略通法语。 ⌨️ 另一个意义上的语言，熟悉 Python 和 C，正在学 Rust，Ferris 🦀 真可爱。 🔧 生命不息，折腾不止。 Arch Linux 2.5 年用户，兼有 RHEL 运维经验少许。 轻度嵌入式玩家，最大成果是桌上的时钟。 魔怔于自托管，扬中里某个角落藏了一台 Orange Pi 🤫。 🌳 涂林人蛾，遵守「幽默、包容、创造」的涂林原则。 📚 文科一塌糊涂，然而还是很热爱文学，很认同「严肃的肤浅不如深刻的幽默」。 🎮 又菜又爱玩，喜欢 MC，但是不开创造一天都活不了 😂。 ⭕ 听说 MBTI 很火，虽然本蛾子怀疑其有效性，但是测出来是 INTP-A Logician。 暂时想不起来更多啦，以后想到了再写吧。\n走过的路 幼儿园咱就不写了吧……😄\n常规教育：\n👶 2015 至 2021：扬州市育才小学。 🎒 2021 至 2024：扬州中学教育集团树人学校（九龙湖校区）。 📜 2024：中考 733/780，1 分错失地招班。 👨 2024 至今：江苏扬州，江苏省扬州中学。 OI：\n🌟 蓝桥杯 2022 省赛（一等）。 ✨ CSP-J 2022 第一轮、第二轮（三等）。 ✨ NOC 2023（二等）。 ✨ CSP-J 2023 第一轮，CSP-S 2023 第一轮、第二轮（二等）。 🚪 进入扬中信奥集训队。 👋 CSP-S 2024 第一轮、第二轮（二等），NOIP 2024（二等）。 关于我经历的更多故事，有时间单独写一篇博客吧。\n桶装幺蛾子 桶装幺蛾子是本蛾子的博客名称，此前曾称为垃圾回收站。在这里本蛾子记录想法、留下足迹，写一写折腾的时候踩过的坑，或者就是分享一些有意思的事情。不定期咕咕咕地更新。\n2020 年，本蛾子以 Simon D. Guqiu 的名字在 CSDN 上发表了第一篇博客。随着 CSDN 吃相愈发难看，本蛾子转向了博客园，后来在 2022 年用 Hexo 在 Cloudflare Pages 上托管了署名 r3vxax 的垃圾回收站。\n2024 年购买云服务器之后，我将博客迁移到了 Wordpress 上。然而我不希望服务器 IP 暴露，因此不久又回到了静态博客 Hugo 托管的方法上，但这次有了自己的域名，Cloudflare Pages 不会再加载不出来了。静态博客足以满足我的需求，因此我打算留在这里，专注写点东西。\n当前的域名 hi.bug-barrel.top，作为个人，本蛾子没有备案，因此在某些国产浏览器上可能无法访问。全站 HTTPS 已经开启，您和本蛾子之间是安全的 😄。根域名现在还没有启用，等本蛾子闲下来，可能会实现一些公共服务。\n关于评论功能，本蛾子不大想实现，因为本蛾子认为评论的内容应当直接被加入到文段内，才能对后来的同学起到最大作用。因此您若有任何想法，请通过以下邮件发送给本蛾子！\n联系 各大平台 ID 不是中文的「智慧的幺蛾子」就是英文的「Talented Bug」（或者变种「talentedbug」「TalentedBug」等等）。\n🔒 SSH 公钥：ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAtPga4T15OdsQJ+wFxp0yacuhxYA9qQTGNqz/HE9hp+ Talented Bug \u0026lt;talentedbug@bug-barrel.top\u0026gt;。 🔑 PGP 公钥：5848 5086 D9A0 2634 1F4B 663E 4F51 3147 DE97 FFBC（Talented Bug \u0026lt;talentedbug@bug-barrel.top\u0026gt;）。 📧 邮件：talentedbug@bug-barrel.top。 🐙 GitHub：Talented Bug (talentedbug) 🌈 Bluesky：Talented Bug (talentedbug.bsky.social) 🐧 LINUX DO：Talented Bug (talentedbug) 其他平台您也可以搜一搜，但是一般本蛾子不怎么看，建议有什么想说的直接邮件。如果想加 QQ 私聊，也请通过邮件联系获得。\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e👋 你好！\u003c/p\u003e\n\u003cp\u003e本蛾子是\u003cstrong\u003e智慧的幺蛾子\u003c/strong\u003e，这是本蛾子的奇葩博客\u003cstrong\u003e桶装幺蛾子\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"智慧的幺蛾子\"\u003e智慧的幺蛾子\u003c/h2\u003e\n\u003cp\u003e做个简单的自我介绍吧。\u003c/p\u003e\n\u003ch3 id=\"标签\"\u003e标签\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e🐸 网名都是智慧的幺蛾子（Talented Bug），来自江苏扬州，现在就读于江苏省扬州中学，\u003cdel\u003e又称月子中心\u003c/del\u003e。\u003c/li\u003e\n\u003cli\u003e🏃‍♂️ AFO\u0026rsquo;d OIer，CSP-J 2022 初入，NOIP 2024 退役。\u003c/li\u003e\n\u003cli\u003e📢 母语汉语，第二语言英语，略通法语。\u003c/li\u003e\n\u003cli\u003e⌨️ 另一个意义上的语言，熟悉 Python 和 C，正在学 Rust，Ferris 🦀 真可爱。\u003c/li\u003e\n\u003cli\u003e🔧 生命不息，折腾不止。\n\u003cul\u003e\n\u003cli\u003eArch Linux 2.5 年用户，兼有 RHEL 运维经验少许。\u003c/li\u003e\n\u003cli\u003e轻度嵌入式玩家，最大成果是桌上的时钟。\u003c/li\u003e\n\u003cli\u003e魔怔于自托管，扬中里某个角落藏了一台 Orange Pi 🤫。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e🌳 \u003ca href=\"https://tulin.netlify.app\"\u003e涂林\u003cdel\u003e人\u003c/del\u003e蛾\u003c/a\u003e，遵守「幽默、包容、创造」的涂林原则。\u003c/li\u003e\n\u003cli\u003e📚 文科一塌糊涂，然而还是很热爱文学，很认同「严肃的肤浅不如深刻的幽默」。\u003c/li\u003e\n\u003cli\u003e🎮 又菜又爱玩，喜欢 MC，但是不开创造一天都活不了 😂。\u003c/li\u003e\n\u003cli\u003e⭕ 听说 MBTI 很火，虽然本蛾子怀疑其有效性，但是测出来是 INTP-A Logician。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e暂时想不起来更多啦，以后想到了再写吧。\u003c/p\u003e\n\u003ch3 id=\"走过的路\"\u003e走过的路\u003c/h3\u003e\n\u003cp\u003e幼儿园咱就不写了吧……😄\u003c/p\u003e\n\u003cp\u003e常规教育：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e👶 2015 至 2021：扬州市育才小学。\u003c/li\u003e\n\u003cli\u003e🎒 2021 至 2024：扬州中学教育集团树人学校（九龙湖校区）。\u003c/li\u003e\n\u003cli\u003e📜 2024：中考 733/780，1 分错失地招班。\u003c/li\u003e\n\u003cli\u003e👨 2024 至今：江苏扬州，江苏省扬州中学。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOI：\u003c/p\u003e","title":"关于智慧的幺蛾子和桶装幺蛾子"},{"content":"对于朴素 DP，有几种常见的优化方法，本文主要介绍单调队列和斜率优化。\n单调队列优化 DP 例题：P1886 滑动窗口 /【模板】单调队列\n单调队列是一种特殊的双端队列，从字面上理解，就是具有某种单调性的队列，例如递增或者递减。一般来说单调队列可以用于维护最值，解决滑动窗口类的问题，时间复杂度是 $O(n)$。\n单调队列的维护可以通过不断添加新元素，并不定时访问或者删除旧的元素。\n以上述例题为例，我们可以如何求出单调队列的长度呢？\n最简单的方法：枚举滑动窗口的左端点和窗口长度，再求出区间内的最大、最小值，时间复杂度 $O(n^{2}k)$； RMQ（区间最值）类算法：同样枚举区间，通过预处理优化求区间最值的时间复杂度，最终为 $O(n^2 \\log_{2} n)$。 我们可以发现，这两个算法都存在一个问题：一个序列 $a_{i},a_{i+1} \\cdots a_{j}$ 和同样长度的 $a_{i+1},a_{i+2} \\cdots a_{j+1}$，其中有长达 $j-i-1$ 的区间是重复的。\n这里，单调队列优化就有用了。我们用一个例子来说明单调队列如何工作：\n1 4 5 -1 0 3 1 假设当前的区间长度 $k=4$，我们只求最小值，那么：\n队列初始为空，1 入队； 由于 1 入队时间早于 4，有可能在 1 出队后，4 成为新的最小值，因此 4 进队； 同上原因，5 入队； 这时候我们遇到了 -1，它小于队尾的 5，并且 -1 的入队时间晚于 5。那么如果 -1 入队，5 出队早于 -1，并且只要 -1 在队中，最小值都不可能是 5，因此 5 出队； 同上原因，4 出队； 由于上面主要原因已经讲完了，所以下面就简单地带过：0 时间晚，入队； 3 时间晚，入队； 1 时间晚，且值小，3 出队，1 入队。 通过上述过程，我们可以发现，无论到哪一位，我们都维护了一个单调递减的队列。由于本题还要求区间长度，我们还应当记录队列中元素的位置，如果超出范围就同样出队。\n那么问题来了，时间复杂度是什么？看起来，我们枚举左端点，还要将一些不符合条件的元素出队，好像来到了二次方，但是考虑枚举左端点时，所有节点只会进队一次、出队一次，所以本题总时间复杂度可以优化到 $O(n)$。\n代码实现：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, k; int a[1200000]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } deque\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= n; i++) { while (!q.empty()) { if (q.back().second \u0026gt; a[i]) { q.pop_back(); } else { break; } } while (!q.empty()) { if (q.front().first \u0026lt;= i - k) { q.pop_front(); } else { break; } } q.push_back({i, a[i]}); if (i \u0026gt;= k) { cout \u0026lt;\u0026lt; q.front().second \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; q.clear(); for (int i = 1; i \u0026lt;= n; i++) { while (!q.empty()) { if (q.back().second \u0026lt; a[i]) { q.pop_back(); } else { break; } } while (!q.empty()) { if (q.front().first \u0026lt;= i - k) { q.pop_front(); } else { break; } } q.push_back({i, a[i]}); if (i \u0026gt;= k) { cout \u0026lt;\u0026lt; q.front().second \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } return 0; } 本题的题解大多采用的是数组模拟队列，但是本蛾子认为虽然 STL 的常数是模拟的 1.5 倍，但我们必须知道这是因为其功能的丰富。一个冷知识，deque 可以随机访问；另一个冷知识，几乎所有 STL 容器都可以顺序访问；再一个冷知识，map、set 等加入元素会自动排序。在数据范围明确的情况下，我们还是要遵循 C++ 封装的思想。\n那么，这与 DP 有啥关系？很显然，例如在 LIS 中，我们需要在前面所有的 DP 状态中寻找满足某个条件的最大值，那么我们可以用一个单调队列维护最长 LIS，代码实现在之前的集训笔记中已经记录了，大家自取：集训笔记：动态规划经典模型 1。\n至于其他应用，本蛾子实在来不及写了，大家可以参考这篇洛谷博客，讲得也很好：单调队列优化dp，也可以自行在 OI Wiki 上搜索相关伪代码来理解。\n斜率优化 DP 相比于很直接、简洁的单调队列优化，斜率优化就复杂了许多。\n前面我们看到的单调队列优化，主要适用于状态转移方程类似 $f_{i}=\\min_{0 \\leq j \\leq i-1} f_{j}+a_{i}+b_{j}$ 的 DP，因为这里求最小值的操作是线性的。\n但是，当我们遇到形如 $f_{i}=\\min_{0 \\leq j \\leq i-1} f_{j}+a_{i} \\times b_{j}$ 的方程，我们就需要进行斜率优化来获得更高效的算法。\n例题：HDU3507 Print Article\n我们可以发现，如果文章分段数增加，会导致每段的长度减少，二者互相牵制，因此无法贪心。\n设 $f_{i}$ 表示打印前 $i$ 个单词的最小成本，$s_{i}$ 则是 $c_{1} \\cdots lc_{i}$ 的前缀和。自然地可以得到状态转移方程：\n$f_{i}=\\min_{0 \\leq j \\leq i-1} f_{i}+(s_{i}-s_{j})^2+M$\n选定一个 $j$，并将 $i$ 看作常量，移项并整理可以推出：\n$f_{j}+s_{j}^2=2s_{i} s_{j}+f_{i}-s_{i}^2-M$\n这个式子看起来很复杂，但是我们牢记所有含 $i$ 都是常量，对比一次函数的式子 $y=kx+b$，我们将 $f_{i}+s_{j}^2$ 看作 $y$，将 $s_{j}$ 看作 $x$，将 $2s_{i}$ 看作 $k$，将剩余的部分全部看作常量 $b$。\n当我们取不同的 $j$ 时，可以发现对应了平面直角座标系中的不同的点 $(x,y)$。\n注：此处图片引用原视频，在文末的参考中列出。\n原视频和本文在这里都将左式写为两项之和，但是其实可以将常数 $f_{j}$ 移项到右边。另外，其实红点和黑点是二次函数的图像而不是一次函数，是我们将它简化了。\n回过头看原来的方程，实际上我们是要求一个 $j$ 使得函数值 $f_{i}$ 最小。那么当 $i$ 一定，斜率也就确定了，截距 $b$ 最小时，$f_{i}$ 也可以取到最小值。也就是说，当斜率 $k$ 对应的直线与函数图像相切时，截距可以取到最小值。\n观察可以发现，相切的点左侧斜率都小于绿色直线，右侧都大于，我们可以通过二分查找位于二者分界处的点。\n当 $i$ 发生变化，例如增加时，斜率增大，依然要寻找这样的点，我们可以通过单调队列维护。\n若新点与队尾点的斜率小于等于队尾与相邻点的斜率，就会出现与凸包相反的方向，此时我们应该将队尾出队，维护下凸包状态； 重复执行上述操作，直到凸包状态可以维持； 新点入队； 将队头所有斜率小于当前直线的节点全部出队； 此时，队头点应当恰好相切，就是最优决策。 代码实现：\n代码借用了参考的视频，感谢！\n下课！ 本蛾子还是太着急了，所以来不及多写一些。\n后天就要上 NOIP 考场了今天写这个是不是废了……\n从 12 月穿越回来的幺蛾子：「是的。」\n参考和引用 单调队列优化dp - XyzL； E51【模板】斜率优化DP 打印文章 - 董晓算法。 ","permalink":"http://localhost:1313/posts/1ec9f00dde/","summary":"\u003cp\u003e对于朴素 DP，有几种常见的优化方法，本文主要介绍\u003cstrong\u003e单调队列\u003c/strong\u003e和\u003cstrong\u003e斜率\u003c/strong\u003e优化。\u003c/p\u003e\n\u003ch2 id=\"单调队列优化-dp\"\u003e单调队列优化 DP\u003c/h2\u003e\n\u003cp\u003e例题：\u003ca href=\"https://www.luogu.com.cn/problem/P1886\"\u003eP1886 滑动窗口 /【模板】单调队列\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e单调队列是一种特殊的双端队列，从字面上理解，就是具有某种单调性的队列，例如递增或者递减。一般来说单调队列可以用于维护最值，解决滑动窗口类的问题，时间复杂度是 $O(n)$。\u003c/p\u003e\n\u003cp\u003e单调队列的维护可以通过不断添加新元素，并不定时访问或者删除旧的元素。\u003c/p\u003e\n\u003cp\u003e以上述例题为例，我们可以如何求出单调队列的长度呢？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最简单的方法：枚举滑动窗口的左端点和窗口长度，再求出区间内的最大、最小值，时间复杂度 $O(n^{2}k)$；\u003c/li\u003e\n\u003cli\u003eRMQ（区间最值）类算法：同样枚举区间，通过预处理优化求区间最值的时间复杂度，最终为 $O(n^2 \\log_{2} n)$。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们可以发现，这两个算法都存在一个问题：一个序列 $a_{i},a_{i+1} \\cdots a_{j}$ 和同样长度的 $a_{i+1},a_{i+2} \\cdots a_{j+1}$，其中有长达 $j-i-1$ 的区间是重复的。\u003c/p\u003e\n\u003cp\u003e这里，单调队列优化就有用了。我们用一个例子来说明单调队列如何工作：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1 4 5 -1 0 3 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e假设当前的区间长度 $k=4$，我们只求最小值，那么：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e队列初始为空，1 入队；\u003c/li\u003e\n\u003cli\u003e由于 1 入队时间早于 4，有可能在 1 出队后，4 成为新的最小值，因此 4 进队；\u003c/li\u003e\n\u003cli\u003e同上原因，5 入队；\u003c/li\u003e\n\u003cli\u003e这时候我们遇到了 -1，它小于队尾的 5，并且 -1 的入队时间晚于 5。那么如果 -1 入队，5 出队早于 -1，并且只要 -1 在队中，最小值都不可能是 5，因此 5 出队；\u003c/li\u003e\n\u003cli\u003e同上原因，4 出队；\u003c/li\u003e\n\u003cli\u003e由于上面主要原因已经讲完了，所以下面就简单地带过：0 时间晚，入队；\u003c/li\u003e\n\u003cli\u003e3 时间晚，入队；\u003c/li\u003e\n\u003cli\u003e1 时间晚，且值小，3 出队，1 入队。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通过上述过程，我们可以发现，无论到哪一位，我们都维护了一个\u003cstrong\u003e单调\u003c/strong\u003e递减的队列。由于本题还要求区间长度，我们还应当记录队列中元素的位置，如果超出范围就同样出队。\u003c/p\u003e","title":"DP 优化的常见方法"},{"content":"图的连通性问题主要包括：\n割边和割点； 强连通分量和缩点； 边双连通分量和点双连通分量。 求解这些问题，效率最高、思路最清晰的算法是 Tarjan 算法，由罗伯特·恩卓·塔扬发明。塔扬研究了并查集、图论等许多领域，因此有很多以他名字命名的算法，这里是指关于图的连通性问题的算法。\n割边和割点 不大严谨、完全不形式化的定义：\n割边：如果删除图上的某条边，图就不再连通，那么这条边就是图的割边。 割点：如果删除图上的某个点以及与其相连的所有边，图就不再连通，那么这个点就是图的割点。 暴力求解这个问题，可以枚举删除某一条边或者某一个点，然后通过 DFS 判断连通性，平均时间复杂度是 $O(n^2)$。\n首先需要了解的是 DFS 树。DFS 树是从图上任意一点开始 DFS，由 DFS 顺序所构成的一棵树，开始点对于答案没有影响。在树上出现的边称为树边，否则称为非树边。\n在割边和割点问题中，一般只研究无向图。非树边在 DFS 树中以返祖边的形式出现，其含义就是字面含义。\n割点 割点可以分为两种情况：\n根节点在 DFS 树中有多余一个子节点，那么它就是割点； 对于一个非根节点，它的子树中至少有一棵，不存在一条返祖边可以回到它的祖先节点。 第一种请款很简单；第二种情况，如果子树上存在到它的祖先的返祖边，当它被删除之后，这棵子树仍然可以通过返祖边到达原本节点的祖先。\n求割点的方法：\n$dfn_{i}$ 表示节点 $i$ 的时间戳，或者也可以说是节点在 DFS 树中的深度，通过其大小比较可以判断祖先与子孙的关系； $low_{i}$ 表示节点 $i$ 不经过其父节点能到达的 $dfn$ 最小的祖先。（这个概念大部分博客都没有讲清楚，本蛾子搜遍互联网终于找到了对其的明确定义，特此感谢：Tarjan 算法求解无向图的割点与割边，可惜的是这篇博客下面的代码是错误的。） 对于一个节点 $v$ 及其祖先 $u$，如果回溯时发现 $low_{v} \\geq dfn_{u}$，也就是说 $v$ 回不到 $u$ 的祖先（取等，因为此时与 $3$ 相连的所有边都被删除，所以不可能到达）。\n还需要注意，当一个节点的子节点已经被访问，更新应当使用 dfn[e[i].t] 而非 low[e[i].t]。若使用后者，会导致割点的子节点使用割点能访问的祖先节点更新，那这就白跑了。\n代码实现（可以根据注释理解）：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; struct edge { int f, t; int n; } e[220000]; int ec; int pre[22000]; int dfn[22000], low[22000]; set\u0026lt;int\u0026gt; ce; bool vis[22000]; int ro; void add(int f, int t) { e[++ec].f = f; e[ec].t = t; e[ec].n = pre[f]; pre[f] = ec; } int dfs_cnt; void dfs(int c, int f) { // `c`: current node, `f`: father node vis[c] = true; dfn[c] = low[c] = ++dfs_cnt; // Update the current timestamp int sc = 0; // The number of children, in case this is root for (int i = pre[c]; i; i = e[i].n) { if (!vis[e[i].t]) { // Not visited, indicating it\u0026#39;s reached for the first // time and thus cannot reach an ancestor sc++; dfs(e[i].t, c); // Go to children and thus recall low[c] = min(low[c], low[e[i].t]); // Update ancestors that `c` // reach by its subtree if (c != ro \u0026amp;\u0026amp; low[e[i].t] \u0026gt;= dfn[c]) { // Indicating that its subtree cannot reach // `c`\u0026#39;s ancestors // SO NODE `C` IS AN CUT NODE ce.insert(c); } if (c == ro \u0026amp;\u0026amp; sc \u0026gt;= 2) { ce.insert(c); // If `c` is root and has more than one subtree, // obviously it\u0026#39;s a cut node } } else { if (e[i].t != f) { // Visited before, so `c` could reach what // `e[i].t` could reach low[c] = min(low[c], dfn[e[i].t]); } } } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int f, t; cin \u0026gt;\u0026gt; f \u0026gt;\u0026gt; t; add(f, t), add(t, f); } for (int i = 1; i \u0026lt;= n; i++) { if (!vis[i]) { ro = i; dfs(i, 0); } } cout \u0026lt;\u0026lt; ce.size() \u0026lt;\u0026lt; endl; for (auto k: ce) { cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; return 0; } 注意去重，因为如果割点不止一棵子树不能返祖，那么就会重复添加。（硬控本蛾子半小时。）\n对应例题：P3388 【模板】割点（割顶）（通过记录）\n割边 割边更加简单，不需要考虑割点中的第一种情况，直接比较每个点的最远返祖边即可。需要注意在求割点中，上述取等是不成立的，因为还有可能不经过这条边，转而绕行另一个节点，到达子节点。\n代码实现：\n// Related variables bool vis[120000]; // If visited int dfn[120000], low[120000]; // As mentioned above struct edge { int f, t; int n; } e[220000]; int ec; int pre[120000]; // Standard \u0026#34;chain forward star\u0026#34; (?) vector\u0026lt;int\u0026gt; ce; // Keep cut edges int n, m; // Node \u0026amp; Edge sums void dfs(int c, int f) { // `c`: current node, `f`: father node vis[c] = true; dfn[c] = low[c] = dfn[f] + 1; // Update the current timestamp for (int i = pre[c]; i; i = e[i].n) { if (!vis[e[i].t]) { // Not visited, indicating it\u0026#39;s reached for the first // time and thus cannot reach an ancestor dfs(e[i].t, c); // Go to children and thus recall low[c] = min(low[c], low[e[i].t]); // Update ancestors that `c` // reach by its subtree if (low[e[i].t] \u0026gt; dfn[c]) { // Indicating that its subtree cannot reach // `c`\u0026#39;s ancestors // SO EDGE `I` IS AN CUT EDGE ce.push_back(i); } } else { if (e[i].t != f) { // Visited before, so `c` could reach what // `e[i].t` could reach low[c] = min(low[c], dfn[e[i].t]); } } } } 对应例题：P1656 炸铁路（通过记录）\n这两则代码需要对应起来看，注意其间的区别，就像 Dijkstra 和 SPFA 一样一眼看上去很像，但是如果有一点细节错了就会拖很长时间。\n强连通分量和缩点 强连通分量：在一个有向图中，最大的强连通子图称为这张图的强连通分量。强连通是指一张有向图中任何两个节点之间都双向可达（可以经过其他点）。\n其实求强连通分量还有另一种两遍 DFS 的方法，但是为了保持本文的统一性，我们还是继续使用 Tarjan 算法。\n用于求强连通分量的 Tarjan 模板与割边没有本质性区别。我们用一个栈保存当前所遍历到的点，当我们发现某个节点 $u$ 的 DFS 子树全部遍历完成之后，$dfn_{u}=low_{u}$，说明现在栈内的所有元素（都是 $u$ 的子节点）属于的强连通分量结束了，因为根节点已经无法到达时间戳更早的祖先了。\nUpd：本蛾子前一天晚上自信地写下了上面这段，然后发现没法理解自己的说法，今天又从头模拟了一边，详细说说为什么 SCC（Strongly Connected Components）与割点和割边的写法有区别。\n辨色力大赛，灵魂画手大赛，相同颜色对应的是同一步操作，叙述一下，理解的同学可以跳过：\n从根节点 1 出发，$dfn_{1}=1$，$low_{1}=1$； 到达 5，记录 $dfn_{5}=2$ 和 $low_{5}=2$，压栈； 到达 3，记录 $dfn_{3}=3$ 和 $low_{3}=3$，压栈； 到达 4，记录 $dfn_{4}=4$ 和 $low_{4}=4$，压栈； 4 的子树（并没有）遍历结束，$dfn_{4}=low_{4}$，记为第 1 个 SCC，只包含 4，弹栈、取消标记； 回溯，3 的子树遍历结束，$dfn_{3}=low_{3}$，记为第 2 个 SCC，只包含 3，弹栈、取消标记； 回溯到 5，从 5 到达 6，压栈； 从 6 到达 1，压栈，用 $low_{1}=1$ 更新 $low_{6}=1$； 回溯，从 6 到达 4，但是此时 4 不在栈中，不可以更新：因为已经处理完的 SCC 相当于已经从图中删去，不再加入 DFS 树； 回溯到 5，根据 $low_{6}$ 更新 $low_{5}=1$； 回溯到 1，前往 2，记录 $dfn_{6}=2$ 和 $low_{2}=6$，压栈； 前往 6，发现在栈内，可以更新，$low_{2}=1$； 1 的子树遍历结束，$dfn_{4}=low_{4}$，记为第 3 个 SCC，包含 1，2，5，6，弹栈、取消标记； 结束！ 可以发现最大的区别是在判断是否通过已经经过的、当前节点的子节点是否可以用于更新当前节点。在割点中，我们允许所有非 DFS 树上的父亲节点进行更新，但是这里一方面因为是有向图，一方面因为已经处理完的 SCC 不属于当前的 SCC，而未处理的应当直接进行更新——不允许更新。\n另外有一个性质，就是完成遍历之后会发现，同一个强连通分量内，所有节点的 $low$ 都是相同的。\n代码实现：\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; struct edge { int f, t; int n; } e[220000]; int ec; int pre[12000]; bool vis_scc[12000]; void add(int f, int t) { e[++ec].f = f; e[ec].t = t; e[ec].n = pre[f]; pre[f] = ec; } int dfn[12000], low[12000]; int ts; stack\u0026lt;int\u0026gt; s; vector\u0026lt;set\u0026lt;int\u0026gt;\u0026gt; v; bool in_s[12000]; int scc[12000]; int scc_id; void dfs(int c) { dfn[c] = low[c] = ++ts; s.push(c); in_s[c] = true; for (int i = pre[c]; i; i = e[i].n) { if (!dfn[e[i].t]) { dfs(e[i].t); if (low[e[i].t] \u0026lt; low[c]) { low[c] = low[e[i].t]; } } else if (in_s[e[i].t]) { low[c] = min(low[c], low[e[i].t]); } } if (dfn[c] == low[c]) { scc_id++; set\u0026lt;int\u0026gt; k; while (s.top() != c) { scc[s.top()] = scc_id; in_s[s.top()] = false; k.insert(s.top()); s.pop(); } scc[s.top()] = scc_id; in_s[s.top()] = false; k.insert(s.top()); s.pop(); v.push_back(k); } } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= m; i++) { int f, t; cin \u0026gt;\u0026gt; f \u0026gt;\u0026gt; t; add(f, t); } for (int i = 1; i \u0026lt;= n; i++) { if (!dfn[i]) { dfs(i); } } cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; endl; for (int i = 1; i \u0026lt;= n; i++) { if (!vis_scc[scc[i]]) { for (auto k: v[scc[i] - 1]) { cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; vis_scc[scc[i]] = true; } } return 0; } 对应例题：[洛谷 B3609 图论与代数结构 701] 强连通分量（通过记录）\n插句闲话，其实我一直觉得现在通常对 Tarjan 中一些变量的命名很不合理，按照本蛾子的理解，应当改成：\ndfn 变成 ts 即 timestamp，时间戳； low 变成 hfa 即 highest father，不通过 DFS 树直接父亲就可以访问的最远祖先。 同意的同学可以在自己的代码里这样用，但是本文为了照顾已经看过很多其他博客的同学，就使用常见的命名方式了。\n缩点：将一个强连通分量缩为一个点，作为整体计算的方法。\n在一些情况下，例如我们需要计算路径的最大值，很明显如果存在一个环，我们会将它走完再离开——反正走完之后还是回到原点，对于结果没有影响，为啥不走一下呢？这时候我们就需要提前计算出强连通分量并将其缩为一个点，权值是子图原本权值的和，否则每次经过都需要将整个子图重跑一遍。\n缩点的实现就是在强连通分量的基础上，建立一张新图，并为每一个强连通分量建立一个点，具体实现相信大家自己就可以做出来，洛谷上的模板题 P3387 【模板】缩点在强连通分量的基础上还要求出最长距离，需要通过 DP 和拓扑排序来做，本蛾子就不写了（太太太太长了），大家可以自己看看题解，然后敲出来。\n边双连通分量和点双连通分量 双连通：对于一对点 $u$ 和 $v$ 来说，如果将它们之间的边删去任何一条，都不能使其不连通，则称 $u$ 和 $v$ 双连通；对于一对边 $i$ 和 $j$ 来说，如果将它们之间的点删去任何一个，都不能使其不连通，则称 $i$ 和 $j$ 双连通。\n点双连通分量具有一些性质：\n不存在割点； 两个点双连通分量之间如果存在公共点，则这个点是割点； 无向连通图上，非割点只属于一个点双连通分量，割点属于至少两个点双连通分量。 求解点双连通分量，代码和割点基本是一模一样，毕竟割点两侧的子图不就是点双连通分量嘛。相应地，边双连通分量之间是割边，但是需要使用 DFS 跑一遍连通块，因为无法确定将哪个节点入栈。\n本蛾子实在是来不及写了（还有 4 天 NOIP），就摘抄一份博客的代码（CC-BY 4.0），作者是北烛青澜，感谢：\n#include\u0026lt;bits/stdc++.h\u0026gt; #define N 10001000 using namespace std; struct sb{int u,v,next;}e[N]; int n,m,cnt,head[N],dfn[N],low[N],tot,stk[N],top,bcc;//bcc存放当前的点双连通分量的数量 vector\u0026lt;int\u0026gt;ans[N];//存放答案 inline void add(int u,int v) { e[++cnt].u=u; e[cnt].v=v; e[cnt].next=head[u]; head[u]=cnt; } inline void tarjan(int x,int fa)//fa是x的父节点 { dfn[x]=low[x]=++tot; stk[++top]=x; int ch=0;//ch存放子节点的数量 for(int i=head[x];i;i=e[i].next) { int v=e[i].v; if(!dfn[v])//如果当前点还没有搜索过 { ch++;//子节点加一 tarjan(v,x);//继续往下搜 low[x]=min(low[x],low[v]);//正常更新low[x]的值 if(low[v]\u0026gt;=dfn[x])//割点的判定条件 { bcc++;//点双连通分量的数量加1 while(stk[top+1]!=v)//如果上一个弹出的栈顶元素不是v的话就一直弹 ans[bcc].push_back(stk[top--]);//将当前点放入栈中 ans[bcc].push_back(x);//最后把割点给加进去 } } else if(v!=fa)//不能用父节点来更新当前点的low值 low[x]=min(low[x],dfn[v]); } if(fa==0\u0026amp;\u0026amp;ch==0)//特判只有一个点的情况 ans[++bcc].push_back(x); } signed main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++) { int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; add(u,v); add(v,u); } for(int i=1;i\u0026lt;=n;i++) { if(!dfn[i]) { top=0; tarjan(i,0); } } cout\u0026lt;\u0026lt;bcc\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=bcc;i++) { int siz=ans[i].size(); cout\u0026lt;\u0026lt;siz\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int j=0;j\u0026lt;siz;j++) cout\u0026lt;\u0026lt;ans[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } #include\u0026lt;bits/stdc++.h\u0026gt; #define N 2000005 using namespace std; int n,m,head[N],dfn[N],low[N],dcc,vis[N],tot,cnt=1; struct sb{int u,v,next,flag;}e[N\u0026lt;\u0026lt;1]; vector\u0026lt;int\u0026gt;ans[N]; inline void add(int u,int v) { e[++cnt].u=u; e[cnt].v=v; e[cnt].next=head[u]; head[u]=cnt; } void tarjan(int x,int fa) { dfn[x]=low[x]=++tot; for(int i=head[x];i;i=e[i].next) { int v=e[i].v; if(!dfn[v]) { tarjan(v,x); low[x]=min(low[x],low[v]); if(low[v]\u0026gt;dfn[x]) e[i].flag=e[i^1].flag=1; } else if(v!=fa)low[x]=min(low[x],dfn[v]); } } void dfs(int x) { ans[dcc].push_back(x); vis[x]=1; for(int i=head[x];i;i=e[i].next) { int v=e[i].v; if(vis[v]||e[i].flag)continue; dfs(v); } } signed main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++) { int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; add(u,v); add(v,u); } for(int i=1;i\u0026lt;=n;i++) if(!dfn[i]) tarjan(i,0); for(int i=1;i\u0026lt;=n;i++) { if(!vis[i]) { dcc++; dfs(i); } } cout\u0026lt;\u0026lt;dcc\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=dcc;i++) { int siz=ans[i].size(); cout\u0026lt;\u0026lt;siz\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int j=0;j\u0026lt;siz;j++) cout\u0026lt;\u0026lt;ans[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } 下课！ 本蛾子一边学习，一边写完了这篇博客，因此难免会有些缺漏。如果您发现本蛾子写错了——很有可能的，那么请在评论中尽管指正，谢谢！\n","permalink":"http://localhost:1313/posts/b1aaece446/","summary":"\u003cp\u003e\u003cstrong\u003e图的连通性问题\u003c/strong\u003e主要包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e割边和割点；\u003c/li\u003e\n\u003cli\u003e强连通分量和缩点；\u003c/li\u003e\n\u003cli\u003e边双连通分量和点双连通分量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e求解这些问题，效率最高、思路最清晰的算法是 \u003cstrong\u003eTarjan\u003c/strong\u003e 算法，由\u003cstrong\u003e罗伯特·恩卓·塔扬\u003c/strong\u003e发明。塔扬研究了并查集、图论等许多领域，因此有很多以他名字命名的算法，这里是指关于图的连通性问题的算法。\u003c/p\u003e\n\u003ch2 id=\"割边和割点\"\u003e割边和割点\u003c/h2\u003e\n\u003cp\u003e不大严谨、完全不形式化的定义：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e割边\u003c/strong\u003e：如果删除图上的某条边，图就不再连通，那么这条边就是图的割边。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e割点\u003c/strong\u003e：如果删除图上的某个点以及与其相连的所有边，图就不再连通，那么这个点就是图的割点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e暴力求解这个问题，可以枚举删除某一条边或者某一个点，然后通过 DFS 判断连通性，平均时间复杂度是 $O(n^2)$。\u003c/p\u003e\n\u003cp\u003e首先需要了解的是 \u003cstrong\u003eDFS 树\u003c/strong\u003e。DFS 树是从图上任意一点开始 DFS，由 DFS 顺序所构成的一棵树，开始点对于答案没有影响。在树上出现的边称为\u003cstrong\u003e树边\u003c/strong\u003e，否则称为\u003cstrong\u003e非树边\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e在割边和割点问题中，一般只研究无向图。非树边在 DFS 树中以\u003cstrong\u003e返祖边\u003c/strong\u003e的形式出现，其含义就是字面含义。\u003c/p\u003e\n\u003ch3 id=\"割点\"\u003e割点\u003c/h3\u003e\n\u003cp\u003e割点可以分为两种情况：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e根节点在 DFS 树中有多余一个子节点，那么它就是割点；\u003c/li\u003e\n\u003cli\u003e对于一个非根节点，它的子树中至少有一棵，不存在一条返祖边可以回到它的祖先节点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e第一种请款很简单；第二种情况，如果子树上存在到它的祖先的返祖边，当它被删除之后，这棵子树仍然可以通过返祖边到达原本节点的祖先。\u003c/p\u003e\n\u003cp\u003e求割点的方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$dfn_{i}$ 表示节点 $i$ 的时间戳，或者也可以说是节点在 DFS 树中的深度，通过其大小比较可以判断祖先与子孙的关系；\u003c/li\u003e\n\u003cli\u003e$low_{i}$ 表示节点 $i$ 不经过其父节点能到达的 $dfn$ 最小的祖先。（这个概念大部分博客都没有讲清楚，本蛾子搜遍互联网终于找到了对其的明确定义，特此感谢：\u003ca href=\"https://skywt.cn/blog/tarjan-cut-vertex-cut-edge/\"\u003eTarjan 算法求解无向图的割点与割边\u003c/a\u003e，可惜的是这篇博客下面的代码是错误的。）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于一个节点 $v$ 及其祖先 $u$，如果回溯时发现 $low_{v} \\geq dfn_{u}$，也就是说 $v$ 回不到 $u$ 的祖先（取等，因为此时与 $3$ 相连的所有边都被删除，所以不可能到达）。\u003c/p\u003e\n\u003cp\u003e还需要注意，当一个节点的子节点已经被访问，更新应当使用 \u003ccode\u003edfn[e[i].t]\u003c/code\u003e 而非 \u003ccode\u003elow[e[i].t]\u003c/code\u003e。若使用后者，会导致割点的子节点使用割点能访问的祖先节点更新，那这就白跑了。\u003c/p\u003e\n\u003cp\u003e代码实现（可以根据注释理解）：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\nint n, m;\nstruct edge {\n    int f, t;\n    int n;\n} e[220000];\nint ec;\nint pre[22000];\nint dfn[22000], low[22000];\nset\u0026lt;int\u0026gt; ce;\nbool vis[22000];\nint ro;\n\nvoid add(int f, int t) {\n    e[++ec].f = f;\n    e[ec].t = t;\n    e[ec].n = pre[f];\n    pre[f] = ec;\n}\n\nint dfs_cnt;\nvoid dfs(int c, int f) { // `c`: current node, `f`: father node\n    vis[c] = true;\n    dfn[c] = low[c] = ++dfs_cnt; // Update the current timestamp\n    int sc = 0; // The number of children, in case this is root\n    for (int i = pre[c]; i; i = e[i].n) {\n        if (!vis[e[i].t]) { // Not visited, indicating it\u0026#39;s reached for the first \n                            // time and thus cannot reach an ancestor\n            sc++;\n            dfs(e[i].t, c); // Go to children and thus recall\n            low[c] = min(low[c], low[e[i].t]); // Update ancestors that `c` \n                                               // reach by its subtree\n            if (c != ro \u0026amp;\u0026amp; low[e[i].t] \u0026gt;= dfn[c]) { // Indicating that its subtree cannot reach \n                                                    // `c`\u0026#39;s ancestors\n                                                    // SO NODE `C` IS AN CUT NODE\n                ce.insert(c);\n            }\n            if (c == ro \u0026amp;\u0026amp; sc \u0026gt;= 2) {\n                ce.insert(c); // If `c` is root and has more than one subtree,\n                                 // obviously it\u0026#39;s a cut node\n            }\n        } else {\n            if (e[i].t != f) { // Visited before, so `c` could reach what \n                               // `e[i].t` could reach\n                low[c] = min(low[c], dfn[e[i].t]);\n            }\n        }\n    }\n}\n\nint main() {\n    cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m;\n    for (int i = 1; i \u0026lt;= m; i++) {\n        int f, t;\n        cin \u0026gt;\u0026gt; f \u0026gt;\u0026gt; t;\n        add(f, t), add(t, f);\n    }\n    for (int i = 1; i \u0026lt;= n; i++) {\n        if (!vis[i]) {\n            ro = i;\n            dfs(i, 0);\n        }\n    }\n    cout \u0026lt;\u0026lt; ce.size() \u0026lt;\u0026lt; endl;\n    for (auto k: ce) {\n        cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\n    }\n    cout \u0026lt;\u0026lt; endl;\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意去重，因为如果割点不止一棵子树不能返祖，那么就会重复添加。（硬控本蛾子半小时。）\u003c/p\u003e","title":"图的连通性问题"},{"content":"我还是希望大家啊，多用歪克特，啊，尤其是我们现在有了，啊，凹凸，简洁而且方便。\n本文中若无特殊说明，认为树的根节点的深度为 1。\n树的直径 树上任意两个点之间的最长距离称为树的直径。\n求树的直径，可以从任何一个节点 $x$ 开始 DFS，能到达的最远节点 $y$ 一定是直径的一端。再从 $y$ 开始 DFS，能到达的最远节点 $z$ 就是直径的另一端，$x$ 与 $y$ 的距离即为直径。\n证明：\n代码：\n树的直径也可以使用树形 DP 计算，若设 1 为树根，那么设某个点向下能达到的最大和次大值是 $d1$ 和 $d2$，那么 $d1 + d2$ 最大时就是树的直径。\n代码：\n上述写法也可以压缩为一个数组，定义 $dp_{u}$ 是以 $u$ 为树根的子树中，从 $u$ 出发的最长路径，那么有转移方程 $dp_{u}=\\max{dp_{u}, dp_{v}}$，其中 $v$ 是 $u$ 的子节点。对于求直径的过程，我们可以在转移时打擂求最大值。\n树的中心 选定一个点作为树的根节点，使得叶节点到根节点的最大距离最小，这个点称为树的中心。\n树的中心一定在直径上，且趋于两个端点的中点，因此可以在找出直径的同时，求出其到每个节点的距离。\n代码：\n#include\u0026lt;cstdio\u0026gt; #include\u0026lt;iostream\u0026gt; #define re register #define maxn 100010 using namespace std; inline int read() { int x=0,f=1; char ch=getchar(); while(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if(ch==\u0026#39;-\u0026#39;)f=-1;ch=getchar();} while(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-\u0026#39;0\u0026#39;;ch=getchar();} return x*f; } struct Edge{ int v,w,nxt; }e[maxn\u0026lt;\u0026lt;2]; int x,y,z; int pos1,pos2,d[maxn],d1[maxn],d2[maxn]; int n,tmp1,tmp2,tmp3,ans,pos,cnt,head[maxn]; inline void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs1(int u,int fa,int dis) { for(int i=head[u];i;i=e[i].nxt) { int ev=e[i].v; if(ev==fa) continue; dfs1(ev,u,dis+e[i].w); } d[u]=dis; if(dis\u0026gt;tmp2) tmp2=dis,tmp1=u; } int main() { n=read(); for(re int i=1;i\u0026lt;n;++i) { x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); } dfs1(1,0,0); pos1=tmp1; tmp2=0,tmp1=0; dfs1(pos1,0,0); pos2=tmp1; tmp2=0,tmp1=0; //找到直径了 for(re int i=1;i\u0026lt;=n;++i) d1[i]=d[i]; dfs1(pos2,0,0); for(re int i=1;i\u0026lt;=n;++i) d2[i]=d[i]; ans=0x3f3f3f3f; for(re int i=1;i\u0026lt;=n;++i) { if(ans\u0026gt;max(d1[i],d2[i])) ans=max(d1[i],d2[i]),pos=i; } printf(\u0026#34;%d %d\u0026#34;,pos,ans); return 0; } 树的重心 选择树中的一个节点并删除，使得分成的所有子树的最大节点数最小，这个点称为树的重心。树的重心若不唯一，则一定有两个。\n代码：\n最近公共祖先 求最近公共祖先的朴素方法是，先让较深的节点向其父亲跳，直到深度相同，然后两个节点同时向上跳，直到相遇，时间复杂度 $O(n)$。\n对于朴素算法的上跳过程，可以通过倍增进行优化。通过预处理 $fa$ 数组，将原本的跳跃次数 $y$ 分为其二进制位对应的跳跃。预处理时间复杂度 $O(n\\log{n})$，查询时间复杂度 $O(\\log{n})$。\n树上差分 例题：洛谷 P3128 Max Flow P\n对每条路径的起点和终点求 LCA，将路径上所有边的权值都加 1，然后求边权最大值。但是如果真的一一添加会超时，可以使用树上差分进行优化。\n需要注意由于树上差分若对于 $w_{a}$ 和 $w_{b}$ 均加上 1，处于路径交汇点的 LCA 实际上加 2。为了抵消影响，需要对 $w_{lca}$ 减去 1；同时由于填充实际数值时会将 $w_{lca}$ 的变化向上波及，还需要对 $w_{fa_{lca}}$ 减去 1，抵消影响。\n树上贪心 例题：ABC333D\n由于我们希望删除的点最少，因此保留的子树一定是最大的，在每次删除时贪心地选择最小的子树即可。\n树上 DP 例题：洛谷 P1122\n树上 DP 的基本思路是将子树的状态转移到根节点上。\n代码：\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int n,a[16005],f[16005],ans=-2147483647; vector \u0026lt;int\u0026gt; E[16005]; void dfs(int u,int fa) { f[u]=a[u];//f初始值 for(int i=0;i\u0026lt;E[u].size();i++) { int t=E[u][i]; if(t!=fa) { dfs(t,u); if(f[t]\u0026gt;0) f[u]+=f[t];//如式 } } } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]);//点权输入 for(int i=1;i\u0026lt;n;i++) { int u,v; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;u,\u0026amp;v); E[u].push_back(v); E[v].push_back(u);//vector双向连边 } dfs(1,0); for(int i=1;i\u0026lt;=n;i++) ans=max(ans,f[i]);//找出最大点权和 printf(\u0026#34;%d\u0026#34;,ans); return 0; } 树上揹包 例题：P2014 选课\n由于本题没有给出作为树根的节点，可以将 0 作为虚根，设 $dp_{i,j}$ 表示前 $i$ 个子节点、选择 $j$ 门课，滚动数组压缩树根的维度。\n换根 DP 例题：ABC348E\n本蛾子集训五天以来第一道一遍 AC 的题目！\n第一次 DFS，初始化深度、LCA 倍增数组； 第二次 DFS，求每个节点及其子树的权值和； 第三次 DFS，求以 1 为根的总和； 第四次 DFS，根据节点之间的关系和子树和，求出以其他点为根时的总和。 代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; #define int long long using namespace std; int n; struct edge { int f, t; int n; } e[220000]; int ec; int pre[120000]; int w[120000]; int nw[120000]; int tot_w; void add(int f, int t) { e[++ec].f = f; e[ec].t = t; e[ec].n = pre[f]; pre[f] = ec; } int v[120000]; int dep[120000]; void dfs_tot(int x, int f) { dep[x] = dep[f] + 1; nw[x] = w[x]; for (int i = pre[x]; i; i = e[i].n) { if (e[i].t != f) { dfs_tot(e[i].t, x); nw[x] += nw[e[i].t]; } } } int tot_c; int dfs4root(int x, int f) { int tw = w[x] * (dep[x] - 1); for (int i = pre[x]; i; i = e[i].n) { if (e[i].t != f) { tw += dfs4root(e[i].t, x); } } return tw; } void dfs_de(int x, int f) { for (int i = pre[x]; i; i = e[i].n) { if (e[i].t != f) { v[e[i].t] = v[x] - nw[e[i].t] + (tot_w - nw[e[i].t]); dfs_de(e[i].t, x); } } } signed main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt; n; i++) { int f, t; cin \u0026gt;\u0026gt; f \u0026gt;\u0026gt; t; add(f, t), add(t, f); } for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; w[i]; tot_w += w[i]; } dfs_tot(1, 0); v[1] = dfs4root(1, 0); dfs_de(1, 0); int min_w = LLONG_MAX; for (int i = 1; i \u0026lt;= n; i++) { min_w = min(min_w, v[i]); } cout \u0026lt;\u0026lt; min_w \u0026lt;\u0026lt; endl; return 0; } 树上 LIS 对于树上每一条路径，用优化后的 LIS 算法 $O(n\\log{n})$ 地求出 LIS，并在递归中继承和回溯。\n难点在于回溯操作，可以提前记录修改操作，并在子树处理之后撤销。\n树上二分 例题：洛谷 P3000 Cow Calisthenics G\n首先要求求最大值的最小值，应为二分答案。\n我们从下往上遍历，如果添加一条边之后最长路径超过了二分的答案，贪心地要求保留边长最小的边，那么就应当删去子树的根与最长路径之间的连边，这样保留的边一定最小，不具有后效性。\n综合 例题：洛谷 P6869 Putovanje\n由于题目要求按顺序走完所有节点，因此两两之间的最优路径是唯一的，否则至少不能省去代价。对于一对起点和终点，最短就是到 LCA 的距离，将路径经过的所有边标记。但是这样可能超时（尤其是在 YZZX 孱弱的评测机上），因此要使用树上差分优化，最后一次性计算。\n下课！ 您达成了新的成就——每题都有分！\n","permalink":"http://localhost:1313/posts/5dad7361ce/","summary":"\u003cp\u003e我还是希望大家啊，多用歪克特，啊，尤其是我们现在有了，啊，凹凸，简洁而且方便。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文中若无特殊说明，认为树的根节点的深度为 1。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"树的直径\"\u003e树的直径\u003c/h2\u003e\n\u003cp\u003e树上任意两个点之间的最长距离称为树的直径。\u003c/p\u003e\n\u003cp\u003e求树的直径，可以从任何一个节点 $x$ 开始 DFS，能到达的最远节点 $y$ 一定是直径的一端。再从 $y$ 开始 DFS，能到达的最远节点 $z$ 就是直径的另一端，$x$ 与 $y$ 的距离即为直径。\u003c/p\u003e\n\u003cp\u003e证明：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/5dad7361ce.d/image-1024x344.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/5dad7361ce.d/image-1-1024x451.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/5dad7361ce.d/image-2-1024x459.png\"\u003e\u003c/p\u003e\n\u003cp\u003e代码：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/5dad7361ce.d/image-3-1024x494.png\"\u003e\u003c/p\u003e\n\u003cp\u003e树的直径也可以使用树形 DP 计算，若设 1 为树根，那么设某个点向下能达到的最大和次大值是 $d1$ 和 $d2$，那么 $d1 + d2$ 最大时就是树的直径。\u003c/p\u003e\n\u003cp\u003e代码：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/5dad7361ce.d/image-4-1024x650.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上述写法也可以压缩为一个数组，定义 $dp_{u}$ 是以 $u$ 为树根的子树中，从 $u$ 出发的最长路径，那么有转移方程 $dp_{u}=\\max{dp_{u}, dp_{v}}$，其中 $v$ 是 $u$ 的子节点。对于求直径的过程，我们可以在转移时打擂求最大值。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/5dad7361ce.d/image-5-1024x442.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"树的中心\"\u003e树的中心\u003c/h2\u003e\n\u003cp\u003e选定一个点作为树的根节点，使得叶节点到根节点的最大距离最小，这个点称为树的中心。\u003c/p\u003e\n\u003cp\u003e树的中心一定在直径上，且趋于两个端点的中点，因此可以在找出直径的同时，求出其到每个节点的距离。\u003c/p\u003e\n\u003cp\u003e代码：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;iostream\u0026gt;\n#define re register\n#define maxn 100010\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if(ch==\u0026#39;-\u0026#39;)f=-1;ch=getchar();}\n\twhile(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-\u0026#39;0\u0026#39;;ch=getchar();}\n\treturn x*f;\n}\nstruct Edge{\n\tint v,w,nxt;\n}e[maxn\u0026lt;\u0026lt;2];\nint x,y,z;\nint pos1,pos2,d[maxn],d1[maxn],d2[maxn];\nint n,tmp1,tmp2,tmp3,ans,pos,cnt,head[maxn];\ninline void add(int u,int v,int w)\n{\n\te[++cnt].v=v;\n\te[cnt].w=w;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dfs1(int u,int fa,int dis)\n{\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t{\n\t\tint ev=e[i].v;\n\t\tif(ev==fa) continue;\n\t\tdfs1(ev,u,dis+e[i].w);\n\t}\n\td[u]=dis;\n\tif(dis\u0026gt;tmp2) tmp2=dis,tmp1=u;\n}\n\nint main()\n{\n\tn=read();\n\tfor(re int i=1;i\u0026lt;n;++i)\n\t{\n\t\tx=read(),y=read(),z=read();\n\t\tadd(x,y,z);\n\t\tadd(y,x,z);\n\t}\n\tdfs1(1,0,0);\n\tpos1=tmp1;\n\ttmp2=0,tmp1=0;\n\tdfs1(pos1,0,0);\n\tpos2=tmp1;\n\ttmp2=0,tmp1=0;\n\t//找到直径了 \n\tfor(re int i=1;i\u0026lt;=n;++i) d1[i]=d[i];\n\tdfs1(pos2,0,0);\n\tfor(re int i=1;i\u0026lt;=n;++i) d2[i]=d[i];\n\tans=0x3f3f3f3f;\n\tfor(re int i=1;i\u0026lt;=n;++i)\n\t{\n\t\tif(ans\u0026gt;max(d1[i],d2[i]))\n\t\tans=max(d1[i],d2[i]),pos=i;\n\t}\n\tprintf(\u0026#34;%d %d\u0026#34;,pos,ans);\n\treturn 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"树的重心\"\u003e树的重心\u003c/h2\u003e\n\u003cp\u003e选择树中的一个节点并删除，使得分成的所有子树的最大节点数最小，这个点称为树的重心。树的重心若不唯一，则一定有两个。\u003c/p\u003e","title":"集训笔记：树结构"},{"content":"最小生成树 Prim 算法 算法原理：从一个点出发维护一个最小生成树上的点的集合，每次选择一条集合内某点和集合外某点的最小边权加入，然后将集合外的这个点加入集合。若暴力查找最小边权，时间复杂度为 $O(n^2)$。\n代码示例：\nPrim 算法的思路和 Dijkstra 最短路算法非常相似，优化也基本相同。对于暴力做法中寻找最小值的步骤，可以使用优先队列优化到 $O(n+m\\log{m})$。\nKruskal 算法 将边权从小到大排序，一一尝试向最小生成树添加边，若边的端点不在同一个连通块内，则添加，时间复杂度为 $O(e\\log{e})$。\n代码示例：\n算法的正确性显然，对于放弃的边，其权值大于前面所有的边，因此产生环时应当首先放弃。时间复杂度瓶颈在排序操作上。\n例题：HDU7226\n序列中所有数字之间的边构成一个完全图，但是不可能将这个完全图实际建出来，空间和时间上都无法接受。\n如果我们直接按顺序连接所有点，那么每条边的边权都小于 n。因此，最小生成树中所有边权都应当小于 n，也就是 $|i - j| * |p_{i}-p_{j}|$ 小于 $n$，两个乘数有一个小于 $\\sqrt{n}$。我们可以选择枚举 $i$ 在 1 到 n，$j$ 在 $i$ 到 $i+\\sqrt{n}$，总时间复杂度为 $O(n\\sqrt{n})$。\n然后对这些边计算最小生成树，因此叠加后的时间复杂度为 $O(n\\sqrt{n}\\log{n}\\sqrt{n})$。若时间复杂度较为紧张，还可以使用桶排进行 Kruskal 中的排序过程，将 $\\log{n}$ 压缩。\n例题：洛谷 P2245 星际导航\n题意是寻找一条路径上边权的最大值。两个点之间可能有很多边，但是边权较大的边不会产生贡献，因此我们先对图运行 Kruskal 求最小生成树，这样两个点之间有唯一路径且一定最小（否则更短的边会出现在生成树中）。这样就可以通过 LCA 直接求出总边权。\n另一种思路是使用 Kruskal 重构树，适用于最小生成树最大边权问题。\nKruskal 重构树的求解过程：\n将边权从小到大排序； 每次选择边权最小的一条边，若其连接的两个点已经进入集合，则跳过；否则，将这两个点的祖先都连接到一个虚点上，点权为这条边的边权。 在这棵树上，两个节点之间的最大权值可以直接通过 LCA 求得，不需要单独维护。某些题目只能通过重构树的方式实现。\n例题：洛谷 P2619 边的限制问题\n如果将所有白边加一个很大的权值，则所有白边都无法进入最小生成树； 如果将所有白边减一个很大的权值，则所有白边都可以进入最小生成树； 显然，这个权值具有单调性，可以通过二分答案寻找分界点，此时就是题目所求的最小生成树。 这种计算方法称为带权二分，是很重要的思想。\n例题：洛谷 P4180 严格次小生成树\n最简单的思路是先求出最小生成树，并每次删除集合中的最大值，添加集合外的最小值。这种贪心的算法很简单，但是不正确。\n反例例如：\n对于一个非严格次小生成树，添加的边权大于等于最小生成树，因此不是严格次小生成树。在添加新边时，不仅要维护环上的最大值，还要维护次大值。对于最初的最小生成树，进行倍增 LCA，分别记录最大和次大值，并在此后添加边时修改。\n例题：POJ2728 最优比率生成树\n设比值大于等于 $k$，则可以变形为 $k\\Sigma{R}-\\Sigma{C}\\leq0$，拆分则为 $(mid \\times R_{1}-C_{1}) + (mid \\times R_{2} - D_{2}) +\\dots \\leq 0$，可以二分求这个 $k$，并依次给边赋值，求图的最小生成时，边权的和是否小于 $k$；若小于，说明 $k$ 偏小，反则偏大。\n这个方法是解决 01 分数规划的常见方法。\n如果题意相反，是求最小值，则应当求最大生成树。\n连通性算法 例题：洛谷 P1656 炸铁路\n显然是求割边。\n代码：\n解释：\n$dfn_{u}$ 是访问到 $u$ 结点时的时间戳或顺序； $low_{u}$ 是 $u$ 能回到哪一个点； 以上两个值在 18 行初始化为点本身； 寻找与 $u$ 直接相邻的点，若这个点还没有被访问，则从这个点开始递归，并更新能够回到的点； 如果一条边是割边，则它的两个端点中一个的时间戳应当小于另一端能回到的点； 若这个点已经被访问，则更新能回到的点。 对于求割边，第 25 行的 $dfn_{v}$ 可以修改为 $low_{v}$，本质上就是一次性更新了能到达的最远祖先，可以跳过其间的点。\n对以上代码进行修改，可以求割点（洛谷 P3388）。\n【待补充】\n代码：\n割点、割边的概念主要是针对无向图。\n强连通分量是，在一个最大的无向图中，任意两点之间都有路径。默认单个点是一个强连通分量。\n求强连通分量的例子：\nDFS 找到 1，2，3，5，5 无法继续，是强连通分量； 返回到 3，仍然无法继续，是强连通分量； 返回到 4，深入到 4，发现可以回到 1，更新 $low$ 为 1； 深入到 6，发现可以回到 1，更新 $low$ 为 1； 回到 2，根据 4 更新 2 的 $low$ 为 1； 回到 1，DFS 结束。 例题：洛谷 P2272 最大半连通子图\n思路：首先将所有强连通分量求出，然后对它们进行缩点，形成一个 DAG，通过 DP 求 DAG 中的点权最大的路径。\n【点双、边双连通分量跳过】\n试题讲评 洛谷 P7991 Connect Two Barns S\n题意简述：有一个不一定连通的图，允许建立最多两条边，使 1 到 N 有路径。\n首先将图分割为若干连通块，按数量分类：\n有一个连通块：直接输出 0； 有两个连通块：加一条边，一定有两个相邻的点，输出 1； 有两个以上的连通块：包含 1 和 N 的连通块分别连接到其他连通块，求最小代价。 对于最后一个情况，枚举每个点，并二分查找包含 1 和 N 的连通块中最接近的点，求最小值。\n洛谷 P8191 Moo Network G\n显然是最小生成树，如果全部建边就成了上文所述。由于 $y$ 的值很小，实际上连边只需要连 25 到 30 条边就可以抵消较小的 $y$ 产生的影响。\n洛谷 P7528 Portals G\n按照题意模拟，逐字理解。\n洛谷 P8328 Usmjeravanje\n题意简述：给定一些有向边和一些无向边，要求确定边的方向，使强连通分量数量最小。\n【待补充】\n下课！ 又是被虐的一天！\n","permalink":"http://localhost:1313/posts/307ee35eff/","summary":"\u003ch2 id=\"最小生成树\"\u003e最小生成树\u003c/h2\u003e\n\u003ch3 id=\"prim-算法\"\u003ePrim 算法\u003c/h3\u003e\n\u003cp\u003e算法原理：从一个点出发维护一个最小生成树上的点的集合，每次选择一条集合内某点和集合外某点的最小边权加入，然后将集合外的这个点加入集合。若暴力查找最小边权，时间复杂度为 $O(n^2)$。\u003c/p\u003e\n\u003cp\u003e代码示例：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/307ee35eff.d/1732344587-image-1024x768.png\"\u003e\u003c/p\u003e\n\u003cp\u003ePrim 算法的思路和 Dijkstra 最短路算法非常相似，优化也基本相同。对于暴力做法中寻找最小值的步骤，可以使用优先队列优化到 $O(n+m\\log{m})$。\u003c/p\u003e\n\u003ch3 id=\"kruskal-算法\"\u003eKruskal 算法\u003c/h3\u003e\n\u003cp\u003e将边权从小到大排序，一一尝试向最小生成树添加边，若边的端点不在同一个连通块内，则添加，时间复杂度为 $O(e\\log{e})$。\u003c/p\u003e\n\u003cp\u003e代码示例：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/307ee35eff.d/1732345486-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e算法的正确性显然，对于放弃的边，其权值大于前面所有的边，因此产生环时应当首先放弃。时间复杂度瓶颈在排序操作上。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例题：HDU7226\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/307ee35eff.d/1732345686-image-1024x129.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/307ee35eff.d/1732345693-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e序列中所有数字之间的边构成一个完全图，但是不可能将这个完全图实际建出来，空间和时间上都无法接受。\u003c/p\u003e\n\u003cp\u003e如果我们直接按顺序连接所有点，那么每条边的边权都小于 \u003ccode\u003en\u003c/code\u003e。因此，最小生成树中所有边权都应当小于 \u003ccode\u003en\u003c/code\u003e，也就是 $|i - j| * |p_{i}-p_{j}|$ 小于 $n$，两个乘数有一个小于 $\\sqrt{n}$。我们可以选择枚举 $i$ 在 1 到 n，$j$ 在 $i$ 到 $i+\\sqrt{n}$，总时间复杂度为 $O(n\\sqrt{n})$。\u003c/p\u003e\n\u003cp\u003e然后对这些边计算最小生成树，因此叠加后的时间复杂度为 $O(n\\sqrt{n}\\log{n}\\sqrt{n})$。若时间复杂度较为紧张，还可以使用桶排进行 Kruskal 中的排序过程，将 $\\log{n}$ 压缩。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例题：洛谷 P2245 星际导航\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/307ee35eff.d/1732347318-image-1024x536.png\"\u003e\u003c/p\u003e\n\u003cp\u003e题意是寻找一条路径上边权的最大值。两个点之间可能有很多边，但是边权较大的边不会产生贡献，因此我们先对图运行 Kruskal 求最小生成树，这样两个点之间有唯一路径且一定最小（否则更短的边会出现在生成树中）。这样就可以通过 LCA 直接求出总边权。\u003c/p\u003e\n\u003cp\u003e另一种思路是使用 \u003cstrong\u003eKruskal 重构树\u003c/strong\u003e，适用于最小生成树最大边权问题。\u003c/p\u003e\n\u003cp\u003eKruskal 重构树的求解过程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将边权从小到大排序；\u003c/li\u003e\n\u003cli\u003e每次选择边权最小的一条边，若其连接的两个点已经进入集合，则跳过；否则，将这两个点的祖先都连接到一个虚点上，点权为这条边的边权。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/307ee35eff.d/1732347871-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在这棵树上，两个节点之间的最大权值可以直接通过 LCA 求得，不需要单独维护。某些题目只能通过重构树的方式实现。\u003c/p\u003e","title":"集训笔记：图论算法二"},{"content":"拓扑排序 拓扑排序是图论中的一种算法，适用于 DAG 中，可以用于求拓扑序列。拓扑排序的结果是一个线性序列，满足每个顶点在序列中只出现一次，且若存在 A 到 B 的路径，则 A 出现在 B 之前。拓扑序列通常不唯一。\n基于 BFS（入度）的拓扑排序比较容易实现。\n伪代码：\n代码示例：\n拓扑排序可以判断图中是否有环。如果最终所有顶点的入度都减少为 0，队列清空，则不存在环；否则则有环。\n代码示例：\n例题：机器人擂台赛（CF645D）\n分析：\n没有自相矛盾：没有环； 没有比赛包含相同机器人：没有重边； 属于「依赖关系」，优先考虑拓扑排序； 判断是否有唯一的拓扑序列，可以在拓扑排序过程中判断是否同时有多于一个入度为 0 的顶点（也就是每次只有一个选择）。 直接在拓扑排序的模板上进行修改即可。\n对于比赛的处理，可以有以下几种方法：\n每次加一条边，并进行拓扑排序，当序列唯一时输出（注意清空）； 答案具有单调性，可以二分答案，对最大答案进行特判是否无解； 拓扑排序相邻两个顶点之间的关系必须给出，因此可以在拓扑排序中记录每一场必要的比赛的编号，然后依次扫描所有比赛，在所有比赛都出现的时候就可以输出了。 最短路算法 BFS 当一张图上不含边权，或者边权都相等，可以直接使用 BFS 计算最短路，算法正确且复杂度不高。\n例题：Nearest Opposite Parity（CF1272E）\n最简单的方法：从每一个数开始，寻找最近的异性数字； 优化：从所有奇数出发，统计能到达所有偶数的最短路，对于偶数也这样求出最短路； 反向建图，也就是从 i + a[i] 和 i - a[i] 连一条到 i 的边，也就是从终点出发，寻找到每一个起点的最短路； 代码：\n两个 BFS 基本一致，以到达奇数的 BFS 为例：\n进一步进行优化，可以设置两个超级源点 $n + 1$ 和 $n + 2$，分别对应奇数和偶数的源点。将所有的奇数和偶数分别连边到对应源点，然后从源点开始 BFS。 代码：\n注：上述反向建边仍然需要。\n例题：TAMNICA（洛谷 P6399）\n最简单的思路：模拟填充螺旋矩阵，然后将推倒的墙两侧的数连边（关键边）。最短路未必全部由关键边构成，因此还需要建普通边，然后使用 BFS 求最短路； 这代码……\n优化：不填充矩阵，用其他方法求出 B 对应的 A；并且减少建边数量，具体方法较多，见代码。 在没有墙倒塌的情况下，显然 $x$ 和 $y$ 之间的距离是 $|x - y|$，因此在普通边的情况下可以不建边，只需要将可以抄近道的关键点从小到大排序并去重，在相邻两个关键点之间连一条边。\n注意：\n下标很大，可以用 map 和链式前向星； SPFA 当心卡常； 答案很大，赋初值要在 1e16 以上； 求 A 对面的 B 决定了最大时间复杂度，可以通过找规律在 $O(\\log{n})$ 以下的时间复杂度内找到。 代码：\n通用最短路算法 最短路算法的核心操作：松弛。\n对于一条 $(x,y)$ 的边，如果有另一个点 $m$ 满足 $(x,m)$ 的 $(m,y)$ 的权值小于前者，则可以将距离更新，称为松弛操作。\nDijkstra 算法 操作步骤：\n代码：\n例题：Roadblock（洛谷 P2176）\n枚举最短路上的每一条边，依次加倍并求最短路。（其实直接枚举所有边也可以。）\n例题：次短路\n将上题中的最短路改为此段路。\n思路：维护两个数组，在松弛时分别更新最短路和次短路。\n例题：联络计划（NIKKEI PC Contest 2019-2D）\n在 $L$ 到 $R$ 之间建一条边，然后在相邻的两个点之间反向建权值为 0 的边，等效地实现建所有边的目标\nBellman-Ford 及相关 Bellman-Ford 可以检测负环。如果经过 n - 1 次松弛操作之后，仍然有可以松弛的边，证明存在负环。\n时间复杂度为 $O(nm)$，算法瓶颈在于每一轮松弛都需要扫描无用的边。通过队列可以优化，使接下来的遍历中不会反复访问。\n代码：\nSPFA 算法时间复杂度为 $O(km)$ ，其中 $k$ 通常是一个很小的常数，但是通过构造可以将 $k$ 搞得很大。\n例题：穿越虫洞 POJ3259\n判断负环，不再赘述。\n例题：爱情之路 HDU4360\n臭 名 昭 著\n分析：\n代码：\n例题：最优贸易（NOIP2009 提高组，洛谷 P1073）\n分析：\n不可以使用 Dijkstra，反例： 本题其实可以使用记忆化搜索通过，但是其他时间复杂度正确的方法包括 SPFA 和分层图。\n压轴题：最优星际贸易（COCI2012/2013 Final）\n60pts 做法：暴力枚举 $x$ 所有可能的值，对于一对 $a$ 和 $b$，假设所有权值为 $x$ 的边都走不通，此时若走不通，且 $x = 1$ 时还是走不通，输出 0 0；若后者不成立，则输出 inf。\n否则，$x$ 可能产生的贡献一定在原来的权值之下，从 $1$ 开始枚举每一个 $x$ 的值运行 Dijkstra。若此时路径长度超过了原权值，那么一定不会产生贡献，退出，否则加入集合去重。\n下课！ ","permalink":"http://localhost:1313/posts/38853453c4/","summary":"\u003ch2 id=\"拓扑排序\"\u003e拓扑排序\u003c/h2\u003e\n\u003cp\u003e拓扑排序是图论中的一种算法，适用于 DAG 中，可以用于求拓扑序列。拓扑排序的结果是一个线性序列，满足每个顶点在序列中只出现一次，且若存在 A 到 B 的路径，则 A 出现在 B 之前。拓扑序列通常不唯一。\u003c/p\u003e\n\u003cp\u003e基于 BFS（入度）的拓扑排序比较容易实现。\u003c/p\u003e\n\u003cp\u003e伪代码：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732257535-image-1024x315.png\"\u003e\u003c/p\u003e\n\u003cp\u003e代码示例：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732257614-image-1024x470.png\"\u003e\u003c/p\u003e\n\u003cp\u003e拓扑排序可以判断图中是否有环。如果最终所有顶点的入度都减少为 0，队列清空，则不存在环；否则则有环。\u003c/p\u003e\n\u003cp\u003e代码示例：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732257770-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例题：机器人擂台赛（CF645D）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732257837-image-1024x366.png\"\u003e\u003c/p\u003e\n\u003cp\u003e分析：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e没有自相矛盾\u003c/em\u003e：没有环；\u003c/li\u003e\n\u003cli\u003e\u003cem\u003e没有比赛包含相同机器人\u003c/em\u003e：没有重边；\u003c/li\u003e\n\u003cli\u003e属于「依赖关系」，优先考虑拓扑排序；\u003c/li\u003e\n\u003cli\u003e判断是否有唯一的拓扑序列，可以在拓扑排序过程中判断是否同时有多于一个入度为 0 的顶点（也就是每次只有一个选择）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e直接在拓扑排序的模板上进行修改即可。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732258142-image-1024x515.png\"\u003e\u003c/p\u003e\n\u003cp\u003e对于比赛的处理，可以有以下几种方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e每次加一条边，并进行拓扑排序，当序列唯一时输出（注意清空）；\u003c/li\u003e\n\u003cli\u003e答案具有单调性，可以二分答案，对最大答案进行特判是否无解；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732258511-image.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拓扑排序相邻两个顶点之间的关系必须给出，因此可以在拓扑排序中记录每一场必要的比赛的编号，然后依次扫描所有比赛，在所有比赛都出现的时候就可以输出了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732258881-image.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"最短路算法\"\u003e最短路算法\u003c/h2\u003e\n\u003ch3 id=\"bfs\"\u003eBFS\u003c/h3\u003e\n\u003cp\u003e当一张图上不含边权，或者边权都相等，可以直接使用 BFS 计算最短路，算法正确且复杂度不高。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例题：Nearest Opposite Parity（CF1272E）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732259171-image-1024x373.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732259216-image-1024x533.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最简单的方法：从每一个数开始，寻找最近的异性数字；\u003c/li\u003e\n\u003cli\u003e优化：从所有奇数出发，统计能到达所有偶数的最短路，对于偶数也这样求出最短路；\u003c/li\u003e\n\u003cli\u003e反向建图，也就是从 \u003ccode\u003ei + a[i]\u003c/code\u003e 和 \u003ccode\u003ei - a[i]\u003c/code\u003e 连一条到 \u003ccode\u003ei\u003c/code\u003e 的边，也就是从\u003cstrong\u003e终点\u003c/strong\u003e出发，寻找到每一个起点的最短路；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代码：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732260193-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e两个 BFS 基本一致，以到达奇数的 BFS 为例：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/38853453c4.d/1732260233-image.png\"\u003e\u003c/p\u003e","title":"集训笔记：图论算法一"},{"content":"洛谷题解\n题意简述 原题链接（CF）\n给出长度为 $n$ 的序列 $a$，允许从某个数 $a_{i}$ 向前或向后跳跃 $a_{i}$ 个数（跳跃后的位置在序列内），要求求出从奇偶性不同的另一个数到每个数的最短距离。\n分析 首先很容易想到一个符合直觉的方案：对于每一个数，我们以它为源点计算最短路（使用图论算法；由于边权都是 1，还可以用 BFS），然后找到距离最近、奇偶性相反的数，输出距离。\n但是这个方法的问题很明显：枚举每个数字，再加上 BFS，至少也是 $O(n^2)$ 的时间复杂度，如果用图论算法还得更高。\n我们希望能在一次 BFS 之后就得出每个点的最短路，这样时间复杂度就来到了 $O(n)$。\n这里的难点就是反向建边，即从 $i \\pm a_{i}$ 建立到 $i$ 的边。其他大佬的题解自然地提到了反向建边，但是对我这样的蒟蒻，为什么反向建边更重要。这出于两个原因：\n输出要求是到达每个数的最短路径，如果存储的也是到达的路径长度显然更方便； BFS 中，如果我们反向地遍历，可以避免正向遍历所导致的反复遍历：我们将从结果推开头，这样不需要对每个源点一一遍历。 有了这个概念，我们就可以将所有数字分为奇数和偶数。定义 $ev_{i}$ 是从偶数到 $i$ 的最短路径，$od_{i}$ 是从奇数到 $i$ 的最短路径，那么显然奇数 $a_{i}$ 的 $od_{i}$、偶数 $a_{j}$ 的 $ev_{j}$ 均为 0。\n我们将偶数提前入队，从它们开始跑一遍 BFS，去求出从偶数到达每一个数的最短路径；对于奇数也是同样的操作。\n那么现在就很清楚了，我们已经有了从奇数或者偶数到达一个点的最短路径（BFS 路径就是最短路），输出直接选择与 $a_{i}$ 相反的那个路径长度即可。\n代码实现 变量名对应表：\nn：原题中 N； a：原题中 a; ev，od：见上文； edge：边： f，t：边的首、尾； n：下一条边（用于遍历）； ec：边的计数； pre：以某个点为首的第一条边（用于遍历）； vis：访问记录（用于 BFS），注意清零； ev_q，od_q：用于偶数、奇数 BFS 的队列。 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n; int a[220000]; int ev[220000], od[220000]; // 链式前向星，其实邻接表也行 struct edge { int f, t; int n; } e[420000]; int ec; int pre[220000]; bool vis[220000]; void add(int f, int t) { e[++ec].f = f; e[ec].t = t; e[ec].n = pre[f]; pre[f] = ec; } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (i - a[i] \u0026gt;= 1) { add(i - a[i], i); // 反向建边 } if (i + a[i] \u0026lt;= n) { add(i + a[i], i); } } memset(vis, 0, sizeof(vis)); // 清空 queue\u0026lt;int\u0026gt; ev_q; for (int i = 1; i \u0026lt;= n; i++) { if (a[i] % 2 == 0) { ev[i] = 0; ev_q.push(i); vis[i] = true; // 初始化本来就是偶数的数，距离为 0，入队 } else { ev[i] = INT_MAX; // 否则初始化为无穷大 } } while (!ev_q.empty()) { // BFS，基本就是模板 int id = ev_q.front(); ev_q.pop(); vis[id] = false; for (int i = pre[id]; i; i = e[i].n) { if (ev[e[i].t] \u0026gt; ev[id] + 1) { ev[e[i].t] = ev[id] + 1; if (!vis[e[i].t]) { ev_q.push(e[i].t); vis[e[i].t] = true; } } } } memset(vis, 0, sizeof(vis)); // 下面一模一样 queue\u0026lt;int\u0026gt; od_q; for (int i = 1; i \u0026lt;= n; i++) { if (a[i] % 2 == 1) { vis[i] = true; od[i] = 0; od_q.push(i); } else { od[i] = INT_MAX; } } while (!od_q.empty()) { int id = od_q.front(); od_q.pop(); vis[id] = false; for (int i = pre[id]; i; i = e[i].n) { if (od[e[i].t] \u0026gt; od[id] + 1) { od[e[i].t] = od[id] + 1; if (!vis[e[i].t]) { od_q.push(e[i].t); vis[e[i].t] = true; } } } } for (int i = 1; i \u0026lt;= n; i++) { int k; if (a[i] % 2 == 0) { k = od[i]; // 输出，输出与当前数字奇偶性不同的距离 } else { k = ev[i]; } if (k == INT_MAX) { cout \u0026lt;\u0026lt; \u0026#34;-1 \u0026#34;; // 无法到达 } else { cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; endl; // 换行好习惯 return 0; } ","permalink":"http://localhost:1313/posts/202b1a70de/","summary":"\u003cp\u003e\u003ca href=\"https://www.luogu.com.cn/article/0m4pa5w4\"\u003e洛谷题解\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"题意简述\"\u003e题意简述\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://codeforces.com/problemset/problem/1272/E\"\u003e原题链接（CF）\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e给出长度为 $n$ 的序列 $a$，允许从某个数 $a_{i}$ 向前或向后跳跃 $a_{i}$ 个数（跳跃后的位置在序列内），要求求出从奇偶性不同的另一个数到每个数的最短距离。\u003c/p\u003e\n\u003ch2 id=\"分析\"\u003e分析\u003c/h2\u003e\n\u003cp\u003e首先很容易想到一个符合直觉的方案：对于每一个数，我们以它为源点计算最短路（使用图论算法；由于边权都是 1，还可以用 BFS），然后找到距离最近、奇偶性相反的数，输出距离。\u003c/p\u003e\n\u003cp\u003e但是这个方法的问题很明显：枚举每个数字，再加上 BFS，至少也是 $O(n^2)$ 的时间复杂度，如果用图论算法还得更高。\u003c/p\u003e\n\u003cp\u003e我们希望能在一次 BFS 之后就得出每个点的最短路，这样时间复杂度就来到了 $O(n)$。\u003c/p\u003e\n\u003cp\u003e这里的难点就是\u003cstrong\u003e反向建边\u003c/strong\u003e，即从 $i \\pm a_{i}$ 建立到 $i$ 的边。其他大佬的题解自然地提到了反向建边，但是对我这样的蒟蒻，为什么反向建边更重要。这出于两个原因：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e输出要求是\u003cstrong\u003e到达\u003c/strong\u003e每个数的最短路径，如果存储的也是到达的路径长度显然更方便；\u003c/li\u003e\n\u003cli\u003eBFS 中，如果我们反向地遍历，可以避免正向遍历所导致的反复遍历：我们将从结果推开头，这样不需要对每个源点一一遍历。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有了这个概念，我们就可以将所有数字分为奇数和偶数。定义 $ev_{i}$ 是\u003cstrong\u003e从\u003c/strong\u003e偶数到 $i$ 的最短路径，$od_{i}$ 是\u003cstrong\u003e从\u003c/strong\u003e奇数到 $i$ 的最短路径，那么显然奇数 $a_{i}$ 的 $od_{i}$、偶数 $a_{j}$ 的 $ev_{j}$ 均为 0。\u003c/p\u003e\n\u003cp\u003e我们将偶数提前入队，从它们开始跑一遍 BFS，去求出\u003cstrong\u003e从偶数\u003c/strong\u003e到达每一个数的最短路径；对于奇数也是同样的操作。\u003c/p\u003e\n\u003cp\u003e那么现在就很清楚了，我们已经有了从奇数或者偶数到达一个点的最短路径（BFS 路径就是最短路），输出直接选择与 $a_{i}$ 相反的那个路径长度即可。\u003c/p\u003e\n\u003ch2 id=\"代码实现\"\u003e代码实现\u003c/h2\u003e\n\u003cp\u003e变量名对应表：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003en\u003c/code\u003e：原题中 \u003ccode\u003eN\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ea\u003c/code\u003e：原题中 \u003ccode\u003ea\u003c/code\u003e;\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eev\u003c/code\u003e，\u003ccode\u003eod\u003c/code\u003e：见上文；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eedge\u003c/code\u003e：边：\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ef\u003c/code\u003e，\u003ccode\u003et\u003c/code\u003e：边的首、尾；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003en\u003c/code\u003e：下一条边（用于遍历）；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eec\u003c/code\u003e：边的计数；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epre\u003c/code\u003e：以某个点为首的第一条边（用于遍历）；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evis\u003c/code\u003e：访问记录（用于 BFS），注意清零；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eev_q\u003c/code\u003e，\u003ccode\u003eod_q\u003c/code\u003e：用于偶数、奇数 BFS 的队列。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include \u0026lt;bits/stdc++.h\u0026gt;\n\nusing namespace std;\nint n;\nint a[220000];\nint ev[220000], od[220000];\n\n// 链式前向星，其实邻接表也行\nstruct edge {\n    int f, t;\n    int n;\n} e[420000];\nint ec;\nint pre[220000];\nbool vis[220000];\nvoid add(int f, int t) {\n    e[++ec].f = f;\n    e[ec].t = t;\n    e[ec].n = pre[f];\n    pre[f] = ec;\n}\n\nint main() {\n    cin \u0026gt;\u0026gt; n;\n    for (int i = 1; i \u0026lt;= n; i++) {\n        cin \u0026gt;\u0026gt; a[i];\n        if (i - a[i] \u0026gt;= 1) {\n            add(i - a[i], i); // 反向建边\n        }\n        if (i + a[i] \u0026lt;= n) {\n            add(i + a[i], i);\n        }\n    }\n    memset(vis, 0, sizeof(vis)); // 清空\n    queue\u0026lt;int\u0026gt; ev_q;\n    for (int i = 1; i \u0026lt;= n; i++) {\n        if (a[i] % 2 == 0) {\n            ev[i] = 0;\n            ev_q.push(i);\n            vis[i] = true; // 初始化本来就是偶数的数，距离为 0，入队\n        } else {\n            ev[i] = INT_MAX; // 否则初始化为无穷大\n        }\n    }\n    while (!ev_q.empty()) { // BFS，基本就是模板\n        int id = ev_q.front();\n        ev_q.pop();\n        vis[id] = false;\n        for (int i = pre[id]; i; i = e[i].n) {\n            if (ev[e[i].t] \u0026gt; ev[id] + 1) {\n                ev[e[i].t] = ev[id] + 1;\n                if (!vis[e[i].t]) {\n                    ev_q.push(e[i].t);\n                    vis[e[i].t] = true;\n                }\n            }\n        }\n    }\n    memset(vis, 0, sizeof(vis)); // 下面一模一样\n    queue\u0026lt;int\u0026gt; od_q;\n    for (int i = 1; i \u0026lt;= n; i++) {\n        if (a[i] % 2 == 1) {\n            vis[i] = true;\n            od[i] = 0;\n            od_q.push(i);\n        } else {\n            od[i] = INT_MAX;\n        }\n    }\n    while (!od_q.empty()) {\n        int id = od_q.front();\n        od_q.pop();\n        vis[id] = false;\n        for (int i = pre[id]; i; i = e[i].n) {\n            if (od[e[i].t] \u0026gt; od[id] + 1) {\n                od[e[i].t] = od[id] + 1;\n                if (!vis[e[i].t]) {\n                    od_q.push(e[i].t);\n                    vis[e[i].t] = true;\n                }\n            }\n        }\n    }\n    for (int i = 1; i \u0026lt;= n; i++) {\n        int k;\n        if (a[i] % 2 == 0) {\n            k = od[i]; // 输出，输出与当前数字奇偶性不同的距离\n        } else {\n            k = ev[i];\n        }\n        if (k == INT_MAX) {\n            cout \u0026lt;\u0026lt; \u0026#34;-1 \u0026#34;; // 无法到达\n        } else {\n            cout \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\n        }\n    }\n    cout \u0026lt;\u0026lt; endl; // 换行好习惯\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e","title":"CF1272E Nearest Opposite Parity 题解"},{"content":"😡 太长不读版：使用 VLESS + WebSocket + TLS 方案、Cloudflare CDN 保护、Cloudflare WARP 解锁服务，在 RackNerd 的 10.99/yr 起廉价服务器上搭建一个安全、隐私、不易封的代理服务器。无广告，很详细。如果您已经下定决心要自己搭建，请跳过 0x01 和 0x02 节。\n本文如未特殊提及，货币单位均为美元。好吧，其实是会被 KaTeX 识别成数学公式……\n各位想必都已经混迹互联网十余载，对于这门技术有所耳闻，甚至自己购买过机场的订阅，在外面的世界已经遨游过一番了。今天本蛾子就讲一个老生常谈的问题：老是觉得那些机场主都不可靠，我能不能自己搭一个？\n首先在文章开始之前，国际惯例，对于几个常见误解进行声明：\n本蛾子热爱中华人民共和国，热爱中国共产党，绝无污蔑、诋毁国家、党和人民的行为，本文的目的仅仅是技术分享，读者您的行为的后果由您自行承担； 本蛾子没有收一分钱；相反，还因为购买服务器和域名花了 30 多，本文请放心食用； 搭建代理服务器是一个比较复杂的过程，您应当有最基本的 Linux 使用能力，对网络相关知识有一定了解； 无论是自建的代理还是机场，总有被封或跑路的一天，您的钱若打了水漂，本蛾子不负责。 12 月 28 日更新：删去了大段大段没啥用的安全性分析。\n👌 我知道了，开始吧 准备好了？让我们先看看大概要做什么。\n购买 RackNerd 服务器（0x04 节）； 购买 Namesilo 域名并用 Cloudflare 托管（0x04 节）； 服务器初步设置，对于建站比较通用（0x05 节）； 搭建代理服务器，此时您已经可以使用代理了（0x05 节）； （可选）使用 Cloudflare 的 CDN 和 WARP 服务，对服务器前后流量进行优化（0x06 节）； （可选）安全性和速度提升（0x06 节）。 本蛾子趁着双十一购买了服务器和域名，总价 27.86（¥200.87，按照支付宝和 Stripe 的汇率），如果您不幸地在没什么活动的时候看到这篇文章，也可以选择到 RackNerd 社区去找找优惠，下面会说到。如果没有什么意外（不可能），搭建时间会在 30 到 40 分钟。\n💵 花钱 其实本蛾子一直都想哪次出国旅游，把台式机带着，找个角落连上网线和电源，就这么免费享受家宽加上超高性能。当然是瞎想了。\n首先我们来到 RackNerd。活动期间会有首页横幅，点击进入即可。RackNerd 的老板据说是华人，除了北美常见节日有活动，双十一、春节等等国内节日也有，并且优点是续费可以原价。如果有可能的话，就在双十一前后买，这样到期之后重新购买，相当于免费换一个 IP。\n如果没有活动，也可以去 RackNerd 的社区活动，常年有优惠，最低价格 10.99，甚至比这个活动还要低。\n无论如何，我们现在可以选择四个套餐，具体配置大家可以自己看，这里本蛾子推荐：\n如果您没有建站的需要，11.11 套餐足矣。 如果您希望在代理之外做点好玩的（WordPress、游戏服务器等），建议购买 25.98 套餐。 注：这里的价格是按照双十一活动写的，如果您查看的是社区活动，请相应选择第一档和第三档套餐。为啥？主要看以下几个指标：\n🧮 vCPU 和内存：这两个决定了能跑多少服务以及性能，如果只是代理，1 vCPU 加上 1 GiB 内存绰绰有余，但是如果有其他想法，尤其是内存容易捉襟见肘； 🛜 流量和带宽：决定你一个月能用多少流量，最低的 1 TiB 都远超机场了，但是注意这个流量包括您在服务器上下载的内容和发送的内容，也就是说您做代理的的用量会是两倍，如果您要看什么 8K 视频，建议还是选大点的带宽为妙； 💾 硬盘：能存多少东西，RackNerd 是全 SSD 的，本蛾子跑过分，也说明如此，大可放心，至于容量，看您自己的需求； 🗺️ 位置：重点来了，这是我们的场景下最重要的内容之一。RackNerd 只有一处 MC 机房（洛杉矶），其他均为 CC（关于 MC 和 CC 区别请自行搜索），后者有时候会出现谷歌验证码、流媒体封禁的情况，而 11.11 套餐是没有 Los Angles DC-02 选项的！并且洛杉矶有直通中国的电缆，因此速度上会比较好看，丢包也稍微少点，通过 RackNerd 的测试页面来看，前后差距能达到 10 倍！但是 RackNerd 看来是超售了，晚高峰时间段还是会卡顿。 12 月 12 日更新：如果使用了下文所述的 WARP 代理，有一定几率也会跳谷歌验证码，介意的话可以不开 WARP，或者多试几次，找一个好的 IP 用。\n12 月 28 日更新：是 WARP 的锅，由于其默认使用 IPv6，提高了许多站点的敏感度，而且这些 IP 都是万人共用，有追求的话可以购买 WARP+ 或者——换一家 VPS 吧。\n关于地址再多说一点，千万不要为了省几刀去买最便宜的套餐，垃圾线路对速度影响真的很大。如果您已经选择了稍贵一点的线路，也请注意不要选错位置，不然多花的钱就浪费了。\n以下是一个示例，需要注意的地方本蛾子用红框框标注了，大家自查：\n大家应该知道 Ubuntu 并不适用于服务器，但是我们这里还是没有选择企业级 Linux 例如 Rocky Linux，主要有几个原因：\nRocky Linux 9 的 NetworkManager 更新需要手动操作，怕大家不大熟悉 Linux； Rocky Linux 的软件包很旧，有些新的脚本用不了； Rocky Linux 预装了比较麻烦的 SELinux，这是个好东西，但是在我们的情况下比较复杂且易导致错误。 12 月 28 日更新：其实用 Rocky Linux 也可以，文末添加了教程。不知道为什么 Ubuntu 的 SSH 总是一顿一顿的。\n选好了服务器配置，接下来就可以付款了。记得选择支付宝，用手机扫码付款，然后注册一个 RackNerd 账号来管理，这些就不详细说，相信大家是会的。付款之后，您填写的邮箱会收到一封邮件，里面包含了 VPS 的 root 密码，以及他们 NerdVM 管理账号。先不着急去连接，我们再来付钱买个域名。\n域名嘛，我直接推荐大家去 Namesilo 注册一个 .top，江苏的一家公司运营，非常便宜，首年 1.88，续费 4.88，什么 .com 之类的就别奢望了，价格普遍 20+。其实 Spaceship 有一些活动非常诱人，例如 .one 首年只要 0.98，但是次年要 23.98，所以……擦亮眼睛吧。\n接下来，同样注册一个账号，我们直接付款购买。\n域名注册好之后，我们马上会将 DNS 记录转移到 Cloudflare 托管，但是由于 Cloudflare 的域名注册没有 .top 的授权，所以不能彻底转移，后期的续费等操作还是要在 Namesilo 上操作。其实如果你只是想搭建一个代理，可以没有域名，但是为了证书和避免 IP 暴露，我们还是买一个为好。\n打开 Cloudflare，注册之类的工作相信大家都会，就不细说了，完成之后我们看到账户主页就有 Add a domain 的选项，我们点击。\n输入你的域名，并根据提示在 Namesilo 将 DNS 服务器修改为 Cloudflare 提供的两个。要说 Namesilo 的管理界面是真的古旧，算了算了，还是给大家演示一下怎么修改 DNS 记录吧。\n首先，在用户的 Dashboard 上打开域名管理。\n然后选择我们刚刚购买的域名，右侧有一个疑似数据库管理的图标——实际上是 DNS 服务管理。\n然后我们删除原来所有的 DNS 服务器，并添加 Cloudflare 提供的服务器。\n这时候我们回到 Cloudflare（是的，接下来基本可以和 Namesilo 这个丑陋的界面说再见了），等待 Cloudflare 的 DNS 信息更新，过一会儿我们就能看见成功的提示了。\n关于 Cloudflare 服务的用法还有很多（大善人的名号不是白叫的），目前的设置应该够用了，本蛾子过段时间可能再写一篇文章，说说怎么用 Cloudflare 的服务给自己的网站增加安全性。（致各位信奥赛选手：如果您的机房采用了极域、育林卫、（旧版）联想以及很多旧的网络控制系统，让您无法上网（但是可以看到一个阻止页面），那么 DNSSEC 能让您的网站正常使用（防止 DNS 污染）。）\n0x05 建站 现在我们可以翻出刚刚 RackNerd 的那封邮件了。简单阅读一下，最重要的信息是两个：\nIP 地址和用于 SSH 的用户名和密码； NerdVM 账户。 后者我们暂时还是用不到，所以先别着急删除邮件。如果您使用 Windows，打开 PowerShell；如果您使用 Linux——这还需要本蛾子教您吗？总之打开一个现代的终端，几乎所有平台都已经有了 OpenSSH。我们使用以下命令连接：\n$ ssh root@[YOUR_IP_ADDRESS] 嗯……有问题吗？前面那个 $ 不是命令的一部分啦，是说您要用普通用户执行！[YOUR_IP_ADDRESS] 是刚刚看到的 IP 地址！\n本蛾子说过您需要最基本的 Linux 知识。\n如果您是首次连接，那么会出现询问您是否保存指纹的提示，直接输入 yes 即可。然后输入刚刚的 root 密码，密码是不显示的，输完之后直接按回车，如果输出了按住退格一会儿，清空输入，如果干脆不想连接了直接按 Ctrl-C 中止。\n不出意外，一长串信息将会欢迎您：\nWelcome to Ubuntu 22.04.5 LTS (GNU/Linux 5.15.0-125-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/pro System information as of *** System load: *** Processes: *** Usage of /: *** Users logged in: *** Memory usage: *** IPv4 address for eth0: *** Swap usage: *** * Strictly confined Kubernetes makes edge and IoT secure. Learn how MicroK8s just raised the bar for easy, resilient and secure K8s cluster deployment. https://ubuntu.com/engage/secure-kubernetes-at-the-edge Expanded Security Maintenance for Applications is not enabled. *** updates can be applied immediately. Enable ESM Apps to receive additional future security updates. See https://ubuntu.com/esm or run: sudo pro status 这段文字里包含了系统信息、版本，当前状态，还有，咳咳，Ubuntu 的广告。\n下面会出现一个您可能很熟悉的东西——刚刚输入 SSH 命令的时候见过？\nroot@racknerd-***:~# 这就是命令提示符了，您后面的命令都需要这样输入。但是现在我们通过 root 登录，还用 SSH，这是非常危险的，所以第一步是建立一个有 sudo 权限的普通账户，并且禁止 root 通过 SSH 登录。\nroot@racknerd-***:~# useradd -m -G sudo admin 添加一个名为 admin 的用户，并分配进入 sudo 组。注意似乎除了 Ubuntu 没人把特权组叫作 sudo，不是都叫 wheel 吗？\nroot@racknerd-***:~# passwd admin New password: Retype new password: passwd: Password updated successfully 在提示输入新密码的地方输入，然后重复一遍。注意仍然是不显示的。\n在修改 SSH 设置之前，我们先测试一下，防止设置有问题，待会儿就没法通过 root 连接服务器了。\nroot@racknerd-***:~# su - admin admin@racknerd-***:~$ 注意到提示符的变化了吗？我们进入了普通用户模式。\nadmin@racknerd-***:~$ sudo apt --version [sudo] password for admin: 输入您刚刚设置的密码，你应该可以看到 APT 的版本信息，但是如果你看到的是：\nadmin is not in the sudoers file. 说明你刚刚的设置存在问题，比如没有加入 sudo 组。\n如果没有什么问题，接下来我们就可以禁用 root 的 SSH 登录了。\nadmin@racknerd-***:~$ sudo vim /etc/ssh/sshd_config 路径名称可以使用 Tab 补全。如果您不会使用 Vim，请自行在网上搜索一下，有很多相关的教程，这里只需要关注两个：\n正常模式（启动时）下输入 i 进入输入模式； 按下 \u0026lt;esc\u0026gt; 退出输入模式，回到正常模式； 正常模式下输入 / 搜索，回车到达； 结束编辑之后，在正常模式下输入 :wq 退出 Vim 并保存。 很简单吧！我们这里只需要查找到 PermitRootLogin 这个设置，将之后的 yes 修改为 no 就行，然后退出 Vim，并重启 sshd 服务：\nadmin@racknerd-***:~$ sudo systemctl restart sshd 然后输入 exit 并重新用 admin@[YOUR_IP_ADDRESS] 连接，这样您使用的就是普通用户了。\n12 月 28 日更新：如果您想进一步防止 SSH 暴力破解密码，请按使用 SSH 公钥登录服务器并禁用密码的说明操作。\n最基本的事情做完了，接下来我们来更新一下。目前 RackNerd 提供的最新版本是 22.04 LTS，最新的则是 24.04 LTS，您千万不要动心去 do-release-upgrade，主要是因为我们毕竟不在服务器跟前，防止出现什么问题我们无法调试。什么？需要换源吗？开玩笑，我们的服务器可是在美国！\nadmin@racknerd-***:~$ sudo apt update \u0026amp;\u0026amp; sudo apt upgrade 更新完成，由于我们没有 Live Patch 之类的高科技，还是需要老老实实地重启：\nadmin@racknerd-***~$ sudo reboot 稍等 1 分钟，再次连接，Ubuntu 的软件包就是最新的了！\n接下来，我们就开始代理的搭建了。其实最好是要自己手动搭建，毕竟那些 N 合一的脚本出过一些挂马、挖矿的幺蛾子丑闻，但是这里为了方便（绝对不是本蛾子没搭建成功），我们还是采用一个本蛾子验证过且很有名的脚本：233boy/v2ray，这样一死一大片。\n首先下载脚本：\nwget https://raw.githubusercontent.com/233boy/v2ray/refs/heads/master/install.sh 执行，安装：\nbash install.sh 这时候脚本会直接给出一个链接，但是暂时不要使用，因为它是纯 VLESS，没有加密，没有 CDN，也没有配置我们花费 1.88 巨款买的域名来防止 IP 泄露。我们再次打开面板：\nsudo v2ray change 然后输入 1 更改协议，输入 8 选择 VLESS + WS + TLS。选择 WebSocket 作为加密是因为 Cloudflare CDN 只支持 WS。\n然后便又一次给出一个订阅链接。这个链接其实已经可以使用了，但是建议还是不要连接，否则特征流量太多容易被封。\n我们回到 Cloudflare 将域名（可以是子域名）解析到服务器 IP，注意这时候不要开启小黄云，否则脚本无法验证域名是否能到达服务器。\n再次使用 sudo v2ray change 打开修改面板，选择 3 更改域名，输入上述域名，这时候可以发现给出的订阅链接又有变化，但是依然不要使用。\n再再次使用 sudo v2ray change，我们来换个端口，考虑到大家可能会用服务器来建站，所以我们尽量不要占用 443 端口，而是使用 Cloudflare CDN 支持的端口，根据您的情况，可以修改为：2053，2087，2096 或者 8443。给出的链接依旧不要使用。\n再再再回到 Cloudflare（读者：你有完没完），打开小黄云。好了，你可以使用上一步的代理链接了。\n什么？您手滑把终端 clear 了？这么不小心，肯定和本蛾子没关系。使用 sudo v2ray i 查看配置就行了。\n12 月 28 日更新：如果您不小心把原来的 SSH 公私钥丢了，上述命令能让您在无法显示中文的 VNC 中直接查看订阅信息。\n⚙️ 优化 到这时候我们安全的问题就基本解决了。我们的请求现在是这样的：\n您的客户端发送请求到 Cloudflare 边缘服务器（过墙，HTTPS 加密，常规流量）； Cloudflare 边缘服务器发现 CDN 没有缓存（那肯定的），发送请求到服务器（墙外，TLS 加密，常规流量）； 服务器的 v2ray 接收到请求，将数据包发送回 Cloudflare 边缘服务器（墙外，TLS + WS 加密，VLESS 特征流量）； Cloudflare 边缘服务器将您的数据发送回客户端（过墙，HTTPS + TLS + WS 加密，VLESS 特征流量）。 可以发现，我们的客户端和服务器都只与 Cloudflare 边缘服务器进行通信，本质上和您访问 Cloudflare Dashboard 没有区别。但是还有一点：您的服务器 IP 是 IDC 机房 IP，非常脏，有些流媒体服务无法使用。因此我们可以在服务器端再次部署一个 WARP 代理，使用 Cloudflare 的 IP 获得更好的纯净度。\nwget https://gitlab.com/fscarmen/warp/-/raw/main/menu.sh 接下来，运行脚本：\nbash menu.sh 第一个选项选择 3，剩余的保持默认即可。不出意外，您的服务器将可以连接 WARP 网络，获得一个（大概率）IPv6 地址。恭喜您，最后一块砖，填上了！\n还是很不错的。\n您现在应当可以观看 YouTube+、Disney+ 和 Netflix 非自制剧。如果您是维基人，那么很遗憾，Wikipedia 的编辑还是无法解锁，并且 MediaWiki 不知道有什么魔法，能识别两个 IP，您获得了一个双重封禁！\n12 月 28 日更新：刚刚运行 v2ray 的时候不要着急启动 WARP，这将导致 Caddy 自动获取证书失败。后期如果发现没法连接，也可以回来关掉 WARP，重启 Caddy，获取成功之后再启动。\n✏️ 后记 其实这篇文章到这里还没有结束。服务器管理本身就是很复杂的工作，如果您还想建站，那又是很复杂的工作。您现在想必已经可以自由访问，虽然晚高峰时段部分站点存在卡顿，但是整体还是很不错的。\n最后，提醒您：外网可供您学习、娱乐，但是如果您不是隐私大佬，请不要贸然使用您的任何真实信息和国内身份注册任何服务，或者在网站上发表不当言论。本蛾子是 OIer，外网对本蛾子的吸引力集中在 Stack Overflow、GitHub、Google Scholar 和 Wikipedia，而您，我不知道为啥会想上外网。\n⛰️ 附录：RHEL 系发行版指南 如果您是 RHEL 忠实用户、想使用 SELinux 或者就是不喜欢 Ubuntu，那么本指南的大部分内容依旧适用，有几点需要注意。\n特权组名称为 wheel 而非 sudo。\n如果您计划禁用密码登录，请勿设置 UsePAM no。\n默认启动 firewalld，出于安全考虑，请不要按照网上的教程直接关闭，放行部分端口即可：\n$ sudo firewall-cmd --add-port=2053/tcp --permanent # 2053 改为您在一键脚本里设置的端口号 $ sudo firewall-cmd --add-port=2053/udp --permanent # 别忘了 UDP $ sudo firewall-cmd --reload # 所有未加 --permanent 的规则会失效 SELinux 会阻止 v2ray 使用 443 端口。在做其他事儿的时候也经常会干涉，硬控本蛾子的调试时间。这玩意儿本蛾子也玩不转，据说是 Linux 权限系统的补充，所以还是把它关掉吧：\n$ sudo vim /etc/selinux/config # 将 SELINUX=enforcing 改为 SELINUX=disabled $ sudo reboot # 必须重启 调试 SELinux 导致本蛾子的服务下线时间比 DDoS 还长，于是就自暴自弃了 😮‍💨\n某些额外的包没有预装，按照报错 sudo dnf provides [name] 再 sudo dnf install [name] 即可。\nRackNerd 提供的 Rocky Linux 和 AlmaLinux 首次更新的时候由于 network-scripts 被弃用，会报错，添加 --allowerasing 参数即可。\n12 月 28 日更新：Rocky Linux 更新导致三四个包都出了问题，本蛾子也不能打包票好用。建议转换至 AlmaLinux，处理起来比较简单。\n","permalink":"http://localhost:1313/posts/4f6adc86c6/","summary":"\u003cp\u003e😡 \u003cstrong\u003e太长不读版\u003c/strong\u003e：使用 VLESS + WebSocket + TLS 方案、Cloudflare CDN 保护、Cloudflare WARP 解锁服务，在 RackNerd 的 10.99/yr 起廉价服务器上搭建一个安全、隐私、不易封的代理服务器。无广告，很详细。如果您已经下定决心要自己搭建，请跳过 0x01 和 0x02 节。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文如未特殊提及，货币单位均为美元。好吧，其实是会被 KaTeX 识别成数学公式……\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e各位想必都已经混迹互联网十余载，对于这门技术有所耳闻，甚至自己购买过机场的订阅，在外面的世界已经遨游过一番了。今天本蛾子就讲一个老生常谈的问题：\u003cstrong\u003e老是觉得那些机场主都不可靠，我能不能自己搭一个？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e首先在文章开始之前，国际惯例，对于几个常见误解进行声明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e本蛾子\u003cstrong\u003e热爱中华人民共和国\u003c/strong\u003e，\u003cstrong\u003e热爱中国共产党\u003c/strong\u003e，\u003cstrong\u003e绝无污蔑、诋毁国家、党和人民的行为\u003c/strong\u003e，本文的目的仅仅是技术分享，读者您的行为的后果由您自行承担；\u003c/li\u003e\n\u003cli\u003e本蛾子没有收一分钱；相反，还因为购买服务器和域名花了 30 多，本文请放心食用；\u003c/li\u003e\n\u003cli\u003e搭建代理服务器是一个比较复杂的过程，您应当有最基本的 Linux 使用能力，对网络相关知识有一定了解；\u003c/li\u003e\n\u003cli\u003e无论是自建的代理还是机场，总有被封或跑路的一天，您的钱若打了水漂，\u003cstrong\u003e本蛾子不负责\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e12 月 28 日更新：删去了大段大段没啥用的安全性分析。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"-我知道了开始吧\"\u003e👌 我知道了，开始吧\u003c/h2\u003e\n\u003cp\u003e准备好了？让我们先看看大概要做什么。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e购买 RackNerd 服务器（0x04 节）；\u003c/li\u003e\n\u003cli\u003e购买 Namesilo 域名并用 Cloudflare 托管（0x04 节）；\u003c/li\u003e\n\u003cli\u003e服务器初步设置，对于建站比较通用（0x05 节）；\u003c/li\u003e\n\u003cli\u003e搭建代理服务器，此时您已经可以使用代理了（0x05 节）；\u003c/li\u003e\n\u003cli\u003e（可选）使用 Cloudflare 的 CDN 和 WARP 服务，对服务器前后流量进行优化（0x06 节）；\u003c/li\u003e\n\u003cli\u003e（可选）安全性和速度提升（0x06 节）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e本蛾子趁着双十一购买了服务器和域名，总价 27.86（¥200.87，按照支付宝和 Stripe 的汇率），如果您不幸地在没什么活动的时候看到这篇文章，也可以选择到 RackNerd 社区去找找优惠，下面会说到。如果没有什么意外（不可能），搭建时间会在 30 到 40 分钟。\u003c/p\u003e","title":"搭建自己的代理服务器"},{"content":"状态是，啊？离离离离——哟哟——\n对应洛谷题号：\n单调队列优化 线性 DP 例题：PTA-Little Bird（洛谷 P3572）\n设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \\min{f_{j} + h_{i} \\geq h_{j}}$，其中 $i - k \\leq j \\lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。\n上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。\n如果队头的元素（最小值）在范围内，我们直接采用； 如果队头的元素不在范围内，我们将其删除； 新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。 代码：\n要点：\n第 19 行执行了出队操作； 第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。 多重揹包 例题：BAN-Bank Notes（洛谷 P3423）\n对题意进行分析，发现：\n揹包容量是面值 $k$； 物品体积是每种硬币的面值； 物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。 设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \\max{f_{i - 1,j - k \\times w_{i}} + k \\times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \\Sigma c_{i})$。\n倍增优化：这个转移方程的时间复杂度瓶颈在于对于每种面值的硬币选取多少个的枚举，因此我们可以将其转换为倍增的 01 揹包，也就是将可以取无限个的物品转化为 $w_{i}, v_{i}$，$2 \\times w_{i}, 2 \\times v_{i}$，$4 \\times w_{i}, 4 \\times v_{i}$ 等等的单个物品。对于具有连续枚举的 DP，倍增优化是一种常见的方法。\n单调队列优化：考虑 $j$ 时的决策，有贡献的可能是 $j - b_{i}$，$j - 2 \\times b[i]$，$j - 3 \\times b_{i}$ 等；$j + b_{i}$ 时，则为 $j$，$j - 1 \\times b_{i}$，$j - 2 \\times b_{i}$。因此可以发现，这里又出现了重复贡献的计算，因此我们依然可以使用单调队列进行优化。\n出现新的元素时，我们在加入队列之前需要将队列中所有的元素都添加 $v_{i}$，时间复杂度较高。但是可以发现，反过来我们可以给新加入的元素对应的值减去 $v_{i}$，然后加入单调队列，时间复杂度大大降低。其中可以体现「正难则反」的思想。\n代码：\n网格图上的 DP 原始题型：\n例题：方格取数（洛谷 P7074）\n本题的特殊之处在于，通常而言网格图问题只能向右或向下，但是本题可以多了向上的方向，因此上下的 DP 状态按照原来的方法就相互依赖，不可行。\n因此这里我们需要改进我们的状态设计。原本的二维 DP 之外，我们额外添加一个表示方向的维度，即 $f_{x,y,d}$，其中 $d \\in {0, 1, 2}$，表示当前格子从下、左或上方到达当前格子的最大结果。因此可以先对第一列填充（只能向下），然后填充剩余部分的右、下方向，最后从下往上填充上方的值。\n对应的转移方程为：\n$f_{i,1,1} = f_{i - 1,1,1} + a_{i,1}$ 例题：Palindromic Paths（洛谷 P3126）\n回文串就要求路径上的字母是对称的，因此我们可以枚举步数和两个对应的座标，这 5 个值中有 1 个可以由其他 4 个推出，因此设计状态为 $f_{x_{1},y_{1},x_{2},y_{2}}$ 或 $f_{step,x_{1},y_{1},x_{2}}$。再次考虑，可以发现其实只需要横座标就可以推出当前位置，并且步数的维度可以用滚动数组压缩，因此规避了数组过大无法开出的问题。\n代码：\n状态压缩 DP 例题：PRZ（洛谷 P5911）\n对于状态维度很多、但是每个维度的信息很少的 DP，可以使用一个二进制数表示当前状态。在本题中，设 $f_{s}$ 中 $s$ 表示当前哪些人已经过桥，例如 10001 表示第一个和第五个人已经过桥，其他人则没有。\n代码：\n其中状态枚举的部分，先枚举每个情况，再对于每个情况从它的子集递推。\n例题：Corn Fields（洛谷 P1879）\n本题在状压 DP 的基础上，需要添加一维，作为公共边的表示。\n数位 DP 例题：数字计数（洛谷 P2602）\n首先对于题意进行转换，由于左右区间的计算比较困难，可以将其转化为 $[1, b]$ 中的计数，减去 $[1, a]$ 之间的计数。\n在数位 DP 中，一般会由高位到低位进行处理。\n设 $f_{i,j}$ 表示 $i$ 位所有以 $j$ 开头的所有数字中，含数字 $7$ 的个数，那么有状态转移方程：\n其中第二个表达式的 $10^{i - 1}$ 表示 $7$ 开头的数字，所有的都应当被计入。例如：\n其中的 $69$ 表示，所有 $97$ 开头的数字都含有 $7$，也就是第三位的贡献。\n数位 DP 的套路包括：\n按位生成 $f$ 表达式； 按位计算存在的情况，并在高位出现情况时添加贡献。 代码：\n用递推实现数位 DP，情况的分类比较多，因此实现比较麻烦。递归的方法，需要解决的情况就少了很多，写法很简单。\n代码：\n中间有一行截断了，后面是 , d。\n其中参数的含义分别为：\ncur：当前是第几位； up：当前位之前的数字是否已经到达最大，也就是说这一位是否可以到 9，还是只能到右边界的对应值； sum：目前已知的情况的总和； zero：是否有前导零； d：总数位。 题目讲解 Bribing Friends（洛谷 P8903） 本题中钱数是揹包的总容量，每个朋友所需的钱和甜筒是每个物品的体积，而受欢迎程度则是物品的价值。\n考虑第 $i$ 个朋友，使用 $x$ 元钱和 $y$ 个甜筒所能获得的最大价值，即 $f_{i,x,y}$。由此很容易推出 DP 状态转移方程，时间复杂度 $O(n^3)$。\n将所有朋友按每元钱所需甜筒排序，对于较大的，应当尽量使用钱；较小的，应当尽量使用甜筒。这样可以从两个方向进行递推，然后得出最终结果。\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; #define int long long #define N 2010 using namespace std; int n, a, b; int f[N][N], g[N][N]; struct node { int p, c, x; } cow[N]; bool cmp(node x, node y) { return x.x \u0026lt; y.x; } signed main() { freopen(\u0026#34;friends.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;friends.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; cow[i].p \u0026gt;\u0026gt; cow[i].c \u0026gt;\u0026gt; cow[i].x; sort(cow + 1, cow + n + 1, cmp); for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= b; j++) f[i][j] = f[i - 1][j]; for (int j = 0; j + cow[i].x * cow[i].c \u0026lt;= b; j++) f[i][j + cow[i].x * cow[i].c] = max(f[i - 1][j + cow[i].x * cow[i].c], f[i - 1][j] + cow[i].p); } for (int i = n; i \u0026gt;= 1; i--) { for (int j = 0; j \u0026lt;= a; j++) g[i][j] = g[i + 1][j]; for (int j = 0; j + cow[i].c \u0026lt;= a; j++) g[i][j + cow[i].c] = max(g[i + 1][j + cow[i].c], g[i + 1][j] + cow[i].p); } int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans = max(ans, f[i][b] + g[i + 1][a]); ans = max(ans, f[i - 1][b] + g[i][a]); for (int j = 0; j \u0026lt;= min(a, cow[i].c); j++) { if (cow[i].x * (cow[i].c - j) \u0026gt; b) continue; ans = max(ans, f[i - 1][b - cow[i].x * (cow[i].c - j)] + g[i + 1][a - j] + cow[i].p); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } Bomboni（洛谷 P9759） 这个部分没有太听懂……\n代码：\n#include \u0026lt;bits/stdc++.h\u0026gt; #define ll long long #define N 510 #define mod 998244353 using namespace std; int n, K; int a[N][N]; int cnt = 0, fac[N], num[1000010]; int f[N][N][N]; void init(int n, int k) { for (int i = 1; i \u0026lt;= k; i++) { if (k % i == 0) { fac[++cnt] = i; num[i] = cnt; } } fac[++cnt] = k; num[k] = cnt; } ll gcd(ll x, ll y) { return __gcd(x, y); } int main() { freopen(\u0026#34;candy.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;candy.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; K; memset(a, -1, sizeof a); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= n; j++) { cin \u0026gt;\u0026gt; a[i][j]; if (a[i][j] != -1) a[i][j] = gcd(a[i][j], K); } init(n, K); f[1][1][num[gcd(a[1][1], K)]] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (a[i][j] == -1) continue; for (int k = 1; k \u0026lt;= cnt; k++) { if (!f[i][j][k]) continue; if (a[i + 1][j] != -1 \u0026amp;\u0026amp; i \u0026lt; n) { int x = gcd(K, 1ll * fac[k] * a[i + 1][j]); f[i + 1][j][num[x]] = (f[i + 1][j][num[x]] + f[i][j][k]); if (f[i + 1][j][num[x]] \u0026gt;= mod) f[i + 1][j][num[x]] -= mod; } if (a[i][j + 1] != -1 \u0026amp;\u0026amp; j \u0026lt; n) { int x = gcd(K, 1ll * fac[k] * a[i][j + 1]); f[i][j + 1][num[x]] = (f[i][j + 1][num[x]] + f[i][j][k]); if (f[i][j + 1][num[x]] \u0026gt;= mod) f[i][j + 1][num[x]] -= mod; } } } } cout \u0026lt;\u0026lt; f[n][n][cnt] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } Redistributing Gifts（洛谷 P8189） 代码：\n//钟跺帇DP #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; namespace IO{ template \u0026lt;typename T\u0026gt; inline void write(T x) { if(x \u0026lt; 0) putchar(\u0026#39;-\u0026#39;) , x = - x; if(x == 0) { putchar(\u0026#39;0\u0026#39;) ; return ; } if(x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); //瀛楃杈揿嚭 return ; } template \u0026lt;typename T\u0026gt; inline void read(T \u0026amp;x) { x = 0; int w = 1; char ch = getchar(); while (!isdigit(ch)) { if (ch == \u0026#39;-\u0026#39;) w = -1; ch = getchar(); } while (isdigit(ch)) x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (ch ^ 48) , ch = getchar(); x *= w; return ; } } #define writeln(x) write(x) , putchar(\u0026#39;\\n\u0026#39;) #define writesp(x) write(x) , putchar(\u0026#39; \u0026#39;) using namespace IO; #define For(i, j, k) for(int i = (j); i \u0026lt;= (k); ++i) #define Dec(i, j, k) for(int i = (j); i \u0026gt;= (k); --i) #define mp make_pair #define pii pair\u0026lt;int, int\u0026gt; #define ppi pair\u0026lt;pii, int\u0026gt; #define ckmax(a, b) ((a) = max((a), (b))) #define ckmin(a, b) ((a) = min((a), (b))) #define pb emplace_back //姣攑ush_back蹇偣锛屽姛鑳戒竴镙凤纴搴曞眰瀹炵幇绋嶆湁鍖哄埆 #define inf 0x3f3f3f3f #define fi first #define se second #define N 20 #define ll long long ll dp[1 \u0026lt;\u0026lt; N][N]; ll ans[1 \u0026lt;\u0026lt; N]; char op[N]; int n, x, g[N]; int main() { freopen(\u0026#34;gifts.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;gifts.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); read(n); For(i, 0, n - 1) { //姹俫[i] bool flag = true; For(j, 0, n - 1) { read(x); --x; if (!flag) continue; g[i] ^= (1 \u0026lt;\u0026lt; x);// 瀛桦偍镓€链夊ザ鐗沬鑳芥敹𫔄扮殑绀肩墿x if (x == i) flag = false;\t} } ans[0] = 1; for (int k = 0; k \u0026lt; n; ++k) dp[1\u0026lt;\u0026lt;k][k] = 1; For(i, 0, n - 1) { For(mask, 1 \u0026lt;\u0026lt; i, (1 \u0026lt;\u0026lt; (i + 1)) - 1) { For(last, 0, i) { if (!(mask \u0026amp; (1 \u0026lt;\u0026lt; last))) // 杩囨护涓嶅湪褰揿𫮃板嗗悎镄勫ザ鐗? continue; ll val = dp[mask][last]; For(k, 0, i - 1) if (!(mask \u0026amp; (1 \u0026lt;\u0026lt; k)) \u0026amp;\u0026amp; (g[last] \u0026amp; (1 \u0026lt;\u0026lt; k))) // 涓嶅湪mask涓笖濂剁坛last鍙互鏀跺埌镄勭ぜ鐗﹌锛岃繘琛岀姸镐佽浆绉? dp[mask^(1\u0026lt;\u0026lt;k)][k] += val; if (g[last] \u0026amp; (1 \u0026lt;\u0026lt; i)) // 濡傛灉濂剁坛last鍙互鏀跺埌绀肩墿i锛屽垯mask闂幆浜嗐€傚嵆绀肩墿板唌ask鍜屽ザ鐗涢泦mask閮藉缑𫔄颁简鍖归历 ans[mask] += val;\t} For(k, i + 1, n - 1) // 璁＄畻瀹宎ns[mask] 旋存柊楂树綅mask镄刣p dp[mask^(1\u0026lt;\u0026lt;k)][k] += ans[mask]; } } int q; read(q); while (q--) { cin \u0026gt;\u0026gt; op; int H = 0, G = 0; For(i, 0, n - 1) if (op[i] == \u0026#39;H\u0026#39;) H ^= (1 \u0026lt;\u0026lt; i); else G ^= (1 \u0026lt;\u0026lt; i);\twriteln(ans[H] * ans[G]); } return 0; } Piling Papers（洛谷 P9129） #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define N 310 #define Q 50010 const int mod = 1e9 + 7; int n, q; ll A, B; int a[N], ans[Q], C[N][N], pow2[N]; int f[N][20][20], g[N][20][20][20]; struct node { int l, r, id; }que[Q]; bool cmp(node a, node b) { if (a.l != b.l) return a.l \u0026lt; b.l; return a.r \u0026lt; b.r; } void solve(ll x, int fh) { int p = 1; int num[20], cnt = 0; while (x) { num[++cnt] = x % 10; x /= 10; } reverse(num + 1, num + cnt + 1); for (int lft = 1; lft \u0026lt;= n; lft++) { // 缁熻浠?lft 寮€濮嫔悜鍙抽€夌墝镄勬柟妗堟暟 memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g)); for (int rgt = lft; rgt \u0026lt;= n; rgt++) { for (int len = 1; len \u0026lt;= cnt; len++) { for (int i = 1; i + len - 1 \u0026lt;= cnt; i++) { int j = i + len - 1;//f[rgt][i][j]琛ㄧず鍙栧埌a[rgt](鍙笉鍙栵级锛屾嫾鎴?x[i]钬斺€撺[j]镄勬柟妗堟暟锛堣繖阅寈瑙嗕负涓€涓瓧绗︽暟缁勶级銆? (f[rgt][i][j] += f[rgt - 1][i][j]) %= mod;//杩𪲔槸涓€涓尯闂村姩镐佽𫔄掞纴鍖洪棿[i,j]鍙敱[i+1,j]鍜𪧀i,j-1]杞Щ钥屾潵銆? if (len == 1) { // i == j if (a[rgt] == num[i]) (f[rgt][i][j] += 2) %= mod;// 1 or 2 method } else { if (a[rgt] == num[i]) (f[rgt][i][j] += f[rgt - 1][i + 1][j]) %= mod; // 锷犲𫮃闱?( 1 method ) if (a[rgt] == num[j]) (f[rgt][i][j] += f[rgt - 1][i][j - 1]) %= mod; // 锷犲悗闱?( 2 method ) } } } } for (int rgt = lft; rgt \u0026lt;= n; rgt++) { for (int len = 1; len \u0026lt;= cnt; len++) { for (int i = 1; i + len - 1 \u0026lt;= cnt; i++) { int j = i + len - 1;// 褰撴嫾鍑虹k浣嶅皬浜巟[k]镄勬暟锛屼笖绗琸浣崭箣鍓崭笌x涓€镊寸殑鏁版椂锛宬涔嫔悗镄勬暟鍙互浠诲彇銆? for (int k = i; k \u0026lt;= j; k++) { //浠[rgt][i][k][j]琛ㄧず鍙栧埌a[rgt]锛屾嫾鍑簒[i]𫔄皒[k-1]锛岀k浣嶅皬浜巟[k]涓旗k + 1𫔄癹浣崭换镒忓彇镄勬柟妗堟暟銆? (g[rgt][i][k][j] += g[rgt - 1][i][k][j]) %= mod; if (i == k) {// 锷犲𫮃闱?(1 method, a[rgt]鏀惧湪i) if (a[rgt] \u0026lt; num[i]) { // 鍖洪棿[k+1,j]镄勬暟浠巃镄刐lft, rgt-1]鍖洪棿阅屼换镒忛€夋嫨涓€涓粍钖? int tmp = (ll)C[rgt - lft][j - k] * pow2[j - k] % mod; (g[rgt][i][k][j] += tmp) %= mod; } } else { if (a[rgt] == num[i]) (g[rgt][i][k][j] += g[rgt - 1][i + 1][k][j]) %= mod; } if (k == j) {// 锷犲悗闱?2 method, a[rgt]鏀惧湪j if (a[rgt] \u0026lt; num[j]) {// all-same way + [a_t as small] int tmp = i == j ? 1 : f[rgt - 1][i][j - 1]; (g[rgt][i][k][j] += tmp) %= mod; } } else { (g[rgt][i][k][j] += g[rgt - 1][i][k][j - 1]) %= mod; } } } } } while (que[p].l == lft \u0026amp;\u0026amp; p \u0026lt;= q) { // 灏嗘墍链夎闂绾匡纴镌夌収宸︾镣规帓搴忋€傚悓涓€宸︾镣圭殑璇㈤梾鍙渶锅氩悓涓€娆?dp銆? int i = que[p].r - que[p].l + 1; for (int j = 0; j \u0026lt;= cnt - 1; j++) {// 鐭殑 ll tmp = fh * C[i][j] % mod * pow2[j] % mod; tmp = (tmp + mod) % mod; (ans[que[p].id] += tmp) %= mod; } for (int k = 1; k \u0026lt;= cnt; k++) { // 绛夐暱镄勶纴灏忎簬x镄? ll tmp = fh * g[que[p].r][1][k][cnt] % mod; tmp = (tmp + mod) % mod; (ans[que[p].id] += tmp) %= mod; } ll tmp = fh * f[que[p].r][1][cnt] % mod; // 绛夐暱镄勶纴绛変簬x镄? tmp = (tmp + mod) % mod; (ans[que[p].id] += tmp) %= mod; ++p; } } } signed main() { freopen(\u0026#34;sequence.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;sequence.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; A \u0026gt;\u0026gt; B; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; cin \u0026gt;\u0026gt; q; for (int i = 1; i \u0026lt;= q; i++) { cin \u0026gt;\u0026gt; que[i].l \u0026gt;\u0026gt; que[i].r; que[i].id = i; } sort(que + 1, que + q + 1, cmp); pow2[0] = 1; for (int i = 1; i \u0026lt;= n; i++) pow2[i] = pow2[i - 1] * 2 % mod; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= i; j++) { if (j == 0 || j == i || i == 0) { C[i][j] = 1; continue; } C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod; } } solve(B, 1); if (A \u0026gt; 1) solve(A - 1, -1); for (int i = 1; i \u0026lt;= q; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","permalink":"http://localhost:1313/posts/976003163f/","summary":"\u003cp\u003e\u003cdel\u003e状态是，啊？离离离离——哟哟——\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e对应洛谷题号：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/976003163f.d/1731832504-image.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"单调队列优化\"\u003e单调队列优化\u003c/h2\u003e\n\u003ch3 id=\"线性-dp\"\u003e线性 DP\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e例题：PTA-Little Bird（洛谷 P3572）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/976003163f.d/1731825461-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \\min{f_{j} + h_{i} \\geq h_{j}}$，其中 $i - k \\leq j \\lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。\u003c/p\u003e\n\u003cp\u003e上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果队头的元素（最小值）在范围内，我们直接采用；\u003c/li\u003e\n\u003cli\u003e如果队头的元素不在范围内，我们将其删除；\u003c/li\u003e\n\u003cli\u003e新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代码：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/976003163f.d/1731826445-image-1024x447.png\"\u003e\u003c/p\u003e\n\u003cp\u003e要点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第 19 行执行了出队操作；\u003c/li\u003e\n\u003cli\u003e第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"多重揹包\"\u003e多重揹包\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e例题：BAN-Bank Notes（洛谷 P3423）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"img\" loading=\"lazy\" src=\"../../static/img/976003163f.d/1731826730-image.png\"\u003e\u003c/p\u003e\n\u003cp\u003e对题意进行分析，发现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e揹包容量是面值 $k$；\u003c/li\u003e\n\u003cli\u003e物品体积是每种硬币的面值；\u003c/li\u003e\n\u003cli\u003e物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \\max{f_{i - 1,j - k \\times w_{i}} + k \\times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \\Sigma c_{i})$。\u003c/p\u003e","title":"集训笔记：动态规划经典模型 2"},{"content":"语速和打字速度的对决（）\n动态规划经典模型 动态规划包括线性 DP、区间 DP、树形 DP、数位 DP、状压 DP、概率 DP、期望 DP 等。\n用通模型 LIS：最长上升子序列 状态表示：集合（所有以 $a_{i}$ 结尾的上升子序列）、属性（最大值）； 状态计算：集合划分（「最后一步」） 实现版本：\n朴素算法\na[0] = -INF // 哨兵 dp[0] = 0 // 边界 for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt; i; j++) { if (a[j] \u0026gt; a[i]) { dp[i] = max(dp[i], dp[j] + 1); } } } 时间复杂度：$O(n^2)$\n算法瓶颈：内层枚举有很多无用状态\n可以使用贪心策略优化：子序列长度相同，枚举末尾的元素 $a_{j}$ 越小，后面更有可能可以连续。\n单调栈优化算法\n定义数组 $low_{i}$ 维护 LIS 长度为 $i$ 时最小的末尾；$len$ 是当前 LIS 的长度； 遍历 $a$ 时，若 $a_{i} \\gt low_{len}$，则更新最大长度，将 $a_{i}$ 添加到末尾； 否则，替换 $low$ 中第一个大于或等于 $a_{i}$ 的元素； 这样 $low$ 始终为一个单调序列，可以使用二分查找优化； 最终 $len$ 是 LIS 的长度（$low$ 不是最终的 LIS 序列）。 代码：\nLCS 最长公共子序列 状态表示 $dp_{i,j}$：集合（$a_{1 \\dots i}$ 和 $b_{1 \\dots j}$ 构成的 LCS）、属性（最大值）； 状态计算：分类讨论（$a_{i}$ 和 $b_{j}$ 是不是 LCS 的最后一位）。 状态转移方程：$dp_{i,j}=\\max{dp_{i,j-1},dp_{i-1,j}}$，其中 $a_{i} \\neq b_{i}$。\n集合讨论需要不重不漏，但是 LCS 中不同状态是有重合的，但是求的是最值，所以集合的交集是不影响的；若求总和、方案等，则必须符合这个标准。\n代码：\n其中若 $a_{i} = b_{j}$，则需要 $a$ 和 $b$ 长度都减一；若 $a_{i} \\neq b_{j}$ 则继承上次的状态的最大值。\n结合：LCIS 将 LCS 和 LIS 状态表示结合； 设 $dp_{i,j}$ 表示 $a_{1 \\dots i}$ 和 $b_{1 \\dots j}$ 且以 $b_{j}$ 为结尾的 LCIS 长度； 设 $a_{0} = b_{0} = -\\infty$ 表示空，作为哨兵；$dp_{1 \\dots n,0} = dp_{0,1 \\dots n} = 0$ 作为边界； 同样分情况讨论，$a_{i}$ 与 $b_{j}$ 不等时继承 $dp_{i - 1,j}$，相等时则在 $a$ 长度减一、$b$ 任意减少取小于 $b_{j}$ 和 $a_{i}$ 的元素，并将长度加一。 状态转移方程：\n代码：\n算法瓶颈：$i$ 不变时，$k$ 反复枚举\n通过记录每次更新后，$j$ 之前的最大值，可以直接推出 $dp$，并在修改之后，若取得的 $b_{k}$ 小于 $a_{i}$，再次更新这个最大值（延迟更新）。\n代码：\n用活模型 揹包是 DP 中的一个经典模型，由 01 揹包衍生至完全揹包、多重揹包等。每种揹包的细节实现又不同。\n01 揹包 主要分为两个描述方式：\n$dp{i,j}$ 表示前 $i$ 个物品放入容量为 $j$ 的揹包中的最大价值。\n$dp_{i,j}$ 表示「可以」放入物品的最大价值（清晰，便于计数）； $dp_{i,j}$ 表示「恰好」放入物品的最大价值（更加灵活）。 代码：\n其中内层选择不选（继承上一个物品，但是揹包容量不变的状态）、选。最后的状态判断是否不可达需要判断 $dp_{i,j}$ 小于零而不是不变。\n空间优化版本（滚动数组）：\n若逆序枚举揹包容量，还可以将空间压缩至一维数组。逆序枚举的原因是防止此前选择后再次被选择（即完全揹包）。\n超大容量的 01 揹包，将重量作为数组维数无法开出数组。例如 AtCoder 的题目，物品的总价值很小。\n可以将总价值作为维度，不枚举体积而是枚举价值，设 $dp_{i}$ 表示价值为 $i$ 时的最小总重量，然后枚举总价值，一旦找到 $dp_{i} \\leq m$ 时，直接输出即可。\n代码：\n其中 $sum$ 是物品的总价值。\n例题：Mr. Potato（洛谷 P7801） 题面：\n思路简述：\n要点：\n对于 $P_{1} \\times P_{2}$ 的计算针对一家店； $n$ 和 $a[i]$ 总和都很小，因此将袋数和土豆个数作为 $dp$ 的下标； $P_{1} \\times P_{2}$ 的表达式在枚举中，分母可以认为是固定的，因此只对分子进行 DP； 对于二次函数进行计算（初中知识），使用两个数组记录最大值和最小值，比较偷懒的方法。 代码：\n注意第一行，要求 $l$ 是比较小的那个分组数，$P_{1} \\times P_{2}$ 不受影响。for 内部第一行是第 $i$ 袋不选的情况，下面的判断则是针对可以选择的情况，记录 $x$ 的最大和最小值。\n用对模型 石子合并模型（区间 DP） 以区间的长度作为 DP 阶段，使用左右端点作为维度描述，三层循环枚举以上状态，一般可以解决，但是部分问题需要具体分析。\n例题：\n状态表示：集合（将 $[i, j]$ 合并为一堆的所有方案）、属性（最小值）； 状态计算：枚举每个区间内的划分点，分解为区间更小的两个。 状态转移方程：\n代码：\n注意只计算左端点，固定区间长度，计算右端点。\n衍生：、\n本题实质上是「带符号的」环形石子合并问题，求出最大值和可能的第一步操作，注意有负权点。\n分析：\n枚举第一步删除哪条边； 环状问题，使用破环成链的方法，通常是 2 倍方法； 设状态表示是 $dp_{i,j}$ 表示区间 $i$ 到 $j$ 合并的情况； 若只有加法，本题是标准的石子合并，但是还存在乘和负数的情况（例如负数乘负数），最大值不能从子区间推出（不符合「最优子结构」的要求）。 为了解决最后一个问题，可以每次通过正负情况判断。处理时比较所有可能的情况（9 种情况，分类讨论）。\n当然还有一种比较简单的方法：同时维护每个区间的最大和最小值，缩减为四种情况。\n代码：\n注意需要开两倍空间，并且乘法时对四种情况进行枚举，其他与简单的石子合并相同。\n复制粘贴枚举情况需要小心。\n真题：方框消除（UVA10559） 思路简述：\n同色方块的位置不连续，不同的点击顺序会影响到最终的结果（如第二张图片所示）； 预处理：将若干连续小方块看作一个方块段，处理其颜色 $color_{i}$ 和 长度 $len_{i}$； $dp_{l,r}$ 表示将大块 L 到 R 消除得到的最大值。 注意到不可以直接套用石子合并的模型：如上图，先合并中间的部分反而可以获得最高得分，可以等待中间合并完成再合并左右两边的。\n最后一步考虑的一定是最右边的大块 R； 对它的处理方式有两种方式：直接消除或者与左侧的某个同色块合并（即先处理中间的），枚举每一个情况取最优； 两种方式对应的转移方程分别为：\n这对吗？反例：1 3 1 2 1。\n将这个新大块直接消除未必比继续与左侧同色大块合并更好，因此二维递推不能得出正确的关系，其实此处有一个贪心的思路（区间越长，得分越高，可以证明）。\n优化的状态设计：多开一维，设 $dp_{l,r,ex_len}$ 表示对于 L 到 R 的区间内，当前有 $ex_len$ 个同色方块紧挨着。因此有两种新的决策方案，直接消除两个区间之和，或者等待与前面的大块的合并（即从 L 到 R - 1 之间找到一个与 R 同色的大块 K，先消除两块之间的一段，从而可以合并）。\n对应的状态转移方程是：\n$dp_{l,r} = dp_{l,r - 1} + (len_{r} + ex_len) \\times (len_{r} + ex_len)$ $dp_{l,r} = dp_{k + 1,r - 1,0} + dp_{l,k,len_{r} + ex_len}$ 代码：\n常规的递推难以实现，因此通过记忆化搜索（优化时间复杂度）使用递归实现递推。\n「决策一」以及下面的部分对应了两个情况，后者直接合并 K 到 R 中间的所有大块，但是对其他先不做处理（未必立刻删除）。\n树形 DP 对于一棵树，我们任选一个节点作为根，处理每个节点的深度，并递归地处理每个节点的状态。对于具体题目需要按实际情况定义状态。\n例题：\nDP 状态：\n要点：\n对于每个子树：根节点选择了，不能选择任何叶子节点，取子节点不选的最大值；根节点不选择，取子节点选择的最大值； 比较简单地解释了树形的 DP 的基本思想。 代码：\n真题：函数返回值 朴素暴力方案：\n正解思路：\n每一层循环要么是独立的常量，要么是依赖于已经出现的循环； 通过建图来维护循环之间的关系（事实上是森林），例如： 森林中的每一棵树，都可以单独考虑，若一棵子树的根确定了，这颗子树的循环次数就是确定的； 定义 $f_{i,j}$ 是某个边界不确定的循环 $i$ 为根的子树，若未知的边界值是 $j$ 可以产生的最大贡献。 因此最终子树的计算结果是：\n具体而言，就是：\n对于每一个子节点，总循环数应该是相乘的；对于每一个不同的 $i$ 即未知循环数，总循环数应当是相加的，因此可以得到以上的算式。\n转移方法（这部分我没太听懂，有大佬可以解释一下）：\n代码：\n最外层的 if 对应左右节点是否确定的情况，分别求乘法的结果，对应上面的转移方程。转移过程可以通过前缀和优化，达到 O(n^2) 的时间复杂度。\n!p[i] 即一个节点没有父亲节点，是一棵树的根节点，从它开始树形 DP；下面的计算部分与上文对应。\n下课！ 作为一个蒟蒻，只能说，每次考试都是对本蛾子的鞭挞，每次都揭示了我有多弱（\nNOIP 2024 还有两个星期，大家一起加油！感谢本课主讲扬中 yzzxliuchao 和大佬 JoeZ009 的讲解。\n","permalink":"http://localhost:1313/posts/ca87829a43/","summary":"\u003cp\u003e\u003cdel\u003e语速和打字速度的对决（）\u003c/del\u003e\u003c/p\u003e\n\u003ch1 id=\"动态规划经典模型\"\u003e动态规划经典模型\u003c/h1\u003e\n\u003cp\u003e动态规划包括\u003cstrong\u003e线性 DP\u003c/strong\u003e、\u003cstrong\u003e区间 DP\u003c/strong\u003e、\u003cstrong\u003e树形 DP\u003c/strong\u003e、\u003cstrong\u003e数位 DP\u003c/strong\u003e、\u003cstrong\u003e状压 DP\u003c/strong\u003e、\u003cstrong\u003e概率 DP\u003c/strong\u003e、\u003cstrong\u003e期望 DP\u003c/strong\u003e 等。\u003c/p\u003e\n\u003ch2 id=\"用通模型\"\u003e用通模型\u003c/h2\u003e\n\u003ch3 id=\"lis最长上升子序列\"\u003eLIS：最长上升子序列\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e状态表示：集合（所有以 $a_{i}$ 结尾的上升子序列）、属性（最大值）；\u003c/li\u003e\n\u003cli\u003e状态计算：集合划分（「最后一步」）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e实现版本：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e朴素算法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ea[0] = -INF // 哨兵\ndp[0] = 0 // 边界\nfor (int i = 1; i \u0026lt;= n; i++) {\n    for (int j = 1; j \u0026lt; i; j++) {\n        if (a[j] \u0026gt; a[i]) {\n            dp[i] = max(dp[i], dp[j] + 1);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e时间复杂度：$O(n^2)$\u003c/p\u003e\n\u003cp\u003e算法瓶颈：内层枚举有很多无用状态\u003c/p\u003e\n\u003cp\u003e可以使用贪心策略优化：子序列长度相同，枚举末尾的元素 $a_{j}$ 越小，后面更有可能可以连续。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e单调栈优化算法\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e定义数组 $low_{i}$ 维护 LIS 长度为 $i$ 时最小的末尾；$len$ 是当前 LIS 的长度；\u003c/li\u003e\n\u003cli\u003e遍历 $a$ 时，若 $a_{i} \\gt low_{len}$，则更新最大长度，将 $a_{i}$ 添加到末尾；\u003c/li\u003e\n\u003cli\u003e否则，替换 $low$ 中第一个大于或等于 $a_{i}$ 的元素；\u003c/li\u003e\n\u003cli\u003e这样 $low$ 始终为一个单调序列，可以使用二分查找优化；\u003c/li\u003e\n\u003cli\u003e最终 $len$ 是 LIS 的长度（$low$ 不是最终的 LIS 序列）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代码：\u003c/p\u003e","title":"集训笔记：动态规划经典模型 1"}]