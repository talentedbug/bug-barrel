<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>集训笔记：动态规划经典模型 2 | 桶装幺蛾子</title>
<meta name="keywords" content="">
<meta name="description" content="状态是，啊？离离离离——哟哟——
对应洛谷题号：

单调队列优化
线性 DP
例题：PTA-Little Bird（洛谷 P3572）

设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \min{f_{j} &#43; h_{i} \geq h_{j}}$，其中 $i - k \leq j \lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。
上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。

如果队头的元素（最小值）在范围内，我们直接采用；
如果队头的元素不在范围内，我们将其删除；
新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。

代码：

要点：

第 19 行执行了出队操作；
第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。

多重揹包
例题：BAN-Bank Notes（洛谷 P3423）

对题意进行分析，发现：

揹包容量是面值 $k$；
物品体积是每种硬币的面值；
物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。

设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \max{f_{i - 1,j - k \times w_{i}} &#43; k \times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \Sigma c_{i})$。">
<meta name="author" content="智慧的幺蛾子">
<link rel="canonical" href="http://localhost:1313/posts/976003163f/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.75cc0bc8b7e49d1131c6aa01c8e0ffc243167dd94130253a953494bccdeba2cb.css" integrity="sha256-dcwLyLfknRExxqoByOD/wkMWfdlBMCU6lTSUvM3ross=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.jpg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.jpg">
<link rel="mask-icon" href="http://localhost:1313/favicon.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh-cn" href="http://localhost:1313/posts/976003163f/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/976003163f/">
  <meta property="og:site_name" content="桶装幺蛾子">
  <meta property="og:title" content="集训笔记：动态规划经典模型 2">
  <meta property="og:description" content="状态是，啊？离离离离——哟哟——
对应洛谷题号：
单调队列优化 线性 DP 例题：PTA-Little Bird（洛谷 P3572）
设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \min{f_{j} &#43; h_{i} \geq h_{j}}$，其中 $i - k \leq j \lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。
上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。
如果队头的元素（最小值）在范围内，我们直接采用； 如果队头的元素不在范围内，我们将其删除； 新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。 代码：
要点：
第 19 行执行了出队操作； 第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。 多重揹包 例题：BAN-Bank Notes（洛谷 P3423）
对题意进行分析，发现：
揹包容量是面值 $k$； 物品体积是每种硬币的面值； 物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。 设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \max{f_{i - 1,j - k \times w_{i}} &#43; k \times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \Sigma c_{i})$。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-17T00:00:00+08:00">
    <meta property="article:modified_time" content="2024-11-17T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="集训笔记：动态规划经典模型 2">
<meta name="twitter:description" content="状态是，啊？离离离离——哟哟——
对应洛谷题号：

单调队列优化
线性 DP
例题：PTA-Little Bird（洛谷 P3572）

设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \min{f_{j} &#43; h_{i} \geq h_{j}}$，其中 $i - k \leq j \lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。
上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。

如果队头的元素（最小值）在范围内，我们直接采用；
如果队头的元素不在范围内，我们将其删除；
新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。

代码：

要点：

第 19 行执行了出队操作；
第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。

多重揹包
例题：BAN-Bank Notes（洛谷 P3423）

对题意进行分析，发现：

揹包容量是面值 $k$；
物品体积是每种硬币的面值；
物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。

设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \max{f_{i - 1,j - k \times w_{i}} &#43; k \times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \Sigma c_{i})$。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "集训笔记：动态规划经典模型 2",
      "item": "http://localhost:1313/posts/976003163f/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "集训笔记：动态规划经典模型 2",
  "name": "集训笔记：动态规划经典模型 2",
  "description": "状态是，啊？离离离离——哟哟——\n对应洛谷题号：\n单调队列优化 线性 DP 例题：PTA-Little Bird（洛谷 P3572）\n设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \\min{f_{j} + h_{i} \\geq h_{j}}$，其中 $i - k \\leq j \\lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。\n上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。\n如果队头的元素（最小值）在范围内，我们直接采用； 如果队头的元素不在范围内，我们将其删除； 新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。 代码：\n要点：\n第 19 行执行了出队操作； 第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。 多重揹包 例题：BAN-Bank Notes（洛谷 P3423）\n对题意进行分析，发现：\n揹包容量是面值 $k$； 物品体积是每种硬币的面值； 物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。 设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \\max{f_{i - 1,j - k \\times w_{i}} + k \\times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \\Sigma c_{i})$。\n",
  "keywords": [
    
  ],
  "articleBody": "状态是，啊？离离离离——哟哟——\n对应洛谷题号：\n单调队列优化 线性 DP 例题：PTA-Little Bird（洛谷 P3572）\n设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \\min{f_{j} + h_{i} \\geq h_{j}}$，其中 $i - k \\leq j \\lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。\n上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。\n如果队头的元素（最小值）在范围内，我们直接采用； 如果队头的元素不在范围内，我们将其删除； 新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。 代码：\n要点：\n第 19 行执行了出队操作； 第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。 多重揹包 例题：BAN-Bank Notes（洛谷 P3423）\n对题意进行分析，发现：\n揹包容量是面值 $k$； 物品体积是每种硬币的面值； 物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。 设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \\max{f_{i - 1,j - k \\times w_{i}} + k \\times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \\Sigma c_{i})$。\n倍增优化：这个转移方程的时间复杂度瓶颈在于对于每种面值的硬币选取多少个的枚举，因此我们可以将其转换为倍增的 01 揹包，也就是将可以取无限个的物品转化为 $w_{i}, v_{i}$，$2 \\times w_{i}, 2 \\times v_{i}$，$4 \\times w_{i}, 4 \\times v_{i}$ 等等的单个物品。对于具有连续枚举的 DP，倍增优化是一种常见的方法。\n单调队列优化：考虑 $j$ 时的决策，有贡献的可能是 $j - b_{i}$，$j - 2 \\times b[i]$，$j - 3 \\times b_{i}$ 等；$j + b_{i}$ 时，则为 $j$，$j - 1 \\times b_{i}$，$j - 2 \\times b_{i}$。因此可以发现，这里又出现了重复贡献的计算，因此我们依然可以使用单调队列进行优化。\n出现新的元素时，我们在加入队列之前需要将队列中所有的元素都添加 $v_{i}$，时间复杂度较高。但是可以发现，反过来我们可以给新加入的元素对应的值减去 $v_{i}$，然后加入单调队列，时间复杂度大大降低。其中可以体现「正难则反」的思想。\n代码：\n网格图上的 DP 原始题型：\n例题：方格取数（洛谷 P7074）\n本题的特殊之处在于，通常而言网格图问题只能向右或向下，但是本题可以多了向上的方向，因此上下的 DP 状态按照原来的方法就相互依赖，不可行。\n因此这里我们需要改进我们的状态设计。原本的二维 DP 之外，我们额外添加一个表示方向的维度，即 $f_{x,y,d}$，其中 $d \\in {0, 1, 2}$，表示当前格子从下、左或上方到达当前格子的最大结果。因此可以先对第一列填充（只能向下），然后填充剩余部分的右、下方向，最后从下往上填充上方的值。\n对应的转移方程为：\n$f_{i,1,1} = f_{i - 1,1,1} + a_{i,1}$ 例题：Palindromic Paths（洛谷 P3126）\n回文串就要求路径上的字母是对称的，因此我们可以枚举步数和两个对应的座标，这 5 个值中有 1 个可以由其他 4 个推出，因此设计状态为 $f_{x_{1},y_{1},x_{2},y_{2}}$ 或 $f_{step,x_{1},y_{1},x_{2}}$。再次考虑，可以发现其实只需要横座标就可以推出当前位置，并且步数的维度可以用滚动数组压缩，因此规避了数组过大无法开出的问题。\n代码：\n状态压缩 DP 例题：PRZ（洛谷 P5911）\n对于状态维度很多、但是每个维度的信息很少的 DP，可以使用一个二进制数表示当前状态。在本题中，设 $f_{s}$ 中 $s$ 表示当前哪些人已经过桥，例如 10001 表示第一个和第五个人已经过桥，其他人则没有。\n代码：\n其中状态枚举的部分，先枚举每个情况，再对于每个情况从它的子集递推。\n例题：Corn Fields（洛谷 P1879）\n本题在状压 DP 的基础上，需要添加一维，作为公共边的表示。\n数位 DP 例题：数字计数（洛谷 P2602）\n首先对于题意进行转换，由于左右区间的计算比较困难，可以将其转化为 $[1, b]$ 中的计数，减去 $[1, a]$ 之间的计数。\n在数位 DP 中，一般会由高位到低位进行处理。\n设 $f_{i,j}$ 表示 $i$ 位所有以 $j$ 开头的所有数字中，含数字 $7$ 的个数，那么有状态转移方程：\n其中第二个表达式的 $10^{i - 1}$ 表示 $7$ 开头的数字，所有的都应当被计入。例如：\n其中的 $69$ 表示，所有 $97$ 开头的数字都含有 $7$，也就是第三位的贡献。\n数位 DP 的套路包括：\n按位生成 $f$ 表达式； 按位计算存在的情况，并在高位出现情况时添加贡献。 代码：\n用递推实现数位 DP，情况的分类比较多，因此实现比较麻烦。递归的方法，需要解决的情况就少了很多，写法很简单。\n代码：\n中间有一行截断了，后面是 , d。\n其中参数的含义分别为：\ncur：当前是第几位； up：当前位之前的数字是否已经到达最大，也就是说这一位是否可以到 9，还是只能到右边界的对应值； sum：目前已知的情况的总和； zero：是否有前导零； d：总数位。 题目讲解 Bribing Friends（洛谷 P8903） 本题中钱数是揹包的总容量，每个朋友所需的钱和甜筒是每个物品的体积，而受欢迎程度则是物品的价值。\n考虑第 $i$ 个朋友，使用 $x$ 元钱和 $y$ 个甜筒所能获得的最大价值，即 $f_{i,x,y}$。由此很容易推出 DP 状态转移方程，时间复杂度 $O(n^3)$。\n将所有朋友按每元钱所需甜筒排序，对于较大的，应当尽量使用钱；较小的，应当尽量使用甜筒。这样可以从两个方向进行递推，然后得出最终结果。\n代码：\n#include #define int long long #define N 2010 using namespace std; int n, a, b; int f[N][N], g[N][N]; struct node { int p, c, x; } cow[N]; bool cmp(node x, node y) { return x.x \u003c y.x; } signed main() { freopen(\"friends.in\", \"r\", stdin); freopen(\"friends.out\", \"w\", stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin \u003e\u003e n \u003e\u003e a \u003e\u003e b; for (int i = 1; i \u003c= n; i++) cin \u003e\u003e cow[i].p \u003e\u003e cow[i].c \u003e\u003e cow[i].x; sort(cow + 1, cow + n + 1, cmp); for (int i = 1; i \u003c= n; i++) { for (int j = 0; j \u003c= b; j++) f[i][j] = f[i - 1][j]; for (int j = 0; j + cow[i].x * cow[i].c \u003c= b; j++) f[i][j + cow[i].x * cow[i].c] = max(f[i - 1][j + cow[i].x * cow[i].c], f[i - 1][j] + cow[i].p); } for (int i = n; i \u003e= 1; i--) { for (int j = 0; j \u003c= a; j++) g[i][j] = g[i + 1][j]; for (int j = 0; j + cow[i].c \u003c= a; j++) g[i][j + cow[i].c] = max(g[i + 1][j + cow[i].c], g[i + 1][j] + cow[i].p); } int ans = 0; for (int i = 1; i \u003c= n; i++) { ans = max(ans, f[i][b] + g[i + 1][a]); ans = max(ans, f[i - 1][b] + g[i][a]); for (int j = 0; j \u003c= min(a, cow[i].c); j++) { if (cow[i].x * (cow[i].c - j) \u003e b) continue; ans = max(ans, f[i - 1][b - cow[i].x * (cow[i].c - j)] + g[i + 1][a - j] + cow[i].p); } } cout \u003c\u003c ans \u003c\u003c '\\n'; return 0; } Bomboni（洛谷 P9759） 这个部分没有太听懂……\n代码：\n#include #define ll long long #define N 510 #define mod 998244353 using namespace std; int n, K; int a[N][N]; int cnt = 0, fac[N], num[1000010]; int f[N][N][N]; void init(int n, int k) { for (int i = 1; i \u003c= k; i++) { if (k % i == 0) { fac[++cnt] = i; num[i] = cnt; } } fac[++cnt] = k; num[k] = cnt; } ll gcd(ll x, ll y) { return __gcd(x, y); } int main() { freopen(\"candy.in\", \"r\", stdin); freopen(\"candy.out\", \"w\", stdout); ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); cin \u003e\u003e n \u003e\u003e K; memset(a, -1, sizeof a); for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= n; j++) { cin \u003e\u003e a[i][j]; if (a[i][j] != -1) a[i][j] = gcd(a[i][j], K); } init(n, K); f[1][1][num[gcd(a[1][1], K)]] = 1; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { if (a[i][j] == -1) continue; for (int k = 1; k \u003c= cnt; k++) { if (!f[i][j][k]) continue; if (a[i + 1][j] != -1 \u0026\u0026 i \u003c n) { int x = gcd(K, 1ll * fac[k] * a[i + 1][j]); f[i + 1][j][num[x]] = (f[i + 1][j][num[x]] + f[i][j][k]); if (f[i + 1][j][num[x]] \u003e= mod) f[i + 1][j][num[x]] -= mod; } if (a[i][j + 1] != -1 \u0026\u0026 j \u003c n) { int x = gcd(K, 1ll * fac[k] * a[i][j + 1]); f[i][j + 1][num[x]] = (f[i][j + 1][num[x]] + f[i][j][k]); if (f[i][j + 1][num[x]] \u003e= mod) f[i][j + 1][num[x]] -= mod; } } } } cout \u003c\u003c f[n][n][cnt] \u003c\u003c '\\n'; return 0; } Redistributing Gifts（洛谷 P8189） 代码：\n//钟跺帇DP #include using namespace std; namespace IO{ template inline void write(T x) { if(x \u003c 0) putchar('-') , x = - x; if(x == 0) { putchar('0') ; return ; } if(x \u003e 9) write(x / 10); putchar(x % 10 + '0'); //瀛楃杈揿嚭 return ; } template inline void read(T \u0026x) { x = 0; int w = 1; char ch = getchar(); while (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); } while (isdigit(ch)) x = (x \u003c\u003c 1) + (x \u003c\u003c 3) + (ch ^ 48) , ch = getchar(); x *= w; return ; } } #define writeln(x) write(x) , putchar('\\n') #define writesp(x) write(x) , putchar(' ') using namespace IO; #define For(i, j, k) for(int i = (j); i \u003c= (k); ++i) #define Dec(i, j, k) for(int i = (j); i \u003e= (k); --i) #define mp make_pair #define pii pair #define ppi pair #define ckmax(a, b) ((a) = max((a), (b))) #define ckmin(a, b) ((a) = min((a), (b))) #define pb emplace_back //姣攑ush_back蹇偣锛屽姛鑳戒竴镙凤纴搴曞眰瀹炵幇绋嶆湁鍖哄埆 #define inf 0x3f3f3f3f #define fi first #define se second #define N 20 #define ll long long ll dp[1 \u003c\u003c N][N]; ll ans[1 \u003c\u003c N]; char op[N]; int n, x, g[N]; int main() { freopen(\"gifts.in\", \"r\", stdin); freopen(\"gifts.out\", \"w\", stdout); read(n); For(i, 0, n - 1) { //姹俫[i] bool flag = true; For(j, 0, n - 1) { read(x); --x; if (!flag) continue; g[i] ^= (1 \u003c\u003c x);// 瀛桦偍镓€链夊ザ鐗沬鑳芥敹𫔄扮殑绀肩墿x if (x == i) flag = false;\t} } ans[0] = 1; for (int k = 0; k \u003c n; ++k) dp[1\u003c",
  "wordCount" : "1890",
  "inLanguage": "zh-cn",
  "datePublished": "2024-11-17T00:00:00+08:00",
  "dateModified": "2024-11-17T00:00:00+08:00",
  "author":{
    "@type": "Person",
    "name": "智慧的幺蛾子"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/976003163f/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "桶装幺蛾子",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top"><link rel="stylesheet" href="/js/katex/katex.min.css">
<script defer src="/js/katex/katex.min.js"></script>
<script defer src="/js/katex/contrib/auto-render.js" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError : false
            });
        });
</script>
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="🥫 桶装幺蛾子 (Alt + H)">🥫 桶装幺蛾子</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="❓ 关于">
                    <span>❓ 关于</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="📚 档案">
                    <span>📚 档案</span>
                </a>
            </li>
            <li>
                <a href="https://www.travellings.cn/go.html" title="🚆 开往">
                    <span>🚆 开往</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      集训笔记：动态规划经典模型 2
    </h1>
    <div class="post-meta"><span title='2024-11-17 00:00:00 +0800 CST'>November 17, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;智慧的幺蛾子

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97%e4%bc%98%e5%8c%96" aria-label="单调队列优化">单调队列优化</a><ul>
                        
                <li>
                    <a href="#%e7%ba%bf%e6%80%a7-dp" aria-label="线性 DP">线性 DP</a></li>
                <li>
                    <a href="#%e5%a4%9a%e9%87%8d%e6%8f%b9%e5%8c%85" aria-label="多重揹包">多重揹包</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e6%a0%bc%e5%9b%be%e4%b8%8a%e7%9a%84-dp" aria-label="网格图上的 DP">网格图上的 DP</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9-dp" aria-label="状态压缩 DP">状态压缩 DP</a></li>
                <li>
                    <a href="#%e6%95%b0%e4%bd%8d-dp" aria-label="数位 DP">数位 DP</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae%e8%ae%b2%e8%a7%a3" aria-label="题目讲解">题目讲解</a><ul>
                        
                <li>
                    <a href="#bribing-friends%e6%b4%9b%e8%b0%b7-p8903" aria-label="Bribing Friends（洛谷 P8903）">Bribing Friends（洛谷 P8903）</a></li>
                <li>
                    <a href="#bomboni%e6%b4%9b%e8%b0%b7-p9759" aria-label="Bomboni（洛谷 P9759）">Bomboni（洛谷 P9759）</a></li>
                <li>
                    <a href="#redistributing-gifts%e6%b4%9b%e8%b0%b7-p8189" aria-label="Redistributing Gifts（洛谷 P8189）">Redistributing Gifts（洛谷 P8189）</a></li>
                <li>
                    <a href="#piling-papers%e6%b4%9b%e8%b0%b7-p9129" aria-label="Piling Papers（洛谷 P9129）">Piling Papers（洛谷 P9129）</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><del>状态是，啊？离离离离——哟哟——</del></p>
<p>对应洛谷题号：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731832504-image.png"></p>
<h2 id="单调队列优化">单调队列优化<a hidden class="anchor" aria-hidden="true" href="#单调队列优化">#</a></h2>
<h3 id="线性-dp">线性 DP<a hidden class="anchor" aria-hidden="true" href="#线性-dp">#</a></h3>
<p><strong>例题：PTA-Little Bird（洛谷 P3572）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731825461-image.png"></p>
<p>设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \min{f_{j} + h_{i} \geq h_{j}}$，其中 $i - k \leq j \lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。</p>
<p>上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。</p>
<ul>
<li>如果队头的元素（最小值）在范围内，我们直接采用；</li>
<li>如果队头的元素不在范围内，我们将其删除；</li>
<li>新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。</li>
</ul>
<p>代码：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731826445-image-1024x447.png"></p>
<p>要点：</p>
<ul>
<li>第 19 行执行了出队操作；</li>
<li>第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。</li>
</ul>
<h3 id="多重揹包">多重揹包<a hidden class="anchor" aria-hidden="true" href="#多重揹包">#</a></h3>
<p><strong>例题：BAN-Bank Notes（洛谷 P3423）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731826730-image.png"></p>
<p>对题意进行分析，发现：</p>
<ul>
<li>揹包容量是面值 $k$；</li>
<li>物品体积是每种硬币的面值；</li>
<li>物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。</li>
</ul>
<p>设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \max{f_{i - 1,j - k \times w_{i}} + k \times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \Sigma c_{i})$。</p>
<p><strong>倍增优化</strong>：这个转移方程的时间复杂度瓶颈在于对于每种面值的硬币选取多少个的枚举，因此我们可以将其转换为倍增的 01 揹包，也就是将可以取无限个的物品转化为 $w_{i}, v_{i}$，$2 \times w_{i}, 2 \times v_{i}$，$4 \times w_{i}, 4 \times v_{i}$ 等等的单个物品。对于具有连续枚举的 DP，倍增优化是一种常见的方法。</p>
<p><strong>单调队列优化</strong>：考虑 $j$ 时的决策，有贡献的可能是 $j - b_{i}$，$j - 2 \times b[i]$，$j - 3 \times b_{i}$ 等；$j + b_{i}$ 时，则为 $j$，$j - 1 \times b_{i}$，$j - 2 \times b_{i}$。因此可以发现，这里又出现了重复贡献的计算，因此我们依然可以使用单调队列进行优化。</p>
<p>出现新的元素时，我们在加入队列之前需要将队列中所有的元素都添加 $v_{i}$，时间复杂度较高。但是可以发现，反过来我们可以给新加入的元素对应的值减去 $v_{i}$，然后加入单调队列，时间复杂度大大降低。其中可以体现「正难则反」的思想。</p>
<p>代码：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731828177-image-1024x430.png"></p>
<h2 id="网格图上的-dp">网格图上的 DP<a hidden class="anchor" aria-hidden="true" href="#网格图上的-dp">#</a></h2>
<p>原始题型：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731828232-image-1024x489.png"></p>
<p><strong>例题：方格取数（洛谷 P7074）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731828284-image.png"></p>
<p>本题的特殊之处在于，通常而言网格图问题只能向右或向下，但是本题可以多了向上的方向，因此上下的 DP 状态按照原来的方法就相互依赖，不可行。</p>
<p>因此这里我们需要改进我们的状态设计。原本的二维 DP 之外，我们额外添加一个表示方向的维度，即 $f_{x,y,d}$，其中 $d \in {0, 1, 2}$，表示当前格子从下、左或上方到达当前格子的最大结果。因此可以先对第一列填充（只能向下），然后填充剩余部分的右、下方向，最后从下往上填充上方的值。</p>
<p>对应的转移方程为：</p>
<ul>
<li>$f_{i,1,1} = f_{i - 1,1,1} + a_{i,1}$</li>
<li><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731829200-image.png"></li>
</ul>
<p><strong>例题：Palindromic Paths（洛谷 P3126）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731829302-image.png"></p>
<p>回文串就要求路径上的字母是对称的，因此我们可以枚举步数和两个对应的座标，这 5 个值中有 1 个可以由其他 4 个推出，因此设计状态为 $f_{x_{1},y_{1},x_{2},y_{2}}$ 或 $f_{step,x_{1},y_{1},x_{2}}$。再次考虑，可以发现其实只需要横座标就可以推出当前位置，并且步数的维度可以用滚动数组压缩，因此规避了数组过大无法开出的问题。</p>
<p>代码：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731829587-image-1024x285.png"></p>
<h2 id="状态压缩-dp">状态压缩 DP<a hidden class="anchor" aria-hidden="true" href="#状态压缩-dp">#</a></h2>
<p><strong>例题：PRZ（洛谷 P5911）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731829823-image.png"></p>
<p>对于状态维度很多、但是每个维度的信息很少的 DP，可以使用一个二进制数表示当前状态。在本题中，设 $f_{s}$ 中 $s$ 表示当前哪些人已经过桥，例如 <code>10001</code> 表示第一个和第五个人已经过桥，其他人则没有。</p>
<p>代码：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731830594-image.png"></p>
<p>其中状态枚举的部分，先枚举每个情况，再对于每个情况从它的子集递推。</p>
<p><strong>例题：Corn Fields（洛谷 P1879）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731830765-image.png"></p>
<p>本题在状压 DP 的基础上，需要添加一维，作为公共边的表示。</p>
<h2 id="数位-dp">数位 DP<a hidden class="anchor" aria-hidden="true" href="#数位-dp">#</a></h2>
<p><strong>例题：数字计数（洛谷 P2602）</strong></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731830910-image.png"></p>
<p>首先对于题意进行转换，由于左右区间的计算比较困难，可以将其转化为 $[1, b]$ 中的计数，减去 $[1, a]$ 之间的计数。</p>
<p>在数位 DP 中，一般会由高位到低位进行处理。</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831127-image-1024x161.png"></p>
<p>设 $f_{i,j}$ 表示 $i$ 位所有以 $j$ 开头的所有数字中，含数字 $7$ 的个数，那么有状态转移方程：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831187-image-1024x94.png"></p>
<p>其中第二个表达式的 $10^{i - 1}$ 表示 $7$ 开头的数字，所有的都应当被计入。例如：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831288-image-1024x537.png"></p>
<p>其中的 $69$ 表示，所有 $97$ 开头的数字都含有 $7$，也就是第三位的贡献。</p>
<p>数位 DP 的套路包括：</p>
<ul>
<li>按位生成 $f$ 表达式；</li>
<li>按位计算存在的情况，并在高位出现情况时添加贡献。</li>
</ul>
<p>代码：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831521-image.png"></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831723-image.png"></p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831486-image.png"></p>
<p>用递推实现数位 DP，情况的分类比较多，因此实现比较麻烦。递归的方法，需要解决的情况就少了很多，写法很简单。</p>
<p>代码：</p>
<p><img alt="img" loading="lazy" src="../../static/img/976003163f.d/1731831948-image-1024x218.png"></p>
<p>中间有一行截断了，后面是 <code>, d</code>。</p>
<p>其中参数的含义分别为：</p>
<ul>
<li><code>cur</code>：当前是第几位；</li>
<li><code>up</code>：当前位之前的数字是否已经到达最大，也就是说这一位是否可以到 9，还是只能到右边界的对应值；</li>
<li><code>sum</code>：目前已知的情况的总和；</li>
<li><code>zero</code>：是否有前导零；</li>
<li><code>d</code>：总数位。</li>
</ul>
<h2 id="题目讲解">题目讲解<a hidden class="anchor" aria-hidden="true" href="#题目讲解">#</a></h2>
<h3 id="bribing-friends洛谷-p8903">Bribing Friends（洛谷 P8903）<a hidden class="anchor" aria-hidden="true" href="#bribing-friends洛谷-p8903">#</a></h3>
<p>本题中钱数是揹包的总容量，每个朋友所需的钱和甜筒是每个物品的体积，而受欢迎程度则是物品的价值。</p>
<p>考虑第 $i$ 个朋友，使用 $x$ 元钱和 $y$ 个甜筒所能获得的最大价值，即 $f_{i,x,y}$。由此很容易推出 DP 状态转移方程，时间复杂度 $O(n^3)$。</p>
<p>将所有朋友按每元钱所需甜筒排序，对于较大的，应当尽量使用钱；较小的，应当尽量使用甜筒。这样可以从两个方向进行递推，然后得出最终结果。</p>
<p>代码：</p>
<pre tabindex="0"><code>#include &lt;bits/stdc++.h&gt;
#define int long long
#define N 2010
using namespace std;

int n, a, b;
int f[N][N], g[N][N];
struct node { int p, c, x; } cow[N];
bool cmp(node x, node y) { return x.x &lt; y.x; }

signed main() {
    freopen(&#34;friends.in&#34;, &#34;r&#34;, stdin);
    freopen(&#34;friends.out&#34;, &#34;w&#34;, stdout);
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
    for (int i = 1; i &lt;= n; i++) 
        cin &gt;&gt; cow[i].p &gt;&gt; cow[i].c &gt;&gt; cow[i].x;
    sort(cow + 1, cow + n + 1, cmp);
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 0; j &lt;= b; j++) f[i][j] = f[i - 1][j];
        for (int j = 0; j + cow[i].x * cow[i].c &lt;= b; j++) 
            f[i][j + cow[i].x * cow[i].c] = max(f[i - 1][j + cow[i].x * cow[i].c], f[i - 1][j] + cow[i].p); 
    }
    for (int i = n; i &gt;= 1; i--) {
        for (int j = 0; j &lt;= a; j++) g[i][j] = g[i + 1][j];
        for (int j = 0; j + cow[i].c &lt;= a; j++) 
            g[i][j + cow[i].c] = max(g[i + 1][j + cow[i].c], g[i + 1][j] + cow[i].p);
    }
    int ans = 0;
    for (int i = 1; i &lt;= n; i++) {
        ans = max(ans, f[i][b] + g[i + 1][a]);
        ans = max(ans, f[i - 1][b] + g[i][a]);
        for (int j = 0; j &lt;= min(a, cow[i].c); j++) {
            if (cow[i].x * (cow[i].c - j) &gt; b) continue;
            ans = max(ans, f[i - 1][b - cow[i].x * (cow[i].c - j)] + g[i + 1][a - j] + cow[i].p);
        }
    }
    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    return 0;
}
</code></pre><h3 id="bomboni洛谷-p9759">Bomboni（洛谷 P9759）<a hidden class="anchor" aria-hidden="true" href="#bomboni洛谷-p9759">#</a></h3>
<p>这个部分没有太听懂……</p>
<p>代码：</p>
<pre tabindex="0"><code>#include &lt;bits/stdc++.h&gt;
#define ll long long
#define N 510
#define mod 998244353
using namespace std;

int n, K;
int a[N][N];
int cnt = 0, fac[N], num[1000010];
int f[N][N][N];

void init(int n, int k) {
    for (int i = 1; i &lt;= k; i++) {
        if (k % i == 0) {
            fac[++cnt] = i;
            num[i] = cnt;
        }
    }
    fac[++cnt] = k;
    num[k] = cnt;
}

ll gcd(ll x, ll y) { return __gcd(x, y); }

int main() {
    freopen(&#34;candy.in&#34;, &#34;r&#34;, stdin);
    freopen(&#34;candy.out&#34;, &#34;w&#34;, stdout);
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin &gt;&gt; n &gt;&gt; K;
    memset(a, -1, sizeof a);
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++) {
            cin &gt;&gt; a[i][j];
            if (a[i][j] != -1) a[i][j] = gcd(a[i][j], K);
        }
    init(n, K);
    f[1][1][num[gcd(a[1][1], K)]] = 1;
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (a[i][j] == -1) continue;
            for (int k = 1; k &lt;= cnt; k++) {
                if (!f[i][j][k]) continue;
                if (a[i + 1][j] != -1 &amp;&amp; i &lt; n) {
                    int x = gcd(K, 1ll * fac[k] * a[i + 1][j]);
                    f[i + 1][j][num[x]] = (f[i + 1][j][num[x]] + f[i][j][k]);
                    if (f[i + 1][j][num[x]] &gt;= mod) f[i + 1][j][num[x]] -= mod;
                }
                if (a[i][j + 1] != -1 &amp;&amp; j &lt; n) {
                    int x = gcd(K, 1ll * fac[k] * a[i][j + 1]);
                    f[i][j + 1][num[x]] = (f[i][j + 1][num[x]] + f[i][j][k]);
                    if (f[i][j + 1][num[x]] &gt;= mod) f[i][j + 1][num[x]] -= mod;
                }
            }
        }
    }
    cout &lt;&lt; f[n][n][cnt] &lt;&lt; &#39;\n&#39;; 
    return 0;
}
</code></pre><h3 id="redistributing-gifts洛谷-p8189">Redistributing Gifts（洛谷 P8189）<a hidden class="anchor" aria-hidden="true" href="#redistributing-gifts洛谷-p8189">#</a></h3>
<p>代码：</p>
<pre tabindex="0"><code>//钟跺帇DP 
#include &lt;bits/stdc++.h&gt;
using namespace std;
namespace IO{
	template &lt;typename T&gt; inline void write(T x) {
	    if(x &lt; 0)
	        putchar(&#39;-&#39;) , x = - x;
	    if(x == 0) {
	        putchar(&#39;0&#39;) ;
	        return ;
	    }
	    if(x &gt; 9) write(x / 10);
	    putchar(x % 10 + &#39;0&#39;);  //瀛楃杈揿嚭 
	    return ;
	}
	template &lt;typename T&gt; inline void read(T &amp;x) {
	    x = 0; int w = 1; char ch = getchar();
	    while (!isdigit(ch)) { if (ch == &#39;-&#39;) w = -1; ch = getchar(); }
	    while (isdigit(ch)) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48) , ch = getchar();
	    x *= w;
	    return ;
	}
}
#define writeln(x) write(x) , putchar(&#39;\n&#39;)
#define writesp(x) write(x) , putchar(&#39; &#39;)
using namespace IO;
#define For(i, j, k) for(int i = (j); i &lt;= (k); ++i)
#define Dec(i, j, k) for(int i = (j); i &gt;= (k); --i)
#define mp make_pair
#define pii pair&lt;int, int&gt; 
#define ppi pair&lt;pii, int&gt;
#define ckmax(a, b) ((a) = max((a), (b)))
#define ckmin(a, b) ((a) = min((a), (b)))
#define pb emplace_back   //姣攑ush_back蹇偣锛屽姛鑳戒竴镙凤纴搴曞眰瀹炵幇绋嶆湁鍖哄埆 
#define inf 0x3f3f3f3f
#define fi first
#define se second
#define N 20
#define ll long long

ll dp[1 &lt;&lt; N][N];
ll ans[1 &lt;&lt; N];
char op[N];
int n, x, g[N];
int main() {
	freopen(&#34;gifts.in&#34;, &#34;r&#34;, stdin);
    freopen(&#34;gifts.out&#34;, &#34;w&#34;, stdout);
	read(n);
	For(i, 0, n - 1) { //姹俫[i] 
		bool flag = true;
		For(j, 0, n - 1) {
			read(x); --x;
			if (!flag) continue;
			g[i] ^= (1 &lt;&lt; x);// 瀛桦偍镓€链夊ザ鐗沬鑳芥敹𫔄扮殑绀肩墿x
			if (x == i) flag = false;	
		}
	}
	ans[0] = 1;
	for (int k = 0; k &lt; n; ++k) dp[1&lt;&lt;k][k] = 1;
	For(i, 0, n - 1) {
		For(mask, 1 &lt;&lt; i, (1 &lt;&lt; (i + 1)) - 1) {
			For(last, 0, i)  {
				if (!(mask &amp; (1 &lt;&lt; last))) // 杩囨护涓嶅湪褰揿𫮃板嗗悎镄勫ザ鐗?
					continue;
				ll val = dp[mask][last];
				For(k, 0, i - 1)  
					if (!(mask &amp; (1 &lt;&lt; k)) &amp;&amp; (g[last] &amp; (1 &lt;&lt; k))) // 涓嶅湪mask涓笖濂剁坛last鍙互鏀跺埌镄勭ぜ鐗﹌锛岃繘琛岀姸镐佽浆绉?
						dp[mask^(1&lt;&lt;k)][k] += val;
				if (g[last] &amp; (1 &lt;&lt; i)) // 濡傛灉濂剁坛last鍙互鏀跺埌绀肩墿i锛屽垯mask闂幆浜嗐€傚嵆绀肩墿板唌ask鍜屽ザ鐗涢泦mask閮藉缑𫔄颁简鍖归历
					ans[mask] += val;	
			}
			For(k, i + 1, n - 1)  // 璁＄畻瀹宎ns[mask] 旋存柊楂树綅mask镄刣p 
				dp[mask^(1&lt;&lt;k)][k] += ans[mask];
		}
	}
	int q; read(q);
	while (q--) {
		cin &gt;&gt; op;
		int H = 0, G = 0;
		For(i, 0, n - 1)  
			if (op[i] == &#39;H&#39;) H ^= (1 &lt;&lt; i);
			else G ^= (1 &lt;&lt; i);	
		writeln(ans[H] * ans[G]);
	}
	return 0;
}
</code></pre><h3 id="piling-papers洛谷-p9129">Piling Papers（洛谷 P9129）<a hidden class="anchor" aria-hidden="true" href="#piling-papers洛谷-p9129">#</a></h3>
<pre tabindex="0"><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define N 310
#define Q 50010
const int mod = 1e9 + 7;

int n, q;
ll A, B;
int a[N], ans[Q], C[N][N], pow2[N];
int f[N][20][20], g[N][20][20][20];

struct node { int l, r, id; }que[Q];
bool cmp(node a, node b) {
    if (a.l != b.l) return a.l &lt; b.l;
    return a.r &lt; b.r;
}

void solve(ll x, int fh) {
    int p = 1;
    int num[20], cnt = 0; 
    while (x) {
        num[++cnt] = x % 10;
        x /= 10;
    }
    reverse(num + 1, num + cnt + 1);
    for (int lft = 1; lft &lt;= n; lft++) { // 缁熻浠?lft 寮€濮嫔悜鍙抽€夌墝镄勬柟妗堟暟
        memset(f, 0, sizeof(f));
        memset(g, 0, sizeof(g));
        for (int rgt = lft; rgt &lt;= n; rgt++) {
            for (int len = 1; len &lt;= cnt; len++) {
                for (int i = 1; i + len - 1 &lt;= cnt; i++) {
                    int j = i + len - 1;//f[rgt][i][j]琛ㄧず鍙栧埌a[rgt](鍙笉鍙栵级锛屾嫾鎴?x[i]钬斺€撺[j]镄勬柟妗堟暟锛堣繖阅寈瑙嗕负涓€涓瓧绗︽暟缁勶级銆?
                    (f[rgt][i][j] += f[rgt - 1][i][j]) %= mod;//杩𪲔槸涓€涓尯闂村姩镐佽𫔄掞纴鍖洪棿[i,j]鍙敱[i+1,j]鍜𪧀i,j-1]杞Щ钥屾潵銆?
                    if (len == 1) { // i == j
                        if (a[rgt] == num[i])  (f[rgt][i][j] += 2) %= mod;// 1 or 2 method 
                    }
                    else { 
                        if (a[rgt] == num[i]) (f[rgt][i][j] += f[rgt - 1][i + 1][j]) %= mod; // 锷犲𫮃闱?( 1 method )
                        if (a[rgt] == num[j]) (f[rgt][i][j] += f[rgt - 1][i][j - 1]) %= mod; // 锷犲悗闱?( 2 method ) 
                    }
                }
            }
        }
        for (int rgt = lft; rgt &lt;= n; rgt++) {
            for (int len = 1; len &lt;= cnt; len++) {
                for (int i = 1; i + len - 1 &lt;= cnt; i++) {
                    int j = i + len - 1;// 褰撴嫾鍑虹k浣嶅皬浜巟[k]镄勬暟锛屼笖绗琸浣崭箣鍓崭笌x涓€镊寸殑鏁版椂锛宬涔嫔悗镄勬暟鍙互浠诲彇銆?
                    for (int k = i; k &lt;= j; k++) { //浠[rgt][i][k][j]琛ㄧず鍙栧埌a[rgt]锛屾嫾鍑簒[i]𫔄皒[k-1]锛岀k浣嶅皬浜巟[k]涓旗k + 1𫔄癹浣崭换镒忓彇镄勬柟妗堟暟銆?
                        (g[rgt][i][k][j] += g[rgt - 1][i][k][j]) %= mod;
                        if (i == k) {// 锷犲𫮃闱?(1 method, a[rgt]鏀惧湪i)
                            if (a[rgt] &lt; num[i]) { // 鍖洪棿[k+1,j]镄勬暟浠巃镄刐lft, rgt-1]鍖洪棿阅屼换镒忛€夋嫨涓€涓粍钖?
                                int tmp = (ll)C[rgt - lft][j - k] * pow2[j - k] % mod;
                                (g[rgt][i][k][j] += tmp) %= mod;
                            }
                        }
                        else {
                            if (a[rgt] == num[i]) 
                                (g[rgt][i][k][j] += g[rgt - 1][i + 1][k][j]) %= mod;
                        }
                        if (k == j) {// 锷犲悗闱?2 method, a[rgt]鏀惧湪j
                            if (a[rgt] &lt; num[j]) {// all-same way + [a_t as small]
                                int tmp = i == j ? 1 : f[rgt - 1][i][j - 1];
                                (g[rgt][i][k][j] += tmp) %= mod;
                            }
                        }
                        else { 
                            (g[rgt][i][k][j] += g[rgt - 1][i][k][j - 1]) %= mod;
                        }
                    }
                }
            }
        }  
        while (que[p].l == lft &amp;&amp; p &lt;= q) { // 灏嗘墍链夎闂绾匡纴镌夌収宸︾镣规帓搴忋€傚悓涓€宸︾镣圭殑璇㈤梾鍙渶锅氩悓涓€娆?dp銆?
            int i = que[p].r - que[p].l + 1;
            for (int j = 0; j &lt;= cnt - 1; j++) {// 鐭殑
                ll tmp = fh * C[i][j] % mod * pow2[j] % mod;
                tmp = (tmp + mod) % mod;
                (ans[que[p].id] += tmp) %= mod;
            }
            for (int k = 1; k &lt;= cnt; k++) { // 绛夐暱镄勶纴灏忎簬x镄?
                ll tmp = fh * g[que[p].r][1][k][cnt] % mod;
                tmp = (tmp + mod) % mod;
                (ans[que[p].id] += tmp) %= mod;
            }
            ll tmp = fh * f[que[p].r][1][cnt] % mod; // 绛夐暱镄勶纴绛変簬x镄?
            tmp = (tmp + mod) % mod;
            (ans[que[p].id] += tmp) %= mod;
            ++p;
        }
    }
}

signed main() {
    freopen(&#34;sequence.in&#34;, &#34;r&#34;, stdin);
    freopen(&#34;sequence.out&#34;, &#34;w&#34;, stdout);
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin &gt;&gt; n &gt;&gt; A &gt;&gt; B;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    cin &gt;&gt; q;
    for (int i = 1; i &lt;= q; i++) {
        cin &gt;&gt; que[i].l &gt;&gt; que[i].r;
        que[i].id = i;
    }
    sort(que + 1, que + q + 1, cmp);
    pow2[0] = 1;
    for (int i = 1; i &lt;= n; i++) pow2[i] = pow2[i - 1] * 2 % mod;
    for (int i = 0; i &lt;= n; i++) {
        for (int j = 0; j &lt;= i; j++) {
            if (j == 0 || j == i || i == 0) {
                C[i][j] = 1;
                continue;
            }
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
        }
    }
    solve(B, 1);
    if (A &gt; 1) solve(A - 1, -1);
    for (int i = 1; i &lt;= q; i++) cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;
    return 0;
}
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/4f6adc86c6/">
    <span class="title">« </span>
    <br>
    <span>搭建自己的代理服务器</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/ca87829a43/">
    <span class="title"> »</span>
    <br>
    <span>集训笔记：动态规划经典模型 1</span>
  </a>
</nav>
<img src="/static/img/signature.png">


  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://creativecommons.org/public-domain/cc0/">CC0</a> 授权，允许您自由使用。</span>
    <br>
    <span><a href="https://icp.gov.moe/?keyword=20252048" target="_blank">萌ICP备20252048号</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
