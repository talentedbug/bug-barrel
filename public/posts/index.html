<!DOCTYPE html>
<html lang="zh-cn" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | 桶装幺蛾子</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - 桶装幺蛾子">
<meta name="author" content="智慧的幺蛾子">
<link rel="canonical" href="http://localhost:1313/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.75cc0bc8b7e49d1131c6aa01c8e0ffc243167dd94130253a953494bccdeba2cb.css" integrity="sha256-dcwLyLfknRExxqoByOD/wkMWfdlBMCU6lTSUvM3ross=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon.jpg">
<link rel="apple-touch-icon" href="http://localhost:1313/favicon.jpg">
<link rel="mask-icon" href="http://localhost:1313/favicon.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/posts/index.xml">
<link rel="alternate" hreflang="zh-cn" href="http://localhost:1313/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/">
  <meta property="og:site_name" content="桶装幺蛾子">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="智慧的幺蛾子的奇葩博客">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="智慧的幺蛾子的奇葩博客">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top"><link rel="stylesheet" href="/js/katex/katex.min.css">
<script defer src="/js/katex/katex.min.js"></script>
<script defer src="/js/katex/contrib/auto-render.js" onload="renderMathInElement(document.body);"></script>
<script>
document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ],
                throwOnError : false
            });
        });
</script>
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="🥫 桶装幺蛾子 (Alt + H)">🥫 桶装幺蛾子</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="❓ 关于">
                    <span>❓ 关于</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="📚 档案">
                    <span>📚 档案</span>
                </a>
            </li>
            <li>
                <a href="https://www.travellings.cn/go.html" title="🚆 开往">
                    <span>🚆 开往</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="http://localhost:1313/">Home</a></div>
  <h1>
    Posts
    <a href="/posts/index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">使用单板机为旧打印机添加局域网共享
    </h2>
  </header>
  <div class="entry-content">
    <p>本蛾子家里有一部香橙派 Zero 3 一直在吃灰。
最近期末复习，大量打印试卷，只有蛾爸的台式机连着一台 HP LaserJet 打印机，不得不断断续续打扰他玩游戏去打印。蛾爸说，唉，要么买一台带 Wi-Fi 打印功能的新打印机吧！一看价格，动辄 2000 多。
于是本蛾子在网上搜了搜，发现 HP 对 Linux 的驱动支持很好。在提出将打印机挪到本蛾子的房间的要求并被拒绝之后，猛地想起来这部吃灰的香橙派，插电看看，更新一下包，还能用。遂记录一下操作方法供您参考 😁
🛜 Wi-Fi 上网 之前这部单板机一直都是直接插网线上网的，但由于房间里唯一的网线接口被蛾爸的台式机占据，不得不使用无线网络。
Armbian 竟然不自带 network-manager，先自己装一个。
sudo apt update &amp;&amp; sudo apt upgrade sudo apt install network-manager sudo systemctl enable --now NetworkManager # 大小写敏感 然后用 nmtui 连接一下无线网。
sudo nmtui 然后选择你的 Wi-Fi 连接即可。
使用 ip addr 验证一下：
可以发现已经 DHCP 了一个 Wi-Fi IP 段的 IP。
本蛾子家的路由器似乎不按照递增的顺序添加 IP，因此还需要设置一下静态 IP，以防失联：
sudo nmtui 重启一下 network-manager 看看：
...</p>
  </div>
  <footer class="entry-footer"><span title='2025-01-10 22:10:47 +0800 CST'>January 10, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 使用单板机为旧打印机添加局域网共享" href="http://localhost:1313/posts/fdf8cb41df/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Clash 配置文件简述
    </h2>
  </header>
  <div class="entry-content">
    <p>最近本蛾子发现之前搭建的代理，访问部分国内网站的时候不光速度很慢，而且有时候会报 PR_END_OF_FILE_ERROR（无法确定内容完整性，就是远程，特别是 CSDN，全站都无法访问。
😮‍💨 唉：后来发现其实是服务端 WARP 的问题，跟 v2rayA 一毛钱关系都没有。
本蛾子现在使用的 v2rayA 虽然安装起来很方便（Arch Linux CN 有打包），但是对于规则的支持并不算好，并且开启、关闭、切换节点的速度也不尽人意。在网上搜索一通，似乎眼下最完善的内核是 Clash 系列的后继者 Mihomo，因此本蛾子就用它来学习一下如何书写 Clash 配置文件。
💻 客户端选择 Clash 系的客户端在 AUR 上基本全部都有打包。根据本蛾子的测试，似乎还在开发且可用性比较高的，只有 Clash Verge Rev 和 FlClash，而后者的 UI 设计本蛾子看着非常舒服，因此本文就以 FlClash 作为测试客户端。
首先对 FlClash 的软件设置进行调整。虽然诸多 Clash 系客户端使用同一个内核，但是其 UI 设计却千差万别。FlClash 的界面大概是这样的。
在 Tools 栏目中，主要是软件本身和覆写配置文件的选项，前者是主题、日志、自动启动等本地定义的选项，不出现在配置文件中，因此我们首先来完成对其的设置。覆写配置文件的设置主要针对使用远程配置文件（例如机场）的用户，方便修改配置文件。
选项大部分您都应该能理解，说几个比较迷惑的：
Logcat：就是日志功能，记录您使用代理访问的网站，关闭之后不会记录，但是似乎需要手动删除之前的记录（位于您的主目录下）。 Auto lost connections：在切换节点之后切断当前存在的连接，开启之后换区域会更加彻底，但是您的下载会被终端。 Only statistics proxy：只对通过的流量进行记录，这时候 FlClash 就变成了一个网络监测工具。 当然这个栏目还有其他功能，比如设置语言、主题、备份之类的，就请您自己探索了。
⚙️ 配置文件 这当然就是本文的重点了！通过 Clash 配置文件，您可以方便地修改 DNS、分流、（基础）去广告等，至于节点链接，倒成了配置文件中不太重要的一部分了。下面本蛾子参考了一些链接和项目，为行文流畅就不一一列出角标了，一并在文末引用。
您书写的配置文件应当保存在任意名称的 .yaml 文件中，在 FlClash 中这样引用：
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-12-29 09:39:37 +0800 CST'>December 29, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to Clash 配置文件简述" href="http://localhost:1313/posts/eeace13dad/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">使用 SSH 公钥登录服务器并禁用密码
    </h2>
  </header>
  <div class="entry-content">
    <p>😠 太长不读：生成 SSH密钥，上传到服务器，然后禁用密码登录。（好像是废话）
0x01 🔒 生成 SSH 密钥 以下使用 $ 符号代表本机执行，&gt; 符号代表服务器执行。
$ ssh-keygen # 旧版本需要添加 `-t ed25519` 参数 Generating public/private ed25519 key pair. Enter file in which to save the key (/home/YOUR_USER_NAME/.ssh/id_ed25519): # 可以自定义位置，也可以直接回车 Enter passphrase for &#34;example&#34; (empty for no passphrase): # 输入密码（不显示），不建议空密码 Enter same passphrase again: # 再输一遍 Your identification has been saved in id_ed25519 Your public key has been saved in id_ed25519.pub # 带有 .pub 的是公钥 The key fingerprint is: SHA256:SOME_STRANGE_STRING YOUR_USER_NAME@YOUR_HOST_NAME # 你的公钥指纹 The key&#39;s randomart image is: # 根据公钥生成的随机图像 &#43;--[ED25519 256]--&#43; | SOME | | STRANGE | | IMAGE | | | | | | | | | | | | | &#43;----[SHA256]-----&#43; $ ls .ssh id_ed25519 id_ed25519 # 可能还有其他文件 0x02 ⬆️ 上传到服务器 首先确保你当前可以使用密码登录一个非 root 的账号。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-12-15 16:50:12 +0800 CST'>December 15, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 使用 SSH 公钥登录服务器并禁用密码" href="http://localhost:1313/posts/5baaf9322f/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">DP 优化的常见方法
    </h2>
  </header>
  <div class="entry-content">
    <p>对于朴素 DP，有几种常见的优化方法，本文主要介绍单调队列和斜率优化。
单调队列优化 DP 例题：P1886 滑动窗口 /【模板】单调队列
单调队列是一种特殊的双端队列，从字面上理解，就是具有某种单调性的队列，例如递增或者递减。一般来说单调队列可以用于维护最值，解决滑动窗口类的问题，时间复杂度是 $O(n)$。
单调队列的维护可以通过不断添加新元素，并不定时访问或者删除旧的元素。
以上述例题为例，我们可以如何求出单调队列的长度呢？
最简单的方法：枚举滑动窗口的左端点和窗口长度，再求出区间内的最大、最小值，时间复杂度 $O(n^{2}k)$； RMQ（区间最值）类算法：同样枚举区间，通过预处理优化求区间最值的时间复杂度，最终为 $O(n^2 \log_{2} n)$。 我们可以发现，这两个算法都存在一个问题：一个序列 $a_{i},a_{i&#43;1} \cdots a_{j}$ 和同样长度的 $a_{i&#43;1},a_{i&#43;2} \cdots a_{j&#43;1}$，其中有长达 $j-i-1$ 的区间是重复的。
这里，单调队列优化就有用了。我们用一个例子来说明单调队列如何工作：
1 4 5 -1 0 3 1 假设当前的区间长度 $k=4$，我们只求最小值，那么：
队列初始为空，1 入队； 由于 1 入队时间早于 4，有可能在 1 出队后，4 成为新的最小值，因此 4 进队； 同上原因，5 入队； 这时候我们遇到了 -1，它小于队尾的 5，并且 -1 的入队时间晚于 5。那么如果 -1 入队，5 出队早于 -1，并且只要 -1 在队中，最小值都不可能是 5，因此 5 出队； 同上原因，4 出队； 由于上面主要原因已经讲完了，所以下面就简单地带过：0 时间晚，入队； 3 时间晚，入队； 1 时间晚，且值小，3 出队，1 入队。 通过上述过程，我们可以发现，无论到哪一位，我们都维护了一个单调递减的队列。由于本题还要求区间长度，我们还应当记录队列中元素的位置，如果超出范围就同样出队。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-27 00:00:00 +0800 CST'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to DP 优化的常见方法" href="http://localhost:1313/posts/1ec9f00dde/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">图的连通性问题
    </h2>
  </header>
  <div class="entry-content">
    <p>图的连通性问题主要包括：
割边和割点； 强连通分量和缩点； 边双连通分量和点双连通分量。 求解这些问题，效率最高、思路最清晰的算法是 Tarjan 算法，由罗伯特·恩卓·塔扬发明。塔扬研究了并查集、图论等许多领域，因此有很多以他名字命名的算法，这里是指关于图的连通性问题的算法。
割边和割点 不大严谨、完全不形式化的定义：
割边：如果删除图上的某条边，图就不再连通，那么这条边就是图的割边。 割点：如果删除图上的某个点以及与其相连的所有边，图就不再连通，那么这个点就是图的割点。 暴力求解这个问题，可以枚举删除某一条边或者某一个点，然后通过 DFS 判断连通性，平均时间复杂度是 $O(n^2)$。
首先需要了解的是 DFS 树。DFS 树是从图上任意一点开始 DFS，由 DFS 顺序所构成的一棵树，开始点对于答案没有影响。在树上出现的边称为树边，否则称为非树边。
在割边和割点问题中，一般只研究无向图。非树边在 DFS 树中以返祖边的形式出现，其含义就是字面含义。
割点 割点可以分为两种情况：
根节点在 DFS 树中有多余一个子节点，那么它就是割点； 对于一个非根节点，它的子树中至少有一棵，不存在一条返祖边可以回到它的祖先节点。 第一种请款很简单；第二种情况，如果子树上存在到它的祖先的返祖边，当它被删除之后，这棵子树仍然可以通过返祖边到达原本节点的祖先。
求割点的方法：
$dfn_{i}$ 表示节点 $i$ 的时间戳，或者也可以说是节点在 DFS 树中的深度，通过其大小比较可以判断祖先与子孙的关系； $low_{i}$ 表示节点 $i$ 不经过其父节点能到达的 $dfn$ 最小的祖先。（这个概念大部分博客都没有讲清楚，本蛾子搜遍互联网终于找到了对其的明确定义，特此感谢：Tarjan 算法求解无向图的割点与割边，可惜的是这篇博客下面的代码是错误的。） 对于一个节点 $v$ 及其祖先 $u$，如果回溯时发现 $low_{v} \geq dfn_{u}$，也就是说 $v$ 回不到 $u$ 的祖先（取等，因为此时与 $3$ 相连的所有边都被删除，所以不可能到达）。
还需要注意，当一个节点的子节点已经被访问，更新应当使用 dfn[e[i].t] 而非 low[e[i].t]。若使用后者，会导致割点的子节点使用割点能访问的祖先节点更新，那这就白跑了。
代码实现（可以根据注释理解）：
#include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int n, m; struct edge { int f, t; int n; } e[220000]; int ec; int pre[22000]; int dfn[22000], low[22000]; set&lt;int&gt; ce; bool vis[22000]; int ro; void add(int f, int t) { e[&#43;&#43;ec].f = f; e[ec].t = t; e[ec].n = pre[f]; pre[f] = ec; } int dfs_cnt; void dfs(int c, int f) { // `c`: current node, `f`: father node vis[c] = true; dfn[c] = low[c] = &#43;&#43;dfs_cnt; // Update the current timestamp int sc = 0; // The number of children, in case this is root for (int i = pre[c]; i; i = e[i].n) { if (!vis[e[i].t]) { // Not visited, indicating it&#39;s reached for the first // time and thus cannot reach an ancestor sc&#43;&#43;; dfs(e[i].t, c); // Go to children and thus recall low[c] = min(low[c], low[e[i].t]); // Update ancestors that `c` // reach by its subtree if (c != ro &amp;&amp; low[e[i].t] &gt;= dfn[c]) { // Indicating that its subtree cannot reach // `c`&#39;s ancestors // SO NODE `C` IS AN CUT NODE ce.insert(c); } if (c == ro &amp;&amp; sc &gt;= 2) { ce.insert(c); // If `c` is root and has more than one subtree, // obviously it&#39;s a cut node } } else { if (e[i].t != f) { // Visited before, so `c` could reach what // `e[i].t` could reach low[c] = min(low[c], dfn[e[i].t]); } } } } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i&#43;&#43;) { int f, t; cin &gt;&gt; f &gt;&gt; t; add(f, t), add(t, f); } for (int i = 1; i &lt;= n; i&#43;&#43;) { if (!vis[i]) { ro = i; dfs(i, 0); } } cout &lt;&lt; ce.size() &lt;&lt; endl; for (auto k: ce) { cout &lt;&lt; k &lt;&lt; &#34; &#34;; } cout &lt;&lt; endl; return 0; } 注意去重，因为如果割点不止一棵子树不能返祖，那么就会重复添加。（硬控本蛾子半小时。）
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-25 00:00:00 +0800 CST'>November 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 图的连通性问题" href="http://localhost:1313/posts/b1aaece446/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">集训笔记：树结构
    </h2>
  </header>
  <div class="entry-content">
    <p>我还是希望大家啊，多用歪克特，啊，尤其是我们现在有了，啊，凹凸，简洁而且方便。
本文中若无特殊说明，认为树的根节点的深度为 1。
树的直径 树上任意两个点之间的最长距离称为树的直径。
求树的直径，可以从任何一个节点 $x$ 开始 DFS，能到达的最远节点 $y$ 一定是直径的一端。再从 $y$ 开始 DFS，能到达的最远节点 $z$ 就是直径的另一端，$x$ 与 $y$ 的距离即为直径。
证明：
代码：
树的直径也可以使用树形 DP 计算，若设 1 为树根，那么设某个点向下能达到的最大和次大值是 $d1$ 和 $d2$，那么 $d1 &#43; d2$ 最大时就是树的直径。
代码：
上述写法也可以压缩为一个数组，定义 $dp_{u}$ 是以 $u$ 为树根的子树中，从 $u$ 出发的最长路径，那么有转移方程 $dp_{u}=\max{dp_{u}, dp_{v}}$，其中 $v$ 是 $u$ 的子节点。对于求直径的过程，我们可以在转移时打擂求最大值。
树的中心 选定一个点作为树的根节点，使得叶节点到根节点的最大距离最小，这个点称为树的中心。
树的中心一定在直径上，且趋于两个端点的中点，因此可以在找出直径的同时，求出其到每个节点的距离。
代码：
#include&lt;cstdio&gt; #include&lt;iostream&gt; #define re register #define maxn 100010 using namespace std; inline int read() { int x=0,f=1; char ch=getchar(); while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();} while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10&#43;ch-&#39;0&#39;;ch=getchar();} return x*f; } struct Edge{ int v,w,nxt; }e[maxn&lt;&lt;2]; int x,y,z; int pos1,pos2,d[maxn],d1[maxn],d2[maxn]; int n,tmp1,tmp2,tmp3,ans,pos,cnt,head[maxn]; inline void add(int u,int v,int w) { e[&#43;&#43;cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs1(int u,int fa,int dis) { for(int i=head[u];i;i=e[i].nxt) { int ev=e[i].v; if(ev==fa) continue; dfs1(ev,u,dis&#43;e[i].w); } d[u]=dis; if(dis&gt;tmp2) tmp2=dis,tmp1=u; } int main() { n=read(); for(re int i=1;i&lt;n;&#43;&#43;i) { x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); } dfs1(1,0,0); pos1=tmp1; tmp2=0,tmp1=0; dfs1(pos1,0,0); pos2=tmp1; tmp2=0,tmp1=0; //找到直径了 for(re int i=1;i&lt;=n;&#43;&#43;i) d1[i]=d[i]; dfs1(pos2,0,0); for(re int i=1;i&lt;=n;&#43;&#43;i) d2[i]=d[i]; ans=0x3f3f3f3f; for(re int i=1;i&lt;=n;&#43;&#43;i) { if(ans&gt;max(d1[i],d2[i])) ans=max(d1[i],d2[i]),pos=i; } printf(&#34;%d %d&#34;,pos,ans); return 0; } 树的重心 选择树中的一个节点并删除，使得分成的所有子树的最大节点数最小，这个点称为树的重心。树的重心若不唯一，则一定有两个。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-24 00:00:00 +0800 CST'>November 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 集训笔记：树结构" href="http://localhost:1313/posts/5dad7361ce/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">集训笔记：图论算法二
    </h2>
  </header>
  <div class="entry-content">
    <p>最小生成树 Prim 算法 算法原理：从一个点出发维护一个最小生成树上的点的集合，每次选择一条集合内某点和集合外某点的最小边权加入，然后将集合外的这个点加入集合。若暴力查找最小边权，时间复杂度为 $O(n^2)$。
代码示例：
Prim 算法的思路和 Dijkstra 最短路算法非常相似，优化也基本相同。对于暴力做法中寻找最小值的步骤，可以使用优先队列优化到 $O(n&#43;m\log{m})$。
Kruskal 算法 将边权从小到大排序，一一尝试向最小生成树添加边，若边的端点不在同一个连通块内，则添加，时间复杂度为 $O(e\log{e})$。
代码示例：
算法的正确性显然，对于放弃的边，其权值大于前面所有的边，因此产生环时应当首先放弃。时间复杂度瓶颈在排序操作上。
例题：HDU7226
序列中所有数字之间的边构成一个完全图，但是不可能将这个完全图实际建出来，空间和时间上都无法接受。
如果我们直接按顺序连接所有点，那么每条边的边权都小于 n。因此，最小生成树中所有边权都应当小于 n，也就是 $|i - j| * |p_{i}-p_{j}|$ 小于 $n$，两个乘数有一个小于 $\sqrt{n}$。我们可以选择枚举 $i$ 在 1 到 n，$j$ 在 $i$ 到 $i&#43;\sqrt{n}$，总时间复杂度为 $O(n\sqrt{n})$。
然后对这些边计算最小生成树，因此叠加后的时间复杂度为 $O(n\sqrt{n}\log{n}\sqrt{n})$。若时间复杂度较为紧张，还可以使用桶排进行 Kruskal 中的排序过程，将 $\log{n}$ 压缩。
例题：洛谷 P2245 星际导航
题意是寻找一条路径上边权的最大值。两个点之间可能有很多边，但是边权较大的边不会产生贡献，因此我们先对图运行 Kruskal 求最小生成树，这样两个点之间有唯一路径且一定最小（否则更短的边会出现在生成树中）。这样就可以通过 LCA 直接求出总边权。
另一种思路是使用 Kruskal 重构树，适用于最小生成树最大边权问题。
Kruskal 重构树的求解过程：
将边权从小到大排序； 每次选择边权最小的一条边，若其连接的两个点已经进入集合，则跳过；否则，将这两个点的祖先都连接到一个虚点上，点权为这条边的边权。 在这棵树上，两个节点之间的最大权值可以直接通过 LCA 求得，不需要单独维护。某些题目只能通过重构树的方式实现。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-23 00:00:00 +0800 CST'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 集训笔记：图论算法二" href="http://localhost:1313/posts/307ee35eff/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">集训笔记：图论算法一
    </h2>
  </header>
  <div class="entry-content">
    <p>拓扑排序 拓扑排序是图论中的一种算法，适用于 DAG 中，可以用于求拓扑序列。拓扑排序的结果是一个线性序列，满足每个顶点在序列中只出现一次，且若存在 A 到 B 的路径，则 A 出现在 B 之前。拓扑序列通常不唯一。
基于 BFS（入度）的拓扑排序比较容易实现。
伪代码：
代码示例：
拓扑排序可以判断图中是否有环。如果最终所有顶点的入度都减少为 0，队列清空，则不存在环；否则则有环。
代码示例：
例题：机器人擂台赛（CF645D）
分析：
没有自相矛盾：没有环； 没有比赛包含相同机器人：没有重边； 属于「依赖关系」，优先考虑拓扑排序； 判断是否有唯一的拓扑序列，可以在拓扑排序过程中判断是否同时有多于一个入度为 0 的顶点（也就是每次只有一个选择）。 直接在拓扑排序的模板上进行修改即可。
对于比赛的处理，可以有以下几种方法：
每次加一条边，并进行拓扑排序，当序列唯一时输出（注意清空）； 答案具有单调性，可以二分答案，对最大答案进行特判是否无解； 拓扑排序相邻两个顶点之间的关系必须给出，因此可以在拓扑排序中记录每一场必要的比赛的编号，然后依次扫描所有比赛，在所有比赛都出现的时候就可以输出了。 最短路算法 BFS 当一张图上不含边权，或者边权都相等，可以直接使用 BFS 计算最短路，算法正确且复杂度不高。
例题：Nearest Opposite Parity（CF1272E）
最简单的方法：从每一个数开始，寻找最近的异性数字； 优化：从所有奇数出发，统计能到达所有偶数的最短路，对于偶数也这样求出最短路； 反向建图，也就是从 i &#43; a[i] 和 i - a[i] 连一条到 i 的边，也就是从终点出发，寻找到每一个起点的最短路； 代码：
两个 BFS 基本一致，以到达奇数的 BFS 为例：
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-22 00:00:00 +0800 CST'>November 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 集训笔记：图论算法一" href="http://localhost:1313/posts/38853453c4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">CF1272E Nearest Opposite Parity 题解
    </h2>
  </header>
  <div class="entry-content">
    <p>洛谷题解
题意简述 原题链接（CF）
给出长度为 $n$ 的序列 $a$，允许从某个数 $a_{i}$ 向前或向后跳跃 $a_{i}$ 个数（跳跃后的位置在序列内），要求求出从奇偶性不同的另一个数到每个数的最短距离。
分析 首先很容易想到一个符合直觉的方案：对于每一个数，我们以它为源点计算最短路（使用图论算法；由于边权都是 1，还可以用 BFS），然后找到距离最近、奇偶性相反的数，输出距离。
但是这个方法的问题很明显：枚举每个数字，再加上 BFS，至少也是 $O(n^2)$ 的时间复杂度，如果用图论算法还得更高。
我们希望能在一次 BFS 之后就得出每个点的最短路，这样时间复杂度就来到了 $O(n)$。
这里的难点就是反向建边，即从 $i \pm a_{i}$ 建立到 $i$ 的边。其他大佬的题解自然地提到了反向建边，但是对我这样的蒟蒻，为什么反向建边更重要。这出于两个原因：
输出要求是到达每个数的最短路径，如果存储的也是到达的路径长度显然更方便； BFS 中，如果我们反向地遍历，可以避免正向遍历所导致的反复遍历：我们将从结果推开头，这样不需要对每个源点一一遍历。 有了这个概念，我们就可以将所有数字分为奇数和偶数。定义 $ev_{i}$ 是从偶数到 $i$ 的最短路径，$od_{i}$ 是从奇数到 $i$ 的最短路径，那么显然奇数 $a_{i}$ 的 $od_{i}$、偶数 $a_{j}$ 的 $ev_{j}$ 均为 0。
我们将偶数提前入队，从它们开始跑一遍 BFS，去求出从偶数到达每一个数的最短路径；对于奇数也是同样的操作。
那么现在就很清楚了，我们已经有了从奇数或者偶数到达一个点的最短路径（BFS 路径就是最短路），输出直接选择与 $a_{i}$ 相反的那个路径长度即可。
代码实现 变量名对应表：
n：原题中 N； a：原题中 a; ev，od：见上文； edge：边： f，t：边的首、尾； n：下一条边（用于遍历）； ec：边的计数； pre：以某个点为首的第一条边（用于遍历）； vis：访问记录（用于 BFS），注意清零； ev_q，od_q：用于偶数、奇数 BFS 的队列。 #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int n; int a[220000]; int ev[220000], od[220000]; // 链式前向星，其实邻接表也行 struct edge { int f, t; int n; } e[420000]; int ec; int pre[220000]; bool vis[220000]; void add(int f, int t) { e[&#43;&#43;ec].f = f; e[ec].t = t; e[ec].n = pre[f]; pre[f] = ec; } int main() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i&#43;&#43;) { cin &gt;&gt; a[i]; if (i - a[i] &gt;= 1) { add(i - a[i], i); // 反向建边 } if (i &#43; a[i] &lt;= n) { add(i &#43; a[i], i); } } memset(vis, 0, sizeof(vis)); // 清空 queue&lt;int&gt; ev_q; for (int i = 1; i &lt;= n; i&#43;&#43;) { if (a[i] % 2 == 0) { ev[i] = 0; ev_q.push(i); vis[i] = true; // 初始化本来就是偶数的数，距离为 0，入队 } else { ev[i] = INT_MAX; // 否则初始化为无穷大 } } while (!ev_q.empty()) { // BFS，基本就是模板 int id = ev_q.front(); ev_q.pop(); vis[id] = false; for (int i = pre[id]; i; i = e[i].n) { if (ev[e[i].t] &gt; ev[id] &#43; 1) { ev[e[i].t] = ev[id] &#43; 1; if (!vis[e[i].t]) { ev_q.push(e[i].t); vis[e[i].t] = true; } } } } memset(vis, 0, sizeof(vis)); // 下面一模一样 queue&lt;int&gt; od_q; for (int i = 1; i &lt;= n; i&#43;&#43;) { if (a[i] % 2 == 1) { vis[i] = true; od[i] = 0; od_q.push(i); } else { od[i] = INT_MAX; } } while (!od_q.empty()) { int id = od_q.front(); od_q.pop(); vis[id] = false; for (int i = pre[id]; i; i = e[i].n) { if (od[e[i].t] &gt; od[id] &#43; 1) { od[e[i].t] = od[id] &#43; 1; if (!vis[e[i].t]) { od_q.push(e[i].t); vis[e[i].t] = true; } } } } for (int i = 1; i &lt;= n; i&#43;&#43;) { int k; if (a[i] % 2 == 0) { k = od[i]; // 输出，输出与当前数字奇偶性不同的距离 } else { k = ev[i]; } if (k == INT_MAX) { cout &lt;&lt; &#34;-1 &#34;; // 无法到达 } else { cout &lt;&lt; k &lt;&lt; &#34; &#34;; } } cout &lt;&lt; endl; // 换行好习惯 return 0; } </p>
  </div>
  <footer class="entry-footer"><span title='2024-11-20 00:00:00 +0800 CST'>November 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to CF1272E Nearest Opposite Parity 题解" href="http://localhost:1313/posts/202b1a70de/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">搭建自己的代理服务器
    </h2>
  </header>
  <div class="entry-content">
    <p>😡 太长不读版：使用 VLESS &#43; WebSocket &#43; TLS 方案、Cloudflare CDN 保护、Cloudflare WARP 解锁服务，在 RackNerd 的 10.99/yr 起廉价服务器上搭建一个安全、隐私、不易封的代理服务器。无广告，很详细。如果您已经下定决心要自己搭建，请跳过 0x01 和 0x02 节。
本文如未特殊提及，货币单位均为美元。好吧，其实是会被 KaTeX 识别成数学公式……
各位想必都已经混迹互联网十余载，对于这门技术有所耳闻，甚至自己购买过机场的订阅，在外面的世界已经遨游过一番了。今天本蛾子就讲一个老生常谈的问题：老是觉得那些机场主都不可靠，我能不能自己搭一个？
首先在文章开始之前，国际惯例，对于几个常见误解进行声明：
本蛾子热爱中华人民共和国，热爱中国共产党，绝无污蔑、诋毁国家、党和人民的行为，本文的目的仅仅是技术分享，读者您的行为的后果由您自行承担； 本蛾子没有收一分钱；相反，还因为购买服务器和域名花了 30 多，本文请放心食用； 搭建代理服务器是一个比较复杂的过程，您应当有最基本的 Linux 使用能力，对网络相关知识有一定了解； 无论是自建的代理还是机场，总有被封或跑路的一天，您的钱若打了水漂，本蛾子不负责。 12 月 28 日更新：删去了大段大段没啥用的安全性分析。
👌 我知道了，开始吧 准备好了？让我们先看看大概要做什么。
购买 RackNerd 服务器（0x04 节）； 购买 Namesilo 域名并用 Cloudflare 托管（0x04 节）； 服务器初步设置，对于建站比较通用（0x05 节）； 搭建代理服务器，此时您已经可以使用代理了（0x05 节）； （可选）使用 Cloudflare 的 CDN 和 WARP 服务，对服务器前后流量进行优化（0x06 节）； （可选）安全性和速度提升（0x06 节）。 本蛾子趁着双十一购买了服务器和域名，总价 27.86（¥200.87，按照支付宝和 Stripe 的汇率），如果您不幸地在没什么活动的时候看到这篇文章，也可以选择到 RackNerd 社区去找找优惠，下面会说到。如果没有什么意外（不可能），搭建时间会在 30 到 40 分钟。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-17 00:00:00 +0800 CST'>November 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;智慧的幺蛾子</footer>
  <a class="entry-link" aria-label="post link to 搭建自己的代理服务器" href="http://localhost:1313/posts/4f6adc86c6/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="http://localhost:1313/posts/page/2/">&nbsp;2/2&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span><a href="https://creativecommons.org/public-domain/cc0/">CC0</a> 授权，允许您自由使用。</span>
    <br>
    <span><a href="https://icp.gov.moe/?keyword=20252048" target="_blank">萌ICP备20252048号</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
