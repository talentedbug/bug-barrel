<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 桶装幺蛾子</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on 桶装幺蛾子</description>
    <generator>Hugo -- 0.141.0</generator>
    <language>zh-cn</language>
    <copyright>CC0 授权，允许您自由使用。</copyright>
    <lastBuildDate>Fri, 10 Jan 2025 22:10:47 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用单板机为旧打印机添加局域网共享</title>
      <link>http://localhost:1313/posts/fdf8cb41df/</link>
      <pubDate>Fri, 10 Jan 2025 22:10:47 +0800</pubDate>
      <guid>http://localhost:1313/posts/fdf8cb41df/</guid>
      <description>&lt;p&gt;本蛾子家里有一部&lt;a href=&#34;http://www.orangepi.org/html/hardWare/computerAndMicrocontrollers/details/Orange-Pi-Zero-3.html&#34;&gt;香橙派 Zero 3&lt;/a&gt; 一直在吃灰。&lt;/p&gt;
&lt;p&gt;最近期末复习，大量打印试卷，只有蛾爸的台式机连着一台 HP LaserJet 打印机，不得不断断续续打扰他玩游戏去打印。蛾爸说，唉，要么买一台带 Wi-Fi 打印功能的新打印机吧！一看价格，动辄 2000 多。&lt;/p&gt;
&lt;p&gt;于是本蛾子在网上搜了搜，发现 HP 对 Linux 的驱动支持很好。在提出将打印机挪到本蛾子的房间的要求并被拒绝之后，猛地想起来这部吃灰的香橙派，插电看看，更新一下包，还能用。遂记录一下操作方法供您参考 😁&lt;/p&gt;
&lt;h2 id=&#34;-wi-fi-上网&#34;&gt;🛜 Wi-Fi 上网&lt;/h2&gt;
&lt;p&gt;之前这部单板机一直都是直接插网线上网的，但由于房间里唯一的网线接口被蛾爸的台式机占据，不得不使用无线网络。&lt;/p&gt;
&lt;p&gt;Armbian 竟然不自带 &lt;code&gt;network-manager&lt;/code&gt;，先自己装一个。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt update &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sudo apt upgrade
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install network-manager
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo systemctl &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt; --now NetworkManager &lt;span class=&#34;c1&#34;&gt;# 大小写敏感&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后用 &lt;code&gt;nmtui&lt;/code&gt; 连接一下无线网。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo nmtui
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20250110222603503&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/fdf8cb41df.d/image-20250110222603503.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20250110222704440&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/fdf8cb41df.d/image-20250110222704440.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后选择你的 Wi-Fi 连接即可。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ip addr&lt;/code&gt; 验证一下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20250110222913786&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/fdf8cb41df.d/image-20250110222913786.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以发现已经 DHCP 了一个 Wi-Fi IP 段的 IP。&lt;/p&gt;
&lt;p&gt;本蛾子家的路由器似乎不按照递增的顺序添加 IP，因此还需要设置一下静态 IP，以防失联：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo nmtui
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img alt=&#34;image-20250110223114160&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/fdf8cb41df.d/image-20250110223114160.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20250110223137620&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/fdf8cb41df.d/image-20250110223137620.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20250110223252638&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/fdf8cb41df.d/image-20250110223252638.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;重启一下 &lt;code&gt;network-manager&lt;/code&gt; 看看：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Clash 配置文件简述</title>
      <link>http://localhost:1313/posts/eeace13dad/</link>
      <pubDate>Sun, 29 Dec 2024 09:39:37 +0800</pubDate>
      <guid>http://localhost:1313/posts/eeace13dad/</guid>
      <description>&lt;p&gt;最近本蛾子发现之前搭建的代理，访问部分国内网站的时候不光速度很慢，而且有时候会报 PR_END_OF_FILE_ERROR（无法确定内容完整性，就是远程，特别是 CSDN，全站都无法访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;😮‍💨 唉：后来发现其实是服务端 WARP 的问题，跟 v2rayA 一毛钱关系都没有。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本蛾子现在使用的 v2rayA 虽然安装起来很方便（Arch Linux CN 有打包），但是对于规则的支持并不算好，并且开启、关闭、切换节点的速度也不尽人意。在网上搜索一通，似乎眼下最完善的内核是 Clash 系列的后继者 Mihomo，因此本蛾子就用它来学习一下&lt;strong&gt;如何书写 Clash 配置文件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;-客户端选择&#34;&gt;💻 客户端选择&lt;/h2&gt;
&lt;p&gt;Clash 系的客户端在 AUR 上基本全部都有打包。根据本蛾子的测试，似乎还在开发且可用性比较高的，只有 Clash Verge Rev 和 FlClash，而后者的 UI 设计本蛾子看着非常舒服，因此本文就以 FlClash 作为测试客户端。&lt;/p&gt;
&lt;p&gt;首先对 FlClash 的软件设置进行调整。虽然诸多 Clash 系客户端使用同一个内核，但是其 UI 设计却千差万别。FlClash 的界面大概是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image-20241229103214948&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/eeace13dad.d/image-20241229103214948.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 Tools 栏目中，主要是软件本身和覆写配置文件的选项，前者是主题、日志、自动启动等本地定义的选项，不出现在配置文件中，因此我们首先来完成对其的设置。覆写配置文件的设置主要针对使用远程配置文件（例如机场）的用户，方便修改配置文件。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;选项大部分您都应该能理解，说几个比较迷惑的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logcat：就是日志功能，记录您使用代理访问的网站，关闭之后不会记录，但是似乎需要手动删除之前的记录（位于您的主目录下）。&lt;/li&gt;
&lt;li&gt;Auto lost connections：在切换节点之后切断当前存在的连接，开启之后换区域会更加彻底，但是您的下载会被终端。&lt;/li&gt;
&lt;li&gt;Only statistics proxy：只对通过的流量进行记录，这时候 FlClash 就变成了一个网络监测工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然这个栏目还有其他功能，比如设置语言、主题、备份之类的，就请您自己探索了。&lt;/p&gt;
&lt;h2 id=&#34;-配置文件&#34;&gt;⚙️ 配置文件&lt;/h2&gt;
&lt;p&gt;这当然就是本文的重点了！通过 Clash 配置文件，您可以方便地修改 DNS、分流、（基础）去广告等，至于节点链接，倒成了配置文件中不太重要的一部分了。下面本蛾子参考了一些链接和项目，为行文流畅就不一一列出角标了，一并在文末引用。&lt;/p&gt;
&lt;p&gt;您书写的配置文件应当保存在任意名称的 &lt;code&gt;.yaml&lt;/code&gt; 文件中，在 FlClash 中这样引用：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用 SSH 公钥登录服务器并禁用密码</title>
      <link>http://localhost:1313/posts/5baaf9322f/</link>
      <pubDate>Sun, 15 Dec 2024 16:50:12 +0800</pubDate>
      <guid>http://localhost:1313/posts/5baaf9322f/</guid>
      <description>&lt;p&gt;😠 &lt;strong&gt;太长不读&lt;/strong&gt;：生成 SSH密钥，上传到服务器，然后禁用密码登录。（好像是废话）&lt;/p&gt;
&lt;h2 id=&#34;0x01--生成-ssh-密钥&#34;&gt;0x01 🔒 生成 SSH 密钥&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;以下使用 &lt;code&gt;$&lt;/code&gt; 符号代表本机执行，&lt;code&gt;&amp;gt;&lt;/code&gt; 符号代表服务器执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ssh-keygen # 旧版本需要添加 `-t ed25519` 参数
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/YOUR_USER_NAME/.ssh/id_ed25519): # 可以自定义位置，也可以直接回车
Enter passphrase for &amp;#34;example&amp;#34; (empty for no passphrase): # 输入密码（不显示），不建议空密码
Enter same passphrase again: # 再输一遍
Your identification has been saved in id_ed25519
Your public key has been saved in id_ed25519.pub # 带有 .pub 的是公钥
The key fingerprint is:
SHA256:SOME_STRANGE_STRING YOUR_USER_NAME@YOUR_HOST_NAME # 你的公钥指纹
The key&amp;#39;s randomart image is: # 根据公钥生成的随机图像
+--[ED25519 256]--+
|       SOME      |
|     STRANGE     |
|      IMAGE      |
|                 |
|                 |
|                 |
|                 |
|                 |
|                 |
+----[SHA256]-----+

$ ls .ssh
id_ed25519 id_ed25519 # 可能还有其他文件
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;0x02--上传到服务器&#34;&gt;0x02 ⬆️ 上传到服务器&lt;/h2&gt;
&lt;p&gt;首先确保你当前可以使用密码登录一个&lt;strong&gt;非 root&lt;/strong&gt; 的账号。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DP 优化的常见方法</title>
      <link>http://localhost:1313/posts/1ec9f00dde/</link>
      <pubDate>Wed, 27 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/1ec9f00dde/</guid>
      <description>&lt;p&gt;对于朴素 DP，有几种常见的优化方法，本文主要介绍&lt;strong&gt;单调队列&lt;/strong&gt;和&lt;strong&gt;斜率&lt;/strong&gt;优化。&lt;/p&gt;
&lt;h2 id=&#34;单调队列优化-dp&#34;&gt;单调队列优化 DP&lt;/h2&gt;
&lt;p&gt;例题：&lt;a href=&#34;https://www.luogu.com.cn/problem/P1886&#34;&gt;P1886 滑动窗口 /【模板】单调队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单调队列是一种特殊的双端队列，从字面上理解，就是具有某种单调性的队列，例如递增或者递减。一般来说单调队列可以用于维护最值，解决滑动窗口类的问题，时间复杂度是 $O(n)$。&lt;/p&gt;
&lt;p&gt;单调队列的维护可以通过不断添加新元素，并不定时访问或者删除旧的元素。&lt;/p&gt;
&lt;p&gt;以上述例题为例，我们可以如何求出单调队列的长度呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的方法：枚举滑动窗口的左端点和窗口长度，再求出区间内的最大、最小值，时间复杂度 $O(n^{2}k)$；&lt;/li&gt;
&lt;li&gt;RMQ（区间最值）类算法：同样枚举区间，通过预处理优化求区间最值的时间复杂度，最终为 $O(n^2 \log_{2} n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以发现，这两个算法都存在一个问题：一个序列 $a_{i},a_{i+1} \cdots a_{j}$ 和同样长度的 $a_{i+1},a_{i+2} \cdots a_{j+1}$，其中有长达 $j-i-1$ 的区间是重复的。&lt;/p&gt;
&lt;p&gt;这里，单调队列优化就有用了。我们用一个例子来说明单调队列如何工作：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1 4 5 -1 0 3 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设当前的区间长度 $k=4$，我们只求最小值，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;队列初始为空，1 入队；&lt;/li&gt;
&lt;li&gt;由于 1 入队时间早于 4，有可能在 1 出队后，4 成为新的最小值，因此 4 进队；&lt;/li&gt;
&lt;li&gt;同上原因，5 入队；&lt;/li&gt;
&lt;li&gt;这时候我们遇到了 -1，它小于队尾的 5，并且 -1 的入队时间晚于 5。那么如果 -1 入队，5 出队早于 -1，并且只要 -1 在队中，最小值都不可能是 5，因此 5 出队；&lt;/li&gt;
&lt;li&gt;同上原因，4 出队；&lt;/li&gt;
&lt;li&gt;由于上面主要原因已经讲完了，所以下面就简单地带过：0 时间晚，入队；&lt;/li&gt;
&lt;li&gt;3 时间晚，入队；&lt;/li&gt;
&lt;li&gt;1 时间晚，且值小，3 出队，1 入队。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上述过程，我们可以发现，无论到哪一位，我们都维护了一个&lt;strong&gt;单调&lt;/strong&gt;递减的队列。由于本题还要求区间长度，我们还应当记录队列中元素的位置，如果超出范围就同样出队。&lt;/p&gt;</description>
    </item>
    <item>
      <title>图的连通性问题</title>
      <link>http://localhost:1313/posts/b1aaece446/</link>
      <pubDate>Mon, 25 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/b1aaece446/</guid>
      <description>&lt;p&gt;&lt;strong&gt;图的连通性问题&lt;/strong&gt;主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;割边和割点；&lt;/li&gt;
&lt;li&gt;强连通分量和缩点；&lt;/li&gt;
&lt;li&gt;边双连通分量和点双连通分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;求解这些问题，效率最高、思路最清晰的算法是 &lt;strong&gt;Tarjan&lt;/strong&gt; 算法，由&lt;strong&gt;罗伯特·恩卓·塔扬&lt;/strong&gt;发明。塔扬研究了并查集、图论等许多领域，因此有很多以他名字命名的算法，这里是指关于图的连通性问题的算法。&lt;/p&gt;
&lt;h2 id=&#34;割边和割点&#34;&gt;割边和割点&lt;/h2&gt;
&lt;p&gt;不大严谨、完全不形式化的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;割边&lt;/strong&gt;：如果删除图上的某条边，图就不再连通，那么这条边就是图的割边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;割点&lt;/strong&gt;：如果删除图上的某个点以及与其相连的所有边，图就不再连通，那么这个点就是图的割点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;暴力求解这个问题，可以枚举删除某一条边或者某一个点，然后通过 DFS 判断连通性，平均时间复杂度是 $O(n^2)$。&lt;/p&gt;
&lt;p&gt;首先需要了解的是 &lt;strong&gt;DFS 树&lt;/strong&gt;。DFS 树是从图上任意一点开始 DFS，由 DFS 顺序所构成的一棵树，开始点对于答案没有影响。在树上出现的边称为&lt;strong&gt;树边&lt;/strong&gt;，否则称为&lt;strong&gt;非树边&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在割边和割点问题中，一般只研究无向图。非树边在 DFS 树中以&lt;strong&gt;返祖边&lt;/strong&gt;的形式出现，其含义就是字面含义。&lt;/p&gt;
&lt;h3 id=&#34;割点&#34;&gt;割点&lt;/h3&gt;
&lt;p&gt;割点可以分为两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根节点在 DFS 树中有多余一个子节点，那么它就是割点；&lt;/li&gt;
&lt;li&gt;对于一个非根节点，它的子树中至少有一棵，不存在一条返祖边可以回到它的祖先节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一种请款很简单；第二种情况，如果子树上存在到它的祖先的返祖边，当它被删除之后，这棵子树仍然可以通过返祖边到达原本节点的祖先。&lt;/p&gt;
&lt;p&gt;求割点的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$dfn_{i}$ 表示节点 $i$ 的时间戳，或者也可以说是节点在 DFS 树中的深度，通过其大小比较可以判断祖先与子孙的关系；&lt;/li&gt;
&lt;li&gt;$low_{i}$ 表示节点 $i$ 不经过其父节点能到达的 $dfn$ 最小的祖先。（这个概念大部分博客都没有讲清楚，本蛾子搜遍互联网终于找到了对其的明确定义，特此感谢：&lt;a href=&#34;https://skywt.cn/blog/tarjan-cut-vertex-cut-edge/&#34;&gt;Tarjan 算法求解无向图的割点与割边&lt;/a&gt;，可惜的是这篇博客下面的代码是错误的。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一个节点 $v$ 及其祖先 $u$，如果回溯时发现 $low_{v} \geq dfn_{u}$，也就是说 $v$ 回不到 $u$ 的祖先（取等，因为此时与 $3$ 相连的所有边都被删除，所以不可能到达）。&lt;/p&gt;
&lt;p&gt;还需要注意，当一个节点的子节点已经被访问，更新应当使用 &lt;code&gt;dfn[e[i].t]&lt;/code&gt; 而非 &lt;code&gt;low[e[i].t]&lt;/code&gt;。若使用后者，会导致割点的子节点使用割点能访问的祖先节点更新，那这就白跑了。&lt;/p&gt;
&lt;p&gt;代码实现（可以根据注释理解）：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;
int n, m;
struct edge {
    int f, t;
    int n;
} e[220000];
int ec;
int pre[22000];
int dfn[22000], low[22000];
set&amp;lt;int&amp;gt; ce;
bool vis[22000];
int ro;

void add(int f, int t) {
    e[++ec].f = f;
    e[ec].t = t;
    e[ec].n = pre[f];
    pre[f] = ec;
}

int dfs_cnt;
void dfs(int c, int f) { // `c`: current node, `f`: father node
    vis[c] = true;
    dfn[c] = low[c] = ++dfs_cnt; // Update the current timestamp
    int sc = 0; // The number of children, in case this is root
    for (int i = pre[c]; i; i = e[i].n) {
        if (!vis[e[i].t]) { // Not visited, indicating it&amp;#39;s reached for the first 
                            // time and thus cannot reach an ancestor
            sc++;
            dfs(e[i].t, c); // Go to children and thus recall
            low[c] = min(low[c], low[e[i].t]); // Update ancestors that `c` 
                                               // reach by its subtree
            if (c != ro &amp;amp;&amp;amp; low[e[i].t] &amp;gt;= dfn[c]) { // Indicating that its subtree cannot reach 
                                                    // `c`&amp;#39;s ancestors
                                                    // SO NODE `C` IS AN CUT NODE
                ce.insert(c);
            }
            if (c == ro &amp;amp;&amp;amp; sc &amp;gt;= 2) {
                ce.insert(c); // If `c` is root and has more than one subtree,
                                 // obviously it&amp;#39;s a cut node
            }
        } else {
            if (e[i].t != f) { // Visited before, so `c` could reach what 
                               // `e[i].t` could reach
                low[c] = min(low[c], dfn[e[i].t]);
            }
        }
    }
}

int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    for (int i = 1; i &amp;lt;= m; i++) {
        int f, t;
        cin &amp;gt;&amp;gt; f &amp;gt;&amp;gt; t;
        add(f, t), add(t, f);
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        if (!vis[i]) {
            ro = i;
            dfs(i, 0);
        }
    }
    cout &amp;lt;&amp;lt; ce.size() &amp;lt;&amp;lt; endl;
    for (auto k: ce) {
        cout &amp;lt;&amp;lt; k &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
    }
    cout &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意去重，因为如果割点不止一棵子树不能返祖，那么就会重复添加。（硬控本蛾子半小时。）&lt;/p&gt;</description>
    </item>
    <item>
      <title>集训笔记：树结构</title>
      <link>http://localhost:1313/posts/5dad7361ce/</link>
      <pubDate>Sun, 24 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/5dad7361ce/</guid>
      <description>&lt;p&gt;我还是希望大家啊，多用歪克特，啊，尤其是我们现在有了，啊，凹凸，简洁而且方便。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文中若无特殊说明，认为树的根节点的深度为 1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;树的直径&#34;&gt;树的直径&lt;/h2&gt;
&lt;p&gt;树上任意两个点之间的最长距离称为树的直径。&lt;/p&gt;
&lt;p&gt;求树的直径，可以从任何一个节点 $x$ 开始 DFS，能到达的最远节点 $y$ 一定是直径的一端。再从 $y$ 开始 DFS，能到达的最远节点 $z$ 就是直径的另一端，$x$ 与 $y$ 的距离即为直径。&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/5dad7361ce.d/image-1024x344.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/5dad7361ce.d/image-1-1024x451.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/5dad7361ce.d/image-2-1024x459.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/5dad7361ce.d/image-3-1024x494.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;树的直径也可以使用树形 DP 计算，若设 1 为树根，那么设某个点向下能达到的最大和次大值是 $d1$ 和 $d2$，那么 $d1 + d2$ 最大时就是树的直径。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/5dad7361ce.d/image-4-1024x650.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述写法也可以压缩为一个数组，定义 $dp_{u}$ 是以 $u$ 为树根的子树中，从 $u$ 出发的最长路径，那么有转移方程 $dp_{u}=\max{dp_{u}, dp_{v}}$，其中 $v$ 是 $u$ 的子节点。对于求直径的过程，我们可以在转移时打擂求最大值。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/5dad7361ce.d/image-5-1024x442.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;树的中心&#34;&gt;树的中心&lt;/h2&gt;
&lt;p&gt;选定一个点作为树的根节点，使得叶节点到根节点的最大距离最小，这个点称为树的中心。&lt;/p&gt;
&lt;p&gt;树的中心一定在直径上，且趋于两个端点的中点，因此可以在找出直径的同时，求出其到每个节点的距离。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define re register
#define maxn 100010
using namespace std;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch&amp;lt;&amp;#39;0&amp;#39;||ch&amp;gt;&amp;#39;9&amp;#39;){if(ch==&amp;#39;-&amp;#39;)f=-1;ch=getchar();}
	while(ch&amp;gt;=&amp;#39;0&amp;#39;&amp;amp;&amp;amp;ch&amp;lt;=&amp;#39;9&amp;#39;){x=x*10+ch-&amp;#39;0&amp;#39;;ch=getchar();}
	return x*f;
}
struct Edge{
	int v,w,nxt;
}e[maxn&amp;lt;&amp;lt;2];
int x,y,z;
int pos1,pos2,d[maxn],d1[maxn],d2[maxn];
int n,tmp1,tmp2,tmp3,ans,pos,cnt,head[maxn];
inline void add(int u,int v,int w)
{
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void dfs1(int u,int fa,int dis)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int ev=e[i].v;
		if(ev==fa) continue;
		dfs1(ev,u,dis+e[i].w);
	}
	d[u]=dis;
	if(dis&amp;gt;tmp2) tmp2=dis,tmp1=u;
}

int main()
{
	n=read();
	for(re int i=1;i&amp;lt;n;++i)
	{
		x=read(),y=read(),z=read();
		add(x,y,z);
		add(y,x,z);
	}
	dfs1(1,0,0);
	pos1=tmp1;
	tmp2=0,tmp1=0;
	dfs1(pos1,0,0);
	pos2=tmp1;
	tmp2=0,tmp1=0;
	//找到直径了 
	for(re int i=1;i&amp;lt;=n;++i) d1[i]=d[i];
	dfs1(pos2,0,0);
	for(re int i=1;i&amp;lt;=n;++i) d2[i]=d[i];
	ans=0x3f3f3f3f;
	for(re int i=1;i&amp;lt;=n;++i)
	{
		if(ans&amp;gt;max(d1[i],d2[i]))
		ans=max(d1[i],d2[i]),pos=i;
	}
	printf(&amp;#34;%d %d&amp;#34;,pos,ans);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;树的重心&#34;&gt;树的重心&lt;/h2&gt;
&lt;p&gt;选择树中的一个节点并删除，使得分成的所有子树的最大节点数最小，这个点称为树的重心。树的重心若不唯一，则一定有两个。&lt;/p&gt;</description>
    </item>
    <item>
      <title>集训笔记：图论算法二</title>
      <link>http://localhost:1313/posts/307ee35eff/</link>
      <pubDate>Sat, 23 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/307ee35eff/</guid>
      <description>&lt;h2 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h2&gt;
&lt;h3 id=&#34;prim-算法&#34;&gt;Prim 算法&lt;/h3&gt;
&lt;p&gt;算法原理：从一个点出发维护一个最小生成树上的点的集合，每次选择一条集合内某点和集合外某点的最小边权加入，然后将集合外的这个点加入集合。若暴力查找最小边权，时间复杂度为 $O(n^2)$。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/307ee35eff.d/1732344587-image-1024x768.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Prim 算法的思路和 Dijkstra 最短路算法非常相似，优化也基本相同。对于暴力做法中寻找最小值的步骤，可以使用优先队列优化到 $O(n+m\log{m})$。&lt;/p&gt;
&lt;h3 id=&#34;kruskal-算法&#34;&gt;Kruskal 算法&lt;/h3&gt;
&lt;p&gt;将边权从小到大排序，一一尝试向最小生成树添加边，若边的端点不在同一个连通块内，则添加，时间复杂度为 $O(e\log{e})$。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/307ee35eff.d/1732345486-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;算法的正确性显然，对于放弃的边，其权值大于前面所有的边，因此产生环时应当首先放弃。时间复杂度瓶颈在排序操作上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题：HDU7226&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/307ee35eff.d/1732345686-image-1024x129.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/307ee35eff.d/1732345693-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;序列中所有数字之间的边构成一个完全图，但是不可能将这个完全图实际建出来，空间和时间上都无法接受。&lt;/p&gt;
&lt;p&gt;如果我们直接按顺序连接所有点，那么每条边的边权都小于 &lt;code&gt;n&lt;/code&gt;。因此，最小生成树中所有边权都应当小于 &lt;code&gt;n&lt;/code&gt;，也就是 $|i - j| * |p_{i}-p_{j}|$ 小于 $n$，两个乘数有一个小于 $\sqrt{n}$。我们可以选择枚举 $i$ 在 1 到 n，$j$ 在 $i$ 到 $i+\sqrt{n}$，总时间复杂度为 $O(n\sqrt{n})$。&lt;/p&gt;
&lt;p&gt;然后对这些边计算最小生成树，因此叠加后的时间复杂度为 $O(n\sqrt{n}\log{n}\sqrt{n})$。若时间复杂度较为紧张，还可以使用桶排进行 Kruskal 中的排序过程，将 $\log{n}$ 压缩。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题：洛谷 P2245 星际导航&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/307ee35eff.d/1732347318-image-1024x536.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;题意是寻找一条路径上边权的最大值。两个点之间可能有很多边，但是边权较大的边不会产生贡献，因此我们先对图运行 Kruskal 求最小生成树，这样两个点之间有唯一路径且一定最小（否则更短的边会出现在生成树中）。这样就可以通过 LCA 直接求出总边权。&lt;/p&gt;
&lt;p&gt;另一种思路是使用 &lt;strong&gt;Kruskal 重构树&lt;/strong&gt;，适用于最小生成树最大边权问题。&lt;/p&gt;
&lt;p&gt;Kruskal 重构树的求解过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将边权从小到大排序；&lt;/li&gt;
&lt;li&gt;每次选择边权最小的一条边，若其连接的两个点已经进入集合，则跳过；否则，将这两个点的祖先都连接到一个虚点上，点权为这条边的边权。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/307ee35eff.d/1732347871-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这棵树上，两个节点之间的最大权值可以直接通过 LCA 求得，不需要单独维护。某些题目只能通过重构树的方式实现。&lt;/p&gt;</description>
    </item>
    <item>
      <title>集训笔记：图论算法一</title>
      <link>http://localhost:1313/posts/38853453c4/</link>
      <pubDate>Fri, 22 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/38853453c4/</guid>
      <description>&lt;h2 id=&#34;拓扑排序&#34;&gt;拓扑排序&lt;/h2&gt;
&lt;p&gt;拓扑排序是图论中的一种算法，适用于 DAG 中，可以用于求拓扑序列。拓扑排序的结果是一个线性序列，满足每个顶点在序列中只出现一次，且若存在 A 到 B 的路径，则 A 出现在 B 之前。拓扑序列通常不唯一。&lt;/p&gt;
&lt;p&gt;基于 BFS（入度）的拓扑排序比较容易实现。&lt;/p&gt;
&lt;p&gt;伪代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732257535-image-1024x315.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732257614-image-1024x470.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;拓扑排序可以判断图中是否有环。如果最终所有顶点的入度都减少为 0，队列清空，则不存在环；否则则有环。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732257770-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题：机器人擂台赛（CF645D）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732257837-image-1024x366.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;没有自相矛盾&lt;/em&gt;：没有环；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;没有比赛包含相同机器人&lt;/em&gt;：没有重边；&lt;/li&gt;
&lt;li&gt;属于「依赖关系」，优先考虑拓扑排序；&lt;/li&gt;
&lt;li&gt;判断是否有唯一的拓扑序列，可以在拓扑排序过程中判断是否同时有多于一个入度为 0 的顶点（也就是每次只有一个选择）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接在拓扑排序的模板上进行修改即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732258142-image-1024x515.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于比赛的处理，可以有以下几种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次加一条边，并进行拓扑排序，当序列唯一时输出（注意清空）；&lt;/li&gt;
&lt;li&gt;答案具有单调性，可以二分答案，对最大答案进行特判是否无解；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732258511-image.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拓扑排序相邻两个顶点之间的关系必须给出，因此可以在拓扑排序中记录每一场必要的比赛的编号，然后依次扫描所有比赛，在所有比赛都出现的时候就可以输出了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732258881-image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;最短路算法&#34;&gt;最短路算法&lt;/h2&gt;
&lt;h3 id=&#34;bfs&#34;&gt;BFS&lt;/h3&gt;
&lt;p&gt;当一张图上不含边权，或者边权都相等，可以直接使用 BFS 计算最短路，算法正确且复杂度不高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题：Nearest Opposite Parity（CF1272E）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732259171-image-1024x373.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732259216-image-1024x533.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的方法：从每一个数开始，寻找最近的异性数字；&lt;/li&gt;
&lt;li&gt;优化：从所有奇数出发，统计能到达所有偶数的最短路，对于偶数也这样求出最短路；&lt;/li&gt;
&lt;li&gt;反向建图，也就是从 &lt;code&gt;i + a[i]&lt;/code&gt; 和 &lt;code&gt;i - a[i]&lt;/code&gt; 连一条到 &lt;code&gt;i&lt;/code&gt; 的边，也就是从&lt;strong&gt;终点&lt;/strong&gt;出发，寻找到每一个起点的最短路；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732260193-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;两个 BFS 基本一致，以到达奇数的 BFS 为例：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/38853453c4.d/1732260233-image.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>CF1272E Nearest Opposite Parity 题解</title>
      <link>http://localhost:1313/posts/202b1a70de/</link>
      <pubDate>Wed, 20 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/202b1a70de/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.luogu.com.cn/article/0m4pa5w4&#34;&gt;洛谷题解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题意简述&#34;&gt;题意简述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/problemset/problem/1272/E&#34;&gt;原题链接（CF）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出长度为 $n$ 的序列 $a$，允许从某个数 $a_{i}$ 向前或向后跳跃 $a_{i}$ 个数（跳跃后的位置在序列内），要求求出从奇偶性不同的另一个数到每个数的最短距离。&lt;/p&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;p&gt;首先很容易想到一个符合直觉的方案：对于每一个数，我们以它为源点计算最短路（使用图论算法；由于边权都是 1，还可以用 BFS），然后找到距离最近、奇偶性相反的数，输出距离。&lt;/p&gt;
&lt;p&gt;但是这个方法的问题很明显：枚举每个数字，再加上 BFS，至少也是 $O(n^2)$ 的时间复杂度，如果用图论算法还得更高。&lt;/p&gt;
&lt;p&gt;我们希望能在一次 BFS 之后就得出每个点的最短路，这样时间复杂度就来到了 $O(n)$。&lt;/p&gt;
&lt;p&gt;这里的难点就是&lt;strong&gt;反向建边&lt;/strong&gt;，即从 $i \pm a_{i}$ 建立到 $i$ 的边。其他大佬的题解自然地提到了反向建边，但是对我这样的蒟蒻，为什么反向建边更重要。这出于两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输出要求是&lt;strong&gt;到达&lt;/strong&gt;每个数的最短路径，如果存储的也是到达的路径长度显然更方便；&lt;/li&gt;
&lt;li&gt;BFS 中，如果我们反向地遍历，可以避免正向遍历所导致的反复遍历：我们将从结果推开头，这样不需要对每个源点一一遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了这个概念，我们就可以将所有数字分为奇数和偶数。定义 $ev_{i}$ 是&lt;strong&gt;从&lt;/strong&gt;偶数到 $i$ 的最短路径，$od_{i}$ 是&lt;strong&gt;从&lt;/strong&gt;奇数到 $i$ 的最短路径，那么显然奇数 $a_{i}$ 的 $od_{i}$、偶数 $a_{j}$ 的 $ev_{j}$ 均为 0。&lt;/p&gt;
&lt;p&gt;我们将偶数提前入队，从它们开始跑一遍 BFS，去求出&lt;strong&gt;从偶数&lt;/strong&gt;到达每一个数的最短路径；对于奇数也是同样的操作。&lt;/p&gt;
&lt;p&gt;那么现在就很清楚了，我们已经有了从奇数或者偶数到达一个点的最短路径（BFS 路径就是最短路），输出直接选择与 $a_{i}$ 相反的那个路径长度即可。&lt;/p&gt;
&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;
&lt;p&gt;变量名对应表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;：原题中 &lt;code&gt;N&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;：原题中 &lt;code&gt;a&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ev&lt;/code&gt;，&lt;code&gt;od&lt;/code&gt;：见上文；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edge&lt;/code&gt;：边：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt;，&lt;code&gt;t&lt;/code&gt;：边的首、尾；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;：下一条边（用于遍历）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ec&lt;/code&gt;：边的计数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pre&lt;/code&gt;：以某个点为首的第一条边（用于遍历）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vis&lt;/code&gt;：访问记录（用于 BFS），注意清零；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ev_q&lt;/code&gt;，&lt;code&gt;od_q&lt;/code&gt;：用于偶数、奇数 BFS 的队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;
int n;
int a[220000];
int ev[220000], od[220000];

// 链式前向星，其实邻接表也行
struct edge {
    int f, t;
    int n;
} e[420000];
int ec;
int pre[220000];
bool vis[220000];
void add(int f, int t) {
    e[++ec].f = f;
    e[ec].t = t;
    e[ec].n = pre[f];
    pre[f] = ec;
}

int main() {
    cin &amp;gt;&amp;gt; n;
    for (int i = 1; i &amp;lt;= n; i++) {
        cin &amp;gt;&amp;gt; a[i];
        if (i - a[i] &amp;gt;= 1) {
            add(i - a[i], i); // 反向建边
        }
        if (i + a[i] &amp;lt;= n) {
            add(i + a[i], i);
        }
    }
    memset(vis, 0, sizeof(vis)); // 清空
    queue&amp;lt;int&amp;gt; ev_q;
    for (int i = 1; i &amp;lt;= n; i++) {
        if (a[i] % 2 == 0) {
            ev[i] = 0;
            ev_q.push(i);
            vis[i] = true; // 初始化本来就是偶数的数，距离为 0，入队
        } else {
            ev[i] = INT_MAX; // 否则初始化为无穷大
        }
    }
    while (!ev_q.empty()) { // BFS，基本就是模板
        int id = ev_q.front();
        ev_q.pop();
        vis[id] = false;
        for (int i = pre[id]; i; i = e[i].n) {
            if (ev[e[i].t] &amp;gt; ev[id] + 1) {
                ev[e[i].t] = ev[id] + 1;
                if (!vis[e[i].t]) {
                    ev_q.push(e[i].t);
                    vis[e[i].t] = true;
                }
            }
        }
    }
    memset(vis, 0, sizeof(vis)); // 下面一模一样
    queue&amp;lt;int&amp;gt; od_q;
    for (int i = 1; i &amp;lt;= n; i++) {
        if (a[i] % 2 == 1) {
            vis[i] = true;
            od[i] = 0;
            od_q.push(i);
        } else {
            od[i] = INT_MAX;
        }
    }
    while (!od_q.empty()) {
        int id = od_q.front();
        od_q.pop();
        vis[id] = false;
        for (int i = pre[id]; i; i = e[i].n) {
            if (od[e[i].t] &amp;gt; od[id] + 1) {
                od[e[i].t] = od[id] + 1;
                if (!vis[e[i].t]) {
                    od_q.push(e[i].t);
                    vis[e[i].t] = true;
                }
            }
        }
    }
    for (int i = 1; i &amp;lt;= n; i++) {
        int k;
        if (a[i] % 2 == 0) {
            k = od[i]; // 输出，输出与当前数字奇偶性不同的距离
        } else {
            k = ev[i];
        }
        if (k == INT_MAX) {
            cout &amp;lt;&amp;lt; &amp;#34;-1 &amp;#34;; // 无法到达
        } else {
            cout &amp;lt;&amp;lt; k &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
        }
    }
    cout &amp;lt;&amp;lt; endl; // 换行好习惯
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>搭建自己的代理服务器</title>
      <link>http://localhost:1313/posts/4f6adc86c6/</link>
      <pubDate>Sun, 17 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/4f6adc86c6/</guid>
      <description>&lt;p&gt;😡 &lt;strong&gt;太长不读版&lt;/strong&gt;：使用 VLESS + WebSocket + TLS 方案、Cloudflare CDN 保护、Cloudflare WARP 解锁服务，在 RackNerd 的 10.99/yr 起廉价服务器上搭建一个安全、隐私、不易封的代理服务器。无广告，很详细。如果您已经下定决心要自己搭建，请跳过 0x01 和 0x02 节。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文如未特殊提及，货币单位均为美元。好吧，其实是会被 KaTeX 识别成数学公式……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位想必都已经混迹互联网十余载，对于这门技术有所耳闻，甚至自己购买过机场的订阅，在外面的世界已经遨游过一番了。今天本蛾子就讲一个老生常谈的问题：&lt;strong&gt;老是觉得那些机场主都不可靠，我能不能自己搭一个？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先在文章开始之前，国际惯例，对于几个常见误解进行声明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本蛾子&lt;strong&gt;热爱中华人民共和国&lt;/strong&gt;，&lt;strong&gt;热爱中国共产党&lt;/strong&gt;，&lt;strong&gt;绝无污蔑、诋毁国家、党和人民的行为&lt;/strong&gt;，本文的目的仅仅是技术分享，读者您的行为的后果由您自行承担；&lt;/li&gt;
&lt;li&gt;本蛾子没有收一分钱；相反，还因为购买服务器和域名花了 30 多，本文请放心食用；&lt;/li&gt;
&lt;li&gt;搭建代理服务器是一个比较复杂的过程，您应当有最基本的 Linux 使用能力，对网络相关知识有一定了解；&lt;/li&gt;
&lt;li&gt;无论是自建的代理还是机场，总有被封或跑路的一天，您的钱若打了水漂，&lt;strong&gt;本蛾子不负责&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;12 月 28 日更新：删去了大段大段没啥用的安全性分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;-我知道了开始吧&#34;&gt;👌 我知道了，开始吧&lt;/h2&gt;
&lt;p&gt;准备好了？让我们先看看大概要做什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;购买 RackNerd 服务器（0x04 节）；&lt;/li&gt;
&lt;li&gt;购买 Namesilo 域名并用 Cloudflare 托管（0x04 节）；&lt;/li&gt;
&lt;li&gt;服务器初步设置，对于建站比较通用（0x05 节）；&lt;/li&gt;
&lt;li&gt;搭建代理服务器，此时您已经可以使用代理了（0x05 节）；&lt;/li&gt;
&lt;li&gt;（可选）使用 Cloudflare 的 CDN 和 WARP 服务，对服务器前后流量进行优化（0x06 节）；&lt;/li&gt;
&lt;li&gt;（可选）安全性和速度提升（0x06 节）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本蛾子趁着双十一购买了服务器和域名，总价 27.86（¥200.87，按照支付宝和 Stripe 的汇率），如果您不幸地在没什么活动的时候看到这篇文章，也可以选择到 RackNerd 社区去找找优惠，下面会说到。如果没有什么意外（不可能），搭建时间会在 30 到 40 分钟。&lt;/p&gt;</description>
    </item>
    <item>
      <title>集训笔记：动态规划经典模型 2</title>
      <link>http://localhost:1313/posts/976003163f/</link>
      <pubDate>Sun, 17 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/976003163f/</guid>
      <description>&lt;p&gt;&lt;del&gt;状态是，啊？离离离离——哟哟——&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;对应洛谷题号：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/976003163f.d/1731832504-image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;单调队列优化&#34;&gt;单调队列优化&lt;/h2&gt;
&lt;h3 id=&#34;线性-dp&#34;&gt;线性 DP&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;例题：PTA-Little Bird（洛谷 P3572）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/976003163f.d/1731825461-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;设一只鸟在第 $i$ 棵树的疲劳值是 $f_{i}$，则 $f[i] = \min{f_{j} + h_{i} \geq h_{j}}$，其中 $i - k \leq j \lt i$。当 $i$ 增加时，可以发现求最小值的部分是有重合的，因此我们可以通过去除冗余部分来优化。&lt;/p&gt;
&lt;p&gt;上述公式中 $[i - k,i)$ 的部分类似于一个滑动窗口，我们每次删除不在区间内的部分，并加入新的区间内的元素，通过（递增）单调队列的数据结构来维护最小值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果队头的元素（最小值）在范围内，我们直接采用；&lt;/li&gt;
&lt;li&gt;如果队头的元素不在范围内，我们将其删除；&lt;/li&gt;
&lt;li&gt;新的元素从队尾加入，如果比队尾更优，则一直将队尾出队（因为新的元素在时效上更优，旧元素没有作用了），直到前方元素比新元素更优。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/976003163f.d/1731826445-image-1024x447.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;要点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 19 行执行了出队操作；&lt;/li&gt;
&lt;li&gt;第 22 行对于队尾贡献一定不及新元素的元素进行了出队，对于贡献相同的元素，依然进行了出队，因为新元素时效性更强。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多重揹包&#34;&gt;多重揹包&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;例题：BAN-Bank Notes（洛谷 P3423）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;img&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/976003163f.d/1731826730-image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;对题意进行分析，发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;揹包容量是面值 $k$；&lt;/li&gt;
&lt;li&gt;物品体积是每种硬币的面值；&lt;/li&gt;
&lt;li&gt;物品价值并不是面值，而是每个物品都为 $1$，且要求总价值最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设 DP 状态 $f_{i,j}$ 表示第 $i$ 个硬币、总面值为 $j$，则有转移方程 $f_{i}{j} = \max{f_{i - 1,j - k \times w_{i}} + k \times v_{i}}$ ，其中 $v_{i}$ 在本题中为 $1$，时间复杂度为 $O(j * \Sigma c_{i})$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>集训笔记：动态规划经典模型 1</title>
      <link>http://localhost:1313/posts/ca87829a43/</link>
      <pubDate>Sat, 16 Nov 2024 00:00:00 +0800</pubDate>
      <guid>http://localhost:1313/posts/ca87829a43/</guid>
      <description>&lt;p&gt;&lt;del&gt;语速和打字速度的对决（）&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&#34;动态规划经典模型&#34;&gt;动态规划经典模型&lt;/h1&gt;
&lt;p&gt;动态规划包括&lt;strong&gt;线性 DP&lt;/strong&gt;、&lt;strong&gt;区间 DP&lt;/strong&gt;、&lt;strong&gt;树形 DP&lt;/strong&gt;、&lt;strong&gt;数位 DP&lt;/strong&gt;、&lt;strong&gt;状压 DP&lt;/strong&gt;、&lt;strong&gt;概率 DP&lt;/strong&gt;、&lt;strong&gt;期望 DP&lt;/strong&gt; 等。&lt;/p&gt;
&lt;h2 id=&#34;用通模型&#34;&gt;用通模型&lt;/h2&gt;
&lt;h3 id=&#34;lis最长上升子序列&#34;&gt;LIS：最长上升子序列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;状态表示：集合（所有以 $a_{i}$ 结尾的上升子序列）、属性（最大值）；&lt;/li&gt;
&lt;li&gt;状态计算：集合划分（「最后一步」）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现版本：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;朴素算法&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a[0] = -INF // 哨兵
dp[0] = 0 // 边界
for (int i = 1; i &amp;lt;= n; i++) {
    for (int j = 1; j &amp;lt; i; j++) {
        if (a[j] &amp;gt; a[i]) {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;时间复杂度：$O(n^2)$&lt;/p&gt;
&lt;p&gt;算法瓶颈：内层枚举有很多无用状态&lt;/p&gt;
&lt;p&gt;可以使用贪心策略优化：子序列长度相同，枚举末尾的元素 $a_{j}$ 越小，后面更有可能可以连续。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单调栈优化算法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义数组 $low_{i}$ 维护 LIS 长度为 $i$ 时最小的末尾；$len$ 是当前 LIS 的长度；&lt;/li&gt;
&lt;li&gt;遍历 $a$ 时，若 $a_{i} \gt low_{len}$，则更新最大长度，将 $a_{i}$ 添加到末尾；&lt;/li&gt;
&lt;li&gt;否则，替换 $low$ 中第一个大于或等于 $a_{i}$ 的元素；&lt;/li&gt;
&lt;li&gt;这样 $low$ 始终为一个单调序列，可以使用二分查找优化；&lt;/li&gt;
&lt;li&gt;最终 $len$ 是 LIS 的长度（$low$ 不是最终的 LIS 序列）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
