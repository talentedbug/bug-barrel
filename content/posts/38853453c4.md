---
date: '2024-11-22T00:00:00+08:00'
draft: false
title: '集訓筆記：圖論算法一'
typora-copy-images-to: '../../static/img/${filename}.d'
---

## 拓撲排序

拓撲排序是圖論中的一種算法，適用於 DAG 中，可以用於求拓撲序列。拓撲排序的結果是一個線性序列，滿足每個頂點在序列中只出現一次，且若存在 A 到 B 的路徑，則 A 出現在 B 之前。拓撲序列通常不唯一。

基於 BFS（入度）的拓撲排序比較容易實現。

僞代碼：

![img](../../static/img/38853453c4.d/1732257535-image-1024x315.png)

代碼示例：

![img](../../static/img/38853453c4.d/1732257614-image-1024x470.png)

拓撲排序可以判斷圖中是否有環。如果最終所有頂點的入度都減少爲 0，隊列清空，則不存在環；否則則有環。

代碼示例：

![img](../../static/img/38853453c4.d/1732257770-image.png)

**例題：機器人擂臺賽（CF645D）**

![img](../../static/img/38853453c4.d/1732257837-image-1024x366.png)

分析：

- *沒有自相矛盾*：沒有環；
- *沒有比賽包含相同機器人*：沒有重邊；
- 屬於「依賴關係」，優先考慮拓撲排序；
- 判斷是否有唯一的拓撲序列，可以在拓撲排序過程中判斷是否同時有多於一個入度爲 0 的頂點（也就是每次只有一個選擇）。

直接在拓撲排序的模板上進行修改即可。

![img](../../static/img/38853453c4.d/1732258142-image-1024x515.png)

對於比賽的處理，可以有以下幾種方法：

- 每次加一條邊，並進行拓撲排序，當序列唯一時輸出（注意清空）；
- 答案具有單調性，可以二分答案，對最大答案進行特判是否無解；

![img](../../static/img/38853453c4.d/1732258511-image.png)

- 拓撲排序相鄰兩個頂點之間的關係必須給出，因此可以在拓撲排序中記錄每一場必要的比賽的編號，然後依次掃描所有比賽，在所有比賽都出現的時候就可以輸出了。

![img](../../static/img/38853453c4.d/1732258881-image.png)

## 最短路算法

### BFS

當一張圖上不含邊權，或者邊權都相等，可以直接使用 BFS 計算最短路，算法正確且複雜度不高。

**例題：Nearest Opposite Parity（CF1272E）**

![img](../../static/img/38853453c4.d/1732259171-image-1024x373.png)

![img](../../static/img/38853453c4.d/1732259216-image-1024x533.png)

- 最簡單的方法：從每一個數開始，尋找最近的異性數字；
- 優化：從所有奇數出發，統計能到達所有偶數的最短路，對於偶數也這樣求出最短路；
- 反向建圖，也就是從 `i + a[i]` 和 `i - a[i]` 連一條到 `i` 的邊，也就是從**終點**出發，尋找到每一個起點的最短路；

代碼：

![img](../../static/img/38853453c4.d/1732260193-image.png)

兩個 BFS 基本一致，以到達奇數的 BFS 爲例：

![img](../../static/img/38853453c4.d/1732260233-image.png)

- 進一步進行優化，可以設置兩個超級源點 $n + 1$ 和 $n + 2$，分別對應奇數和偶數的源點。將所有的奇數和偶數分別連邊到對應源點，然後從源點開始 BFS。

代碼：

![img](../../static/img/38853453c4.d/1732260406-image.png)

注：上述反向建邊仍然需要。

![img](../../static/img/38853453c4.d/1732260498-image.png)

**例題：TAMNICA（洛谷 P6399）**

![img](../../static/img/38853453c4.d/1732260870-image.png)

- 最簡單的思路：模擬填充螺旋矩陣，然後將推倒的牆兩側的數連邊（關鍵邊）。最短路未必全部由關鍵邊構成，因此還需要建普通邊，然後使用 BFS 求最短路；

這代碼……

![img](../../static/img/38853453c4.d/1732261172-image-1024x440.png)

- 優化：不填充矩陣，用其他方法求出 B 對應的 A；並且減少建邊數量，具體方法較多，見代碼。

在沒有牆倒塌的情況下，顯然 $x$ 和 $y$ 之間的距離是 $|x - y|$，因此在普通邊的情況下可以不建邊，只需要將可以抄近道的關鍵點從小到大排序並去重，在相鄰兩個關鍵點之間連一條邊。

注意：

- 下標很大，可以用 `map` 和鏈式前向星；
- SPFA 當心卡常；
- 答案很大，賦初值要在 `1e16` 以上；
- 求 A 對面的 B 決定了最大時間複雜度，可以通過找規律在 $O(\log{n})$ 以下的時間複雜度內找到。

![img](../../static/img/38853453c4.d/1732261891-image-1024x487.png)

代碼：

![img](../../static/img/38853453c4.d/1732262022-image.png)

## 通用最短路算法

最短路算法的核心操作：**鬆弛**。

對於一條 $(x,y)$ 的邊，如果有另一個點 $m$ 滿足 $(x,m)$ 的 $(m,y)$ 的權值小於前者，則可以將距離更新，稱爲鬆弛操作。

### Dijkstra 算法

操作步驟：

![img](../../static/img/38853453c4.d/1732263963-image-1024x602.png)

代碼：

![img](../../static/img/38853453c4.d/1732264161-image.png)

**例題：Roadblock（洛谷 P2176）**

![img](../../static/img/38853453c4.d/1732264310-image-1024x336.png)

枚舉最短路上的每一條邊，依次加倍並求最短路。（其實直接枚舉所有邊也可以。）

**例題：次短路**

將上題中的最短路改爲此段路。

思路：維護兩個數組，在鬆弛時分別更新最短路和次短路。

![img](../../static/img/38853453c4.d/1732264600-image-1024x569.png)

**例題：聯絡計劃（NIKKEI PC Contest 2019-2D）**

![img](../../static/img/38853453c4.d/1732264684-image-1024x503.png)

在 $L$ 到 $R$ 之間建一條邊，然後在相鄰的兩個點之間反向建權值爲 0 的邊，等效地實現建所有邊的目標

## Bellman-Ford 及相關

![img](../../static/img/38853453c4.d/1732265075-image.png)

Bellman-Ford 可以檢測負環。如果經過 `n - 1` 次鬆弛操作之後，仍然有可以鬆弛的邊，證明存在負環。

![img](../../static/img/38853453c4.d/1732265143-image.png)

時間複雜度爲 $O(nm)$，算法瓶頸在於每一輪鬆弛都需要掃描無用的邊。通過隊列可以優化，使接下來的遍歷中不會反覆訪問。

![img](../../static/img/38853453c4.d/1732265244-image-1024x528.png)

代碼：

![img](../../static/img/38853453c4.d/1732265284-image-1024x491.png)

SPFA 算法時間複雜度爲 $O(km)$ ，其中 $k$ *通常*是一個很小的常數，但是通過構造可以將 $k$ 搞得很大。

**例題：穿越蟲洞 POJ3259**

判斷負環，不再贅述。

**例題：愛情之路 HDU4360**

*臭 名 昭 著*

![img](../../static/img/38853453c4.d/1732265520-image-1024x463.png)

分析：

![img](../../static/img/38853453c4.d/1732265608-image-1024x405.png)

代碼：

![img](../../static/img/38853453c4.d/1732265671-image.png)

**例題：最優貿易（NOIP2009 提高組，洛谷 P1073）**

分析：

- 不可以使用 Dijkstra，反例：

![img](../../static/img/38853453c4.d/1732265977-image-1024x462.png)

本題其實可以使用記憶化搜索通過，但是其他時間複雜度正確的方法包括 SPFA 和分層圖。

![img](../../static/img/38853453c4.d/1732266104-image-1024x387.png)

**壓軸題：最優星際貿易（COCI2012/2013 Final）**

![img](../../static/img/38853453c4.d/1732266280-image-1024x139.png)

*60pts* 做法：暴力枚舉 $x$ 所有可能的值，對於一對 $a$ 和 $b$，假設所有權值爲 $x$ 的邊都走不通，此時若走不通，且 $x = 1$ 時還是走不通，輸出 `0 0`；若後者不成立，則輸出 `inf`。

否則，$x$ 可能產生的貢獻一定在原來的權值之下，從 $1$ 開始枚舉每一個 $x$ 的值運行 Dijkstra。若此時路徑長度超過了原權值，那麼一定不會產生貢獻，退出，否則加入集合去重。

## 下課！
