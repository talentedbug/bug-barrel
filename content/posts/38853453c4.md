---
date: '2024-11-22T00:00:00+08:00'
draft: false
title: '集训笔记：图论算法一'
typora-copy-images-to: '../../static/img/${filename}.d'
coverImage: 'https://www.loliapi.com/acg/pc/'
---

## 拓扑排序

拓扑排序是图论中的一种算法，适用于 DAG 中，可以用于求拓扑序列。拓扑排序的结果是一个线性序列，满足每个顶点在序列中只出现一次，且若存在 A 到 B 的路径，则 A 出现在 B 之前。拓扑序列通常不唯一。

基于 BFS（入度）的拓扑排序比较容易实现。

伪代码：

![img](../../static/img/38853453c4.d/1732257535-image-1024x315.png)

代码示例：

![img](../../static/img/38853453c4.d/1732257614-image-1024x470.png)

拓扑排序可以判断图中是否有环。如果最终所有顶点的入度都减少为 0，队列清空，则不存在环；否则则有环。

代码示例：

![img](../../static/img/38853453c4.d/1732257770-image.png)

**例题：机器人擂台赛（CF645D）**

![img](../../static/img/38853453c4.d/1732257837-image-1024x366.png)

分析：

- *没有自相矛盾*：没有环；
- *没有比赛包含相同机器人*：没有重边；
- 属于「依赖关系」，优先考虑拓扑排序；
- 判断是否有唯一的拓扑序列，可以在拓扑排序过程中判断是否同时有多于一个入度为 0 的顶点（也就是每次只有一个选择）。

直接在拓扑排序的模板上进行修改即可。

![img](../../static/img/38853453c4.d/1732258142-image-1024x515.png)

对于比赛的处理，可以有以下几种方法：

- 每次加一条边，并进行拓扑排序，当序列唯一时输出（注意清空）；
- 答案具有单调性，可以二分答案，对最大答案进行特判是否无解；

![img](../../static/img/38853453c4.d/1732258511-image.png)

- 拓扑排序相邻两个顶点之间的关系必须给出，因此可以在拓扑排序中记录每一场必要的比赛的编号，然后依次扫描所有比赛，在所有比赛都出现的时候就可以输出了。

![img](../../static/img/38853453c4.d/1732258881-image.png)

## 最短路算法

### BFS

当一张图上不含边权，或者边权都相等，可以直接使用 BFS 计算最短路，算法正确且复杂度不高。

**例题：Nearest Opposite Parity（CF1272E）**

![img](../../static/img/38853453c4.d/1732259171-image-1024x373.png)

![img](../../static/img/38853453c4.d/1732259216-image-1024x533.png)

- 最简单的方法：从每一个数开始，寻找最近的异性数字；
- 优化：从所有奇数出发，统计能到达所有偶数的最短路，对于偶数也这样求出最短路；
- 反向建图，也就是从 `i + a[i]` 和 `i - a[i]` 连一条到 `i` 的边，也就是从**终点**出发，寻找到每一个起点的最短路；

代码：

![img](../../static/img/38853453c4.d/1732260193-image.png)

两个 BFS 基本一致，以到达奇数的 BFS 为例：

![img](../../static/img/38853453c4.d/1732260233-image.png)

- 进一步进行优化，可以设置两个超级源点 $n + 1$ 和 $n + 2$，分别对应奇数和偶数的源点。将所有的奇数和偶数分别连边到对应源点，然后从源点开始 BFS。

代码：

![img](../../static/img/38853453c4.d/1732260406-image.png)

注：上述反向建边仍然需要。

![img](../../static/img/38853453c4.d/1732260498-image.png)

**例题：TAMNICA（洛谷 P6399）**

![img](../../static/img/38853453c4.d/1732260870-image.png)

- 最简单的思路：模拟填充螺旋矩阵，然后将推倒的墙两侧的数连边（关键边）。最短路未必全部由关键边构成，因此还需要建普通边，然后使用 BFS 求最短路；

这代码……

![img](../../static/img/38853453c4.d/1732261172-image-1024x440.png)

- 优化：不填充矩阵，用其他方法求出 B 对应的 A；并且减少建边数量，具体方法较多，见代码。

在没有墙倒塌的情况下，显然 $x$ 和 $y$ 之间的距离是 $|x - y|$，因此在普通边的情况下可以不建边，只需要将可以抄近道的关键点从小到大排序并去重，在相邻两个关键点之间连一条边。

注意：

- 下标很大，可以用 `map` 和链式前向星；
- SPFA 当心卡常；
- 答案很大，赋初值要在 `1e16` 以上；
- 求 A 对面的 B 决定了最大时间复杂度，可以通过找规律在 $O(\log{n})$ 以下的时间复杂度内找到。

![img](../../static/img/38853453c4.d/1732261891-image-1024x487.png)

代码：

![img](../../static/img/38853453c4.d/1732262022-image.png)

## 通用最短路算法

最短路算法的核心操作：**松弛**。

对于一条 $(x,y)$ 的边，如果有另一个点 $m$ 满足 $(x,m)$ 的 $(m,y)$ 的权值小于前者，则可以将距离更新，称为松弛操作。

### Dijkstra 算法

操作步骤：

![img](../../static/img/38853453c4.d/1732263963-image-1024x602.png)

代码：

![img](../../static/img/38853453c4.d/1732264161-image.png)

**例题：Roadblock（洛谷 P2176）**

![img](../../static/img/38853453c4.d/1732264310-image-1024x336.png)

枚举最短路上的每一条边，依次加倍并求最短路。（其实直接枚举所有边也可以。）

**例题：次短路**

将上题中的最短路改为此段路。

思路：维护两个数组，在松弛时分别更新最短路和次短路。

![img](../../static/img/38853453c4.d/1732264600-image-1024x569.png)

**例题：联络计划（NIKKEI PC Contest 2019-2D）**

![img](../../static/img/38853453c4.d/1732264684-image-1024x503.png)

在 $L$ 到 $R$ 之间建一条边，然后在相邻的两个点之间反向建权值为 0 的边，等效地实现建所有边的目标

## Bellman-Ford 及相关

![img](../../static/img/38853453c4.d/1732265075-image.png)

Bellman-Ford 可以检测负环。如果经过 `n - 1` 次松弛操作之后，仍然有可以松弛的边，证明存在负环。

![img](../../static/img/38853453c4.d/1732265143-image.png)

时间复杂度为 $O(nm)$，算法瓶颈在于每一轮松弛都需要扫描无用的边。通过队列可以优化，使接下来的遍历中不会反复访问。

![img](../../static/img/38853453c4.d/1732265244-image-1024x528.png)

代码：

![img](../../static/img/38853453c4.d/1732265284-image-1024x491.png)

SPFA 算法时间复杂度为 $O(km)$ ，其中 $k$ *通常*是一个很小的常数，但是通过构造可以将 $k$ 搞得很大。

**例题：穿越虫洞 POJ3259**

判断负环，不再赘述。

**例题：爱情之路 HDU4360**

*臭 名 昭 著*

![img](../../static/img/38853453c4.d/1732265520-image-1024x463.png)

分析：

![img](../../static/img/38853453c4.d/1732265608-image-1024x405.png)

代码：

![img](../../static/img/38853453c4.d/1732265671-image.png)

**例题：最优贸易（NOIP2009 提高组，洛谷 P1073）**

分析：

- 不可以使用 Dijkstra，反例：

![img](../../static/img/38853453c4.d/1732265977-image-1024x462.png)

本题其实可以使用记忆化搜索通过，但是其他时间复杂度正确的方法包括 SPFA 和分层图。

![img](../../static/img/38853453c4.d/1732266104-image-1024x387.png)

**压轴题：最优星际贸易（COCI2012/2013 Final）**

![img](../../static/img/38853453c4.d/1732266280-image-1024x139.png)

*60pts* 做法：暴力枚举 $x$ 所有可能的值，对于一对 $a$ 和 $b$，假设所有权值为 $x$ 的边都走不通，此时若走不通，且 $x = 1$ 时还是走不通，输出 `0 0`；若后者不成立，则输出 `inf`。

否则，$x$ 可能产生的贡献一定在原来的权值之下，从 $1$ 开始枚举每一个 $x$ 的值运行 Dijkstra。若此时路径长度超过了原权值，那么一定不会产生贡献，退出，否则加入集合去重。

## 下课！
