---
date: '2024-11-27T00:00:00+08:00'
draft: false
title: 'DP 優化的常見方法'
typora-copy-images-to: '../../static/img/${filename}.d'
---

對於樸素 DP，有幾種常見的優化方法，本文主要介紹**單調隊列**和**斜率**優化。

## 單調隊列優化 DP

例題：[P1886 滑動窗口 /【模板】單調隊列](https://www.luogu.com.cn/problem/P1886)

單調隊列是一種特殊的雙端隊列，從字面上理解，就是具有某種單調性的隊列，例如遞增或者遞減。一般來說單調隊列可以用於維護最值，解決滑動窗口類的問題，時間複雜度是 $O(n)$。

單調隊列的維護可以通過不斷添加新元素，並不定時訪問或者刪除舊的元素。

以上述例題爲例，我們可以如何求出單調隊列的長度呢？

- 最簡單的方法：枚舉滑動窗口的左端點和窗口長度，再求出區間內的最大、最小值，時間複雜度 $O(n^{2}k)$；
- RMQ（區間最值）類算法：同樣枚舉區間，通過預處理優化求區間最值的時間複雜度，最終爲 $O(n^2 \log_{2} n)$。

我們可以發現，這兩個算法都存在一個問題：一個序列 $a_{i},a_{i+1} \cdots a_{j}$ 和同樣長度的 $a_{i+1},a_{i+2} \cdots a_{j+1}$，其中有長達 $j-i-1$ 的區間是重複的。

這裏，單調隊列優化就有用了。我們用一個例子來說明單調隊列如何工作：

```
1 4 5 -1 0 3 1
```

假設當前的區間長度 $k=4$，我們只求最小值，那麼：

- 隊列初始爲空，1 入隊；
- 由於 1 入隊時間早於 4，有可能在 1 出隊後，4 成爲新的最小值，因此 4 進隊；
- 同上原因，5 入隊；
- 這時候我們遇到了 -1，它小於隊尾的 5，並且 -1 的入隊時間晚於 5。那麼如果 -1 入隊，5 出隊早於 -1，並且只要 -1 在隊中，最小值都不可能是 5，因此 5 出隊；
- 同上原因，4 出隊；
- 由於上面主要原因已經講完了，所以下面就簡單地帶過：0 時間晚，入隊；
- 3 時間晚，入隊；
- 1 時間晚，且值小，3 出隊，1 入隊。

通過上述過程，我們可以發現，無論到哪一位，我們都維護了一個**單調**遞減的隊列。由於本題還要求區間長度，我們還應當記錄隊列中元素的位置，如果超出範圍就同樣出隊。

那麼問題來了，時間複雜度是什麼？看起來，我們枚舉左端點，還要將一些不符合條件的元素出隊，好像來到了二次方，但是考慮枚舉左端點時，所有節點只會進隊一次、出隊一次，所以本題總時間複雜度可以優化到 $O(n)$。

代碼實現：

```
#include <bits/stdc++.h>

using namespace std;
int n, k;
int a[1200000];

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    deque<pair<int, int>> q;
    for (int i = 1; i <= n; i++) {
        while (!q.empty()) {
            if (q.back().second > a[i]) {
                q.pop_back();
            } else {
                break;
            }
        }
        while (!q.empty()) {
            if (q.front().first <= i - k) {
                q.pop_front();
            } else {
                break;
            }
        }
        q.push_back({i, a[i]});
        if (i >= k) {
            cout << q.front().second << " ";
        }
    }
    cout << endl;
    q.clear();
    for (int i = 1; i <= n; i++) {
        while (!q.empty()) {
            if (q.back().second < a[i]) {
                q.pop_back();
            } else {
                break;
            }
        }
        while (!q.empty()) {
            if (q.front().first <= i - k) {
                q.pop_front();
            } else {
                break;
            }
        }
        q.push_back({i, a[i]});
        if (i >= k) {
            cout << q.front().second << " ";
        }
    }
    return 0;
}
```

本題的題解大多采用的是數組模擬隊列，但是本蛾子認爲雖然 STL 的常數是模擬的 1.5 倍，但我們必須知道這是因爲其功能的豐富。一個冷知識，deque 可以隨機訪問；另一個冷知識，幾乎所有 STL 容器都可以順序訪問；再一個冷知識，map、set 等加入元素會自動排序。在數據範圍明確的情況下，我們還是要遵循 C++ 封裝的思想。

那麼，這與 DP 有啥關係？很顯然，例如在 LIS 中，我們需要在前面所有的 DP 狀態中尋找滿足某個條件的最大值，那麼我們可以用一個單調隊列維護最長 LIS，代碼實現在之前的集訓筆記中已經記錄了，大家自取：[集訓筆記：動態規劃經典模型 1](https://old.bug-barrel.top/archives/55)。

至於其他應用，本蛾子實在來不及寫了，大家可以參考這篇洛谷博客，講得也很好：[單調隊列優化dp](https://www.luogu.com.cn/article/1u1affxp)，也可以自行在 OI Wiki 上搜索相關僞代碼來理解。

## 斜率優化 DP

相比於很直接、簡潔的單調隊列優化，斜率優化就複雜了許多。

前面我們看到的單調隊列優化，主要適用於狀態轉移方程類似 $f_{i}=\min_{0 \leq j \leq i-1} f_{j}+a_{i}+b_{j}$ 的 DP，因爲這裏求最小值的操作是線性的。

但是，當我們遇到形如 $f_{i}=\min_{0 \leq j \leq i-1} f_{j}+a_{i} \times b_{j}$ 的方程，我們就需要進行斜率優化來獲得更高效的算法。

例題：[HDU3507 Print Article](https://vjudge.net/problem/HDU-3507)

我們可以發現，如果文章分段數增加，會導致每段的長度減少，二者互相牽制，因此無法貪心。

設 $f_{i}$ 表示打印前 $i$ 個單詞的最小成本，$s_{i}$ 則是 $c_{1} \cdots lc_{i}$ 的前綴和。自然地可以得到狀態轉移方程：

$f_{i}=\min_{0 \leq j \leq i-1} f_{i}+(s_{i}-s_{j})^2+M$

選定一個 $j$，並將 $i$ 看作常量，移項並整理可以推出：

$f_{j}+s_{j}^2=2s_{i} s_{j}+f_{i}-s_{i}^2-M$

這個式子看起來很複雜，但是我們牢記所有含 $i$ 都是常量，對比一次函數的式子 $y=kx+b$，我們將 $f_{i}+s_{j}^2$ 看作 $y$，將 $s_{j}$ 看作 $x$，將 $2s_{i}$ 看作 $k$，將剩餘的部分全部看作常量 $b$。

當我們取不同的 $j$ 時，可以發現對應了平面直角座標系中的不同的點 $(x,y)$。

![img](../../static/img/1ec9f00dde.d/image-27.png)

> 注：此處圖片引用原視頻，在文末的參考中列出。
>
> 原視頻和本文在這裏都將左式寫爲兩項之和，但是其實可以將常數 $f_{j}$ 移項到右邊。另外，其實紅點和黑點是二次函數的圖像而不是一次函數，是我們將它簡化了。

回過頭看原來的方程，實際上我們是要求一個 $j$ 使得函數值 $f_{i}$ 最小。那麼當 $i$ 一定，斜率也就確定了，截距 $b$ 最小時，$f_{i}$ 也可以取到最小值。也就是說，當斜率 $k$ 對應的直線與函數圖像相切時，截距可以取到最小值。

觀察可以發現，相切的點左側斜率都小於綠色直線，右側都大於，我們可以通過二分查找位於二者分界處的點。

當 $i$ 發生變化，例如增加時，斜率增大，依然要尋找這樣的點，我們可以通過單調隊列維護。

- 若新點與隊尾點的斜率小於等於隊尾與相鄰點的斜率，就會出現與凸包相反的方向，此時我們應該將隊尾出隊，維護下凸包狀態；
- 重複執行上述操作，直到凸包狀態可以維持；
- 新點入隊；
- 將隊頭所有斜率小於當前直線的節點全部出隊；
- 此時，隊頭點應當恰好相切，就是最優決策。

代碼實現：

![img](../../static/img/1ec9f00dde.d/image-28.png)

> 代碼借用了參考的視頻，感謝！

## 下課！

本蛾子還是太着急了，所以來不及多寫一些。

後天就要上 NOIP 考場了今天寫這個是不是廢了……

> 從 12 月穿越回來的幺蛾子：「是的。」

## 參考和引用

- [單調隊列優化dp](https://www.luogu.com.cn/article/1u1affxp) - [XyzL](https://www.luogu.com.cn/user/130812)；
- [E51【模板】斜率優化DP 打印文章](https://www.bilibili.com/video/BV1CM4y147Ef) - [董曉算法](https://space.bilibili.com/517494241)。
