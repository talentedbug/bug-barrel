---
date: '2024-11-20T00:00:00+08:00'
draft: false
title: 'CF1272E Nearest Opposite Parity 題解'
typora-copy-images-to: '../../static/img/${filename}.d'
---

[洛谷題解](https://www.luogu.com.cn/article/0m4pa5w4)

## 題意簡述

[原題鏈接（CF）](https://codeforces.com/problemset/problem/1272/E)

給出長度爲 $n$ 的序列 $a$，允許從某個數 $a_{i}$ 向前或向後跳躍 $a_{i}$ 個數（跳躍後的位置在序列內），要求求出從奇偶性不同的另一個數到每個數的最短距離。

## 分析

首先很容易想到一個符合直覺的方案：對於每一個數，我們以它爲源點計算最短路（使用圖論算法；由於邊權都是 1，還可以用 BFS），然後找到距離最近、奇偶性相反的數，輸出距離。

但是這個方法的問題很明顯：枚舉每個數字，再加上 BFS，至少也是 $O(n^2)$ 的時間複雜度，如果用圖論算法還得更高。

我們希望能在一次 BFS 之後就得出每個點的最短路，這樣時間複雜度就來到了 $O(n)$。

這裏的難點就是**反向建邊**，即從 $i \pm a_{i}$ 建立到 $i$ 的邊。其他大佬的題解自然地提到了反向建邊，但是對我這樣的蒟蒻，爲什麼反向建邊更重要。這出於兩個原因：

- 輸出要求是**到達**每個數的最短路徑，如果存儲的也是到達的路徑長度顯然更方便；
- BFS 中，如果我們反向地遍歷，可以避免正向遍歷所導致的反覆遍歷：我們將從結果推開頭，這樣不需要對每個源點一一遍歷。

有了這個概念，我們就可以將所有數字分爲奇數和偶數。定義 $ev_{i}$ 是**從**偶數到 $i$ 的最短路徑，$od_{i}$ 是**從**奇數到 $i$ 的最短路徑，那麼顯然奇數 $a_{i}$ 的 $od_{i}$、偶數 $a_{j}$ 的 $ev_{j}$ 均爲 0。

我們將偶數提前入隊，從它們開始跑一遍 BFS，去求出**從偶數**到達每一個數的最短路徑；對於奇數也是同樣的操作。

那麼現在就很清楚了，我們已經有了從奇數或者偶數到達一個點的最短路徑（BFS 路徑就是最短路），輸出直接選擇與 $a_{i}$ 相反的那個路徑長度即可。

## 代碼實現

變量名對應表：

- `n`：原題中 `N`；
- `a`：原題中 `a`;
- `ev`，`od`：見上文；
- `edge`：邊：
- `f`，`t`：邊的首、尾；
- `n`：下一條邊（用於遍歷）；
- `ec`：邊的計數；
- `pre`：以某個點爲首的第一條邊（用於遍歷）；
- `vis`：訪問記錄（用於 BFS），注意清零；
- `ev_q`，`od_q`：用於偶數、奇數 BFS 的隊列。

```
#include <bits/stdc++.h>

using namespace std;
int n;
int a[220000];
int ev[220000], od[220000];

// 鏈式前向星，其實鄰接表也行
struct edge {
    int f, t;
    int n;
} e[420000];
int ec;
int pre[220000];
bool vis[220000];
void add(int f, int t) {
    e[++ec].f = f;
    e[ec].t = t;
    e[ec].n = pre[f];
    pre[f] = ec;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (i - a[i] >= 1) {
            add(i - a[i], i); // 反向建邊
        }
        if (i + a[i] <= n) {
            add(i + a[i], i);
        }
    }
    memset(vis, 0, sizeof(vis)); // 清空
    queue<int> ev_q;
    for (int i = 1; i <= n; i++) {
        if (a[i] % 2 == 0) {
            ev[i] = 0;
            ev_q.push(i);
            vis[i] = true; // 初始化本來就是偶數的數，距離爲 0，入隊
        } else {
            ev[i] = INT_MAX; // 否則初始化爲無窮大
        }
    }
    while (!ev_q.empty()) { // BFS，基本就是模板
        int id = ev_q.front();
        ev_q.pop();
        vis[id] = false;
        for (int i = pre[id]; i; i = e[i].n) {
            if (ev[e[i].t] > ev[id] + 1) {
                ev[e[i].t] = ev[id] + 1;
                if (!vis[e[i].t]) {
                    ev_q.push(e[i].t);
                    vis[e[i].t] = true;
                }
            }
        }
    }
    memset(vis, 0, sizeof(vis)); // 下面一模一樣
    queue<int> od_q;
    for (int i = 1; i <= n; i++) {
        if (a[i] % 2 == 1) {
            vis[i] = true;
            od[i] = 0;
            od_q.push(i);
        } else {
            od[i] = INT_MAX;
        }
    }
    while (!od_q.empty()) {
        int id = od_q.front();
        od_q.pop();
        vis[id] = false;
        for (int i = pre[id]; i; i = e[i].n) {
            if (od[e[i].t] > od[id] + 1) {
                od[e[i].t] = od[id] + 1;
                if (!vis[e[i].t]) {
                    od_q.push(e[i].t);
                    vis[e[i].t] = true;
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        int k;
        if (a[i] % 2 == 0) {
            k = od[i]; // 輸出，輸出與當前數字奇偶性不同的距離
        } else {
            k = ev[i];
        }
        if (k == INT_MAX) {
            cout << "-1 "; // 無法到達
        } else {
            cout << k << " ";
        }
    }
    cout << endl; // 換行好習慣
    return 0;
}
```
